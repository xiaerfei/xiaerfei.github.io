<!doctype html>
<html class="theme-next use-motion theme-next-mist">
<head>
  

<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />








  <link rel="stylesheet" type="text/css" href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5"/>




<link rel="stylesheet" type="text/css" href="/css/main.css?v=0.4.5.1"/>


    <meta name="description" content="just do it !" />



  <meta name="keywords" content="Hexo,next" />





  <link rel="shorticon icon" type="image/x-icon" href="/favicon.ico?v=0.4.5.1" />


<meta name="description" content="just do it !">
<meta property="og:type" content="website">
<meta property="og:title" content="吾生也有涯，而知也无涯">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="吾生也有涯，而知也无涯">
<meta property="og:description" content="just do it !">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="吾生也有涯，而知也无涯">
<meta name="twitter:description" content="just do it !">


<script type="text/javascript" id="hexo.configuration">
  var CONFIG = {
    scheme: 'Mist',
    sidebar: 'post'
  };
</script>



  <title> 吾生也有涯，而知也无涯 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  <!--[if lte IE 8]>
  <div style=' clear: both; height: 59px; padding:0 0 0 15px; position: relative;margin:0 auto;'>
    <a href="http://windows.microsoft.com/en-US/internet-explorer/products/ie/home?ocid=ie6_countdown_bannercode">
      <img src="http://7u2nvr.com1.z0.glb.clouddn.com/picouterie.jpg" border="0" height="42" width="820"
           alt="You are using an outdated browser. For a faster, safer browsing experience, upgrade for free today or use other browser ,like chrome firefox safari."
           style='margin-left:auto;margin-right:auto;display: block;'/>
    </a>
  </div>
<![endif]-->
  






  <div class="container one-column 
   page-home 
">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><h1 class="site-meta">
  <span class="logo-line-before"><i></i></span>
  <a href="/" class="brand" rel="start">
      <span class="logo">
        <i class="icon-next-logo"></i>
      </span>
      <span class="site-title">吾生也有涯，而知也无涯</span>
  </a>
  <span class="logo-line-after"><i></i></span>
</h1>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu ">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            <i class="menu-item-icon icon-next-home"></i> <br />
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            <i class="menu-item-icon icon-next-archives"></i> <br />
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            <i class="menu-item-icon icon-next-tags"></i> <br />
            标签
          </a>
        </li>
      

      
      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div id="content" class="content"> 
  <section id="posts" class="posts-expand">
    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2017/12/15/JSPatch/" itemprop="url">
                从“0”实现一个JSPatch
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2017-12-15T12:19:20+08:00" content="2017-12-15">
            2017-12-15
          </time>
        </span>

        

        
          
        
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><h2 id="引言">引言</h2><p>之前写了一篇 <a href="http://xiaerfei.github.io/2016/04/23/JSPatch-stduy/" target="_blank" rel="external">JSPatch 学习</a> 的基础教程。时过一年之后，JSPatch 已经被 Apple 封杀，周围同事已经很少再使用了。但当下动态化部署十分火热(RN、Weex)，研究一下 JSPatch 的源码对我们的帮助很大。</p>
<p>本篇并不是给大家分析 JSPatch 的源码</p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2017/10/27/data-communication-etherNet/" itemprop="url">
                计算机网络基础-以太网
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2017-10-27T05:28:00+08:00" content="2017-10-27">
            2017-10-27
          </time>
        </span>

        

        
          
        
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><h2 id="总线形以太网">总线形以太网</h2><p>学习内容有一下几点：</p>
<ul>
<li>[x] 总线形以太网拓扑结构</li>
<li>[x] 总线形以太网功能需求</li>
<li>[x] 总线形以太网体系结构</li>
</ul>
<h3 id="拓扑结构">拓扑结构</h3><p><img src="http://7xv4w8.com1.z0.glb.clouddn.com/%E4%BB%A5%E5%A4%AA%E7%BD%91-%E6%9C%80%E6%97%A9%E7%9A%84%E4%BB%A5%E5%A4%AA%E7%BD%91%E8%AE%BE%E8%AE%A1%E5%9B%BE.png" alt=""></p>
<p><img src="http://7xv4w8.com1.z0.glb.clouddn.com/%E4%BB%A5%E5%A4%AA%E7%BD%91-%E6%80%BB%E7%BA%BF%E4%BB%A5%E5%A4%AA%E7%BD%91%E6%8B%93%E6%89%91%E7%BB%93%E6%9E%84.png" alt=""></p>
<p>为了防止总线两端的反射信号，在总线两端各接一个匹配阻抗。任何终端向总线上发送信号，信号都会迅速向总线的两端传播。</p>
<p><strong>距离问题:互联起来的终端，他们之间的距离有什么要求?</strong><br>我们都知道，信号的传播随着距离的增加会衰减，然后变形、失真，所有要在适当的距离增加一个中继器，把变形的信号还原为原来发送的信号。</p>
<p><img src="http://7xv4w8.com1.z0.glb.clouddn.com/%E4%BB%A5%E5%A4%AA%E7%BD%91-%E4%B8%AD%E7%BB%A7%E5%99%A8%E4%BD%9C%E7%94%A8.png" alt=""></p>
<p><strong>距离问题:互联起来的终端，他们之间的距离有什么要求?</strong></p>
<p><img src="http://7xv4w8.com1.z0.glb.clouddn.com/%E4%BB%A5%E5%A4%AA%E7%BD%91-%E6%80%BB%E7%BA%BF%E9%95%BF%E5%BA%A6.png" alt=""></p>
<p><em>从信号传播角度来说，只要不断增加中继器，总线的长度是无限的</em></p>
<h3 id="功能需求">功能需求</h3><p>要实现两个终端之间的数据通信，必须解决这样一些问题:</p>
<p><img src="http://7xv4w8.com1.z0.glb.clouddn.com/%E4%BB%A5%E5%A4%AA%E7%BD%91-%E5%8A%9F%E8%83%BD%E9%9C%80%E6%B1%82%E9%97%AE%E9%A2%98.png" alt=""></p>
<h4 id="数据封装">数据封装</h4><p><strong>解决发什么?收什么?</strong></p>
<p>发送端发送数据，接收端要想接到数据，除数据外还要增加一些辅助信息，比如地址、数据类型等等，这就形成了一个<code>帧</code></p>
<p><img src="http://7xv4w8.com1.z0.glb.clouddn.com/%E4%BB%A5%E5%A4%AA%E7%BD%91-%E8%BE%85%E5%8A%A9%E4%BF%A1%E6%81%AF.png" alt=""></p>
<p><em>发送端以帧为单位发送，接收端以帧为单位接收</em></p>
<p><img src="http://7xv4w8.com1.z0.glb.clouddn.com/%E4%BB%A5%E5%A4%AA%E7%BD%91-%E5%B8%A7.png" alt=""></p>
<h3 id="数据与信号转换">数据与信号转换</h3><p><strong>解决怎么发?怎么收?</strong></p>
<p><code>发送终端:</code> 把构成帧的二进制位流转换成信号<br><code>接收终端:</code> 把从总线上接收到的信号转换成一串二进制位流</p>
<h3 id="帧对界">帧对界</h3><p><strong>解决怎么收?</strong></p>
<p><code>接收终端:</code> 从一串二进制位流中正确提取出每一帧</p>
<h3 id="检测总线状态">检测总线状态</h3><p><strong>解决什么时候发?什么时候收?</strong></p>
<p><code>传输媒体:</code> 同轴电缆<br><code>信息交换的方式:</code> 半双工通信</p>
<p><img src="http://7xv4w8.com1.z0.glb.clouddn.com/%E4%BB%A5%E5%A4%AA%E7%BD%91-%E6%A3%80%E6%B5%8B%E6%80%BB%E7%BA%BF%E7%8A%B6%E6%80%81.png" alt=""></p>
<p><em>总线状态空闲仅仅是发送数据的前提</em></p>
<h3 id="公平竞争总线的机制">公平竞争总线的机制</h3><p><strong>解决什么时候发 ?</strong></p>
<p><em>需要有一种机制保证只有一个终端能够 成功发送数据，而且每一个终端成功发送数 据的几率还要是均等的</em></p>
<h3 id="寻址">寻址</h3><p><strong>解决由谁来收 ?</strong></p>
<p><img src="http://7xv4w8.com1.z0.glb.clouddn.com/%E4%BB%A5%E5%A4%AA%E7%BD%91-%E5%AF%BB%E5%9D%80.png" alt=""></p>
<p><em>每一个终端能够判别自己是否是数据 的接收者，当确定自己是数据接收者 的时候才接收。</em></p>
<h2 id="基带传输和曼彻斯特编码">基带传输和曼彻斯特编码</h2><p>学习内容有一下几点：</p>
<ul>
<li>[x] 什么是基带传输</li>
<li>[x] 如何用基带信号表示和还原数据</li>
<li>[x] 什么是曼彻斯特编码</li>
<li>[x] 如何用曼彻斯特编码实现位同步</li>
</ul>
<h3 id="什么是基带传输">什么是基带传输</h3><p><strong>基带传输就是用基带信号实现数据传输的方式</strong><br>什么叫基带信号?<br>    ▷ 基带信号就是幅度只有两种离散值的数字信号</p>
<p><img src="" alt="基带信号表示"></p>
<h3 id="如何用基带信号表示和还原数据?">如何用基带信号表示和还原数据?</h3><p><strong>基带传输需要解决什么问题?</strong><br>    ▷ 如何用基带信号表示和还原数据</p>
<p>二进制数的单位是二进制位，基带信号的单位是码元。对基 带信号来说，码元就是一个二进制位所对应的信号。</p>
<p><img src="" alt="基带信号参数"></p>
<p><strong>码元长度与数据传输速率有关</strong></p>
<p>数据传输速率:10Mbps<br>每秒传输10M位二进制位<br>基带信号每秒产生10M个码元<br>码元长度=1/(10×10^6)s</p>
<p><img src="" alt="时钟周期"><br><img src="" alt="时钟周期等于码元长度"></p>
<p><strong>数据传输速率与时钟频率之间的关系</strong></p>
<p>数据传输速率:10Mbps<br>码元长度=1/(10×10^6)s<br>时钟周期=1/(10×10^6)s<br>时钟频率=1/时钟周期=10MHz</p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2017/10/24/data-communication-base/" itemprop="url">
                计算机网络基础-数据通信基础
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2017-10-24T20:22:00+08:00" content="2017-10-24">
            2017-10-24
          </time>
        </span>

        

        
          
        
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><h2 id="数据传输系统">数据传输系统</h2><p>学习内容有一下几点：</p>
<ul>
<li>[x] 系统组成</li>
<li>[x] 系统功能</li>
<li>[x] 信道连接结点的方式</li>
<li>[x] 数据通信方式 </li>
</ul>
<h3 id="系统组成">系统组成</h3><p>数据传输系统由结点、收发器和信道组成</p>
<ul>
<li><p><code>结点:</code>可以是终端、服务器和交换机等设备</p>
<p>  ▷ 用于产生需要传输的二进制位流<br>  ▷ 或是接收二进制位流</p>
</li>
</ul>
<p><img src="http://7xv4w8.com1.z0.glb.clouddn.com/%E7%B3%BB%E7%BB%9F%E7%BB%84%E6%88%90-%E7%BB%93%E7%82%B9.png" alt=""></p>
<ul>
<li><p><code>收发器:</code></p>
<p>  ▷ 连接发送端的收发器实现将数据转换成信号的过程<br>  ▷ 连接接收端的收发器实现将信号还原成数据的过程</p>
</li>
</ul>
<p><img src="http://7xv4w8.com1.z0.glb.clouddn.com/%E7%B3%BB%E7%BB%9F%E7%BB%84%E6%88%90-%E6%94%B6%E5%8F%91%E5%99%A8.png" alt=""></p>
<ul>
<li><p><code>信道:</code>信号传播通道</p>
<p>  ▷ 传播光信号信道、传播电信号信道<br>  ▷ 有线信道、无线信道<br>  ▷ 单段物理链路信道、多段物理链路组合信道</p>
</li>
</ul>
<p><img src="http://7xv4w8.com1.z0.glb.clouddn.com/%E7%B3%BB%E7%BB%9F%E7%BB%84%E6%88%90-%E4%BF%A1%E9%81%93-1.png" alt=""></p>
<p><img src="http://7xv4w8.com1.z0.glb.clouddn.com/%E7%B3%BB%E7%BB%9F%E7%BB%84%E6%88%90-%E4%BF%A1%E9%81%93-2.png" alt=""></p>
<h3 id="系统功能">系统功能</h3><p><img src="http://7xv4w8.com1.z0.glb.clouddn.com/%E7%B3%BB%E7%BB%9F%E7%BB%84%E6%88%90-%E7%B3%BB%E7%BB%9F%E5%8A%9F%E8%83%BD.png" alt=""></p>
<h3 id="信道连接结点方式">信道连接结点方式</h3><p>根据同一信道连接设备的多少可以把信道连接设备的方式<br>分为点对点连接方式和多点连接方式</p>
<ul>
<li>点对点连接方式  只连接两个设备 </li>
<li>多点连接方式 连接三个及三个以上设备</li>
</ul>
<p><img src="http://7xv4w8.com1.z0.glb.clouddn.com/%E7%B3%BB%E7%BB%9F%E7%BB%84%E6%88%90-%E4%BF%A1%E9%81%93%E8%BF%9E%E6%8E%A5%E7%BB%93%E7%82%B9%E6%96%B9%E5%BC%8F.png" alt=""></p>
<h3 id="数据通信方式">数据通信方式</h3><ul>
<li><p><code>半双工通信:</code>又称双向交替通信，指数据允许沿两个方向传输，任一时刻只能沿一个方向传输数据</p>
<p>  ▷ 两端设备都允许发送、接收数据，但任一时刻不能同时既发送又接收数据。</p>
</li>
</ul>
<p><img src="http://7xv4w8.com1.z0.glb.clouddn.com/%E7%B3%BB%E7%BB%9F%E7%BB%84%E6%88%90-%E5%8D%8A%E5%8F%8C%E5%B7%A5%E9%80%9A%E4%BF%A1.png" alt=""></p>
<ul>
<li><p><code>全双工通信:</code>又称双向同时通信，指允许同时沿两个方向传输 数据，这种通信方式下，两端设备之间必须同时存在两个方向 的信道。</p>
<p>  ▷ 一般情况下，采用全双工通信方式的数据传输系统，信道连接 方式为点对点连接方式，且两个设备由双向信道(允许同时双 向通信的信道)互连。</p>
</li>
</ul>
<p><img src="http://7xv4w8.com1.z0.glb.clouddn.com/%E7%B3%BB%E7%BB%9F%E7%BB%84%E6%88%90-%E5%85%A8%E5%8F%8C%E5%B7%A5%E9%80%9A%E4%BF%A1.png" alt=""></p>
<hr>
<h2 id="信号">信号</h2><p>学习内容有一下几点：</p>
<ul>
<li>[x] 正弦波信号</li>
<li>[x] 数字信号</li>
<li>[x] 模拟信号</li>
<li>[x] 信号的失真和还原 </li>
</ul>
<h3 id="正弦波信号">正弦波信号</h3><p>周期性的数字信号和模拟信号可以用一组不同频率的正弦波信号表示</p>
<p><img src="http://7xv4w8.com1.z0.glb.clouddn.com/%E4%BF%A1%E5%8F%B7-%E6%A8%A1%E6%8B%9F%E4%BF%A1%E5%8F%B7.png" alt=""></p>
<p>三个参数:</p>
<ul>
<li>幅度:A</li>
<li>频率 :1/T</li>
<li>初始相位(简称相位): φ</li>
</ul>
<h3 id="数字信号">数字信号</h3><p><img src="http://7xv4w8.com1.z0.glb.clouddn.com/%E4%BF%A1%E5%8F%B7-%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B71.png" alt=""></p>
<ul>
<li><code>数字信号:</code>幅度为有限离散值的信号数字信号改变幅度时，直接从一种幅度跳变到另一种幅度</li>
<li><code>基带信号:</code>幅度只有两种离散值的数字信号 基带信号为最常用的表示二进制位流的数字信号</li>
</ul>
<p><img src="http://7xv4w8.com1.z0.glb.clouddn.com/%E4%BF%A1%E5%8F%B7-%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B72.png" alt=""></p>
<ul>
<li><code>谐波:</code>用于合成周期性数字信号的不同频率的正弦波信号</li>
<li><code>拟合周期性数字信号:</code>由有限次谐波合成的接近原始周期性数字信号的信号</li>
<li><code>带宽:</code>用于形成拟合周期性数字信号的各次谐波的频率范围</li>
</ul>
<h3 id="模拟信号">模拟信号</h3><p><img src="http://7xv4w8.com1.z0.glb.clouddn.com/%E4%BF%A1%E5%8F%B7-%E6%A8%A1%E6%8B%9F%E4%BF%A1%E5%8F%B7%E5%B9%85%E5%BA%A6%E8%BF%9E%E7%BB%AD.png" alt=""></p>
<ul>
<li><code>拟合周期性模拟信号:</code>由有限次不同频率正弦波信号合成 的接近原周期性模拟信号的信号</li>
<li><code>模拟信号的带宽:</code>用于形成“拟合周期性模拟信号”的一 组不同频率的正弦波信号的频率范围</li>
</ul>
<h3 id="信号的失真和还原">信号的失真和还原</h3><p><img src="http://7xv4w8.com1.z0.glb.clouddn.com/%E4%BF%A1%E5%8F%B7-%E6%A8%A1%E6%8B%9F%E4%BF%A1%E5%8F%B7%E5%A4%B1%E7%9C%9F.png" alt=""></p>
<ul>
<li><p>数字信号和模拟信号都会引发失真</p>
<p>  ▷ <code>阻抗:</code>物理链路存在阻抗，阻抗与物理链路长度成正比<br>  ▷ <code>阻抗具有频率相关性:</code>相同物理链路对不同频率的信号呈现不同的<br>阻抗，不同频率的信号经过相同物理链路，有着不同的衰减程度</p>
</li>
<li><p>失真是因为相同物理链路上，不同频率的正弦波信号的衰减不同</p>
</li>
</ul>
<h4 id="数字信号还原">数字信号还原</h4><ul>
<li>幅度还原:通过设置阈值来还原幅度</li>
<li>宽度还原:通过时钟同步实现</li>
</ul>
<p><img src="http://7xv4w8.com1.z0.glb.clouddn.com/%E4%BF%A1%E5%8F%B7-%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E8%BF%98%E5%8E%9F.png" alt=""></p>
<p>基带信号不能还原的情况:</p>
<ul>
<li>失真后的低电平高于阈值:噪音</li>
<li>失真后的高电平低于阈值:衰减</li>
</ul>
<p><img src="http://7xv4w8.com1.z0.glb.clouddn.com/%E4%BF%A1%E5%8F%B7-%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E4%B8%8D%E8%83%BD%E8%BF%98%E5%8E%9F.png" alt=""></p>
<h4 id="模拟信号还原原理">模拟信号还原原理</h4><ul>
<li>幅度连续的信号只能通过放大信号来弥补信号衰减</li>
<li>构成模拟信号的各次谐波的衰减程度不同</li>
<li>必须对各次谐波单独设置放大电路</li>
</ul>
<p><img src="http://7xv4w8.com1.z0.glb.clouddn.com/%E4%BF%A1%E5%8F%B7-%E6%A8%A1%E6%8B%9F%E4%BF%A1%E5%8F%B7%E8%BF%98%E5%8E%9F%E5%8E%9F%E7%90%86.png" alt=""></p>
<h4 id="模拟信号还原复杂性">模拟信号还原复杂性</h4><ul>
<li>由于模拟信号是由无数谐波所组成的，为各次谐波单独设置放大电路是不可行的</li>
<li>为模拟信号设置单个统一的放大电路反而加剧失真 严重程度</li>
</ul>
<h3 id="小结">小结</h3><ul>
<li>数字信号和模拟信号都是由多次谐波组成的</li>
<li>数字信号和模拟信号通过物理链路传输都会引发失真</li>
<li>数字信号失真容易还原，模拟信号不容易还原</li>
</ul>
<hr>
<h2 id="调制">调制</h2><p>学习内容有一下几点：</p>
<ul>
<li>[x] 调制技术</li>
<li>[x] 模拟信号中码元的定义</li>
<li>[x] 奈奎斯特准则和香农定理</li>
</ul>
<h3 id="调制技术">调制技术</h3><ul>
<li>调制是将正弦波信号(或余弦波信号)转换成表示二进制位流的模拟 信号的过程</li>
<li>解调是从调制后的模拟信号中还原出二进制位流的过程</li>
</ul>
<p><img src="http://7xv4w8.com1.z0.glb.clouddn.com/%E8%B0%83%E5%88%B6%E6%8A%80%E6%9C%AF-%E8%B0%83%E5%88%B6%E8%A7%A3%E8%B0%83.png" alt=""></p>
<h4 id="振幅键控调制技术">振幅键控调制技术</h4><p>振幅键控调制技术(Amplitude Shift Keying，ASK):用两种 不同幅度的载波信号来表示两个不同的二进制数值，通常一种 幅度为0，另一种幅度采用正常值。</p>
<p><img src="http://7xv4w8.com1.z0.glb.clouddn.com/%E6%8C%AF%E5%B9%85%E9%94%AE%E6%8E%A7%E8%B0%83%E5%88%B6%E6%8A%80%E6%9C%AF.png" alt=""></p>
<h4 id="移频键控调制技术">移频键控调制技术</h4><p>移频键控调制技术(Frequency Shift Keying，FSK)用两种不同频率的信号来表示两个不同的二进制数值</p>
<p><img src="http://7xv4w8.com1.z0.glb.clouddn.com/%E7%A7%BB%E9%A2%91%E9%94%AE%E6%8E%A7%E8%B0%83%E5%88%B6%E6%8A%80%E6%9C%AF.png" alt=""></p>
<h4 id="移相键控调制技术">移相键控调制技术</h4><ul>
<li>移相键控调制技术(Phase Shift Keying，PSK):通过改变 载波的相位来表示不同的二进制数值:相对移相和绝对移相</li>
<li>相对移相:二进制数0的信号和前面信号相同相位，二进制数1 的信号和前面信号相反相位(相差180°)</li>
</ul>
<p><img src="http://7xv4w8.com1.z0.glb.clouddn.com/%E7%A7%BB%E7%9B%B8%E9%94%AE%E6%8E%A7%E8%B0%83%E5%88%B6%E6%8A%80%E6%9C%AF.png" alt=""></p>
<ul>
<li>移相键控调制技术(Phase Shift Keying，PSK):通过改变载波的相位来表示不同的二进制数值</li>
<li>绝对移相:二进制数0和二进制数1分别用两种不同的相反相位<br>(相差180°)的载波信号表示<img src="http://7xv4w8.com1.z0.glb.clouddn.com/%E7%BB%9D%E5%AF%B9%E7%A7%BB%E7%9B%B8.png" alt=""></li>
</ul>
<p><img src="http://7xv4w8.com1.z0.glb.clouddn.com/%E7%A7%BB%E7%9B%B8%E9%94%AE%E6%8E%A7%E8%B0%83%E5%88%B6%E6%8A%80%E6%9C%AF.png" alt=""></p>
<h3 id="码元的定义">码元的定义</h3><ul>
<li>码元长度:指维持正弦波信号(或余弦波信号)幅度、频率和相位不变的最短时间长度</li>
<li>码  元:如果将信号以码元长度为单位分隔，每一段码元长度内的信号</li>
</ul>
<p>码元是调制后用于表示二进制位流的模拟信号的基本信号单位</p>
<ul>
<li>波 特 率:单位时间内传输的码元数量</li>
</ul>
<p><img src="http://7xv4w8.com1.z0.glb.clouddn.com/%E7%A0%81%E5%85%83%E7%9A%84%E5%AE%9A%E4%B9%89.png" alt=""></p>
<h3 id="奈奎斯特准则和香农定理">奈奎斯特准则和香农定理</h3><h4 id="奈奎斯特准则">奈奎斯特准则</h4><p>奈奎斯特准则(理想信道):</p>
<ul>
<li>最大波特率 RP=2×BW(BW为信道带宽)</li>
<li>最大传输速率 RS=2×BW×log2n(n为信号的状态数)</li>
<li>最大传输速率也称为信道容量</li>
</ul>
<p>信道容量取决于信道带宽和经过信道传播的信号状态数</p>
<h4 id="香农定理">香农定理</h4><p>香农定理(随机热噪声的信道):</p>
<ul>
<li>最大传输速率 RS=BW×log2(1+S/N)(BW为信道带宽、S/N为信号信噪比)</li>
<li>香农定理表明，存在随机热噪声的信道中，信道最大传输速率取决于信道带宽和经过信道传播的信号的信噪比，与信号的编码或调制技术 无关。</li>
<li>奈奎斯特准则和香农定理给出了在指定信道的情况下获得较高数据传输速率的途径。</li>
</ul>
<hr>
<h2 id="差错控制_—_检错码">差错控制 — 检错码</h2><p>学习内容有一下几点：</p>
<ul>
<li>[x] 出错现象和原因</li>
<li>[x] 检错码</li>
</ul>
<h3 id="出错的现象和原因">出错的现象和原因</h3><ul>
<li>出错:发送端发送的二进制位流与接收端接收到的二进制位流不一致</li>
<li>出错的二进制位可能是一位，可能是随机多位，也可能是连续多位</li>
<li><p>计算机网络中</p>
<p>  ▷ 出错的二进制位往往是连续多位二进制位<br>  ▷ 出错的二进制位的起始位置是随机的</p>
</li>
</ul>
<p><img src="http://7xv4w8.com1.z0.glb.clouddn.com/%E5%B7%AE%E9%94%99%E6%8E%A7%E5%88%B6-%E5%87%BA%E9%94%99%E7%9A%84%E7%8E%B0%E8%B1%A1%E5%92%8C%E5%8E%9F%E5%9B%A0.png" alt=""></p>
<ul>
<li>二进制位流从发送端到接收端经历的每一个步骤都有可能出错。</li>
<li><p>提高数据传输速率增加出错概率</p>
<p>  ▷ 对于数字传输系统，往往通过增加幅度的离散值的数量来提高每<br>一位码元表示的二进制数位数。<br>  ▷ 对于模拟传输系统，往往通过增加信号的状态数来提高每一位码<br>元表示的二进制数位数。</p>
</li>
</ul>
<h3 id="检错码">检错码</h3><ul>
<li>检错码:为了使得接收端能够检测出数据传输过程中发生的错误而添加的附加信息。 </li>
</ul>
<blockquote>
<p>如果数据是D，检错码是C :C=f(D)</p>
</blockquote>
<p><img src="http://7xv4w8.com1.z0.glb.clouddn.com/%E5%B7%AE%E9%94%99%E6%8E%A7%E5%88%B6-%E6%A3%80%E9%94%99%E7%A0%81.png" alt=""></p>
<ul>
<li><p>计算检错码C的函数f最好具备以下特点:</p>
<p>  ▷ 不同的数据D对应着不同的C<br>  ▷ C的位数远小于D且固定<br>  ▷ 函数f计算过程简单</p>
</li>
<li><p>选择计算检错码C的函数f时，需要在函数f的计算复杂性、检错 码C的位数和传输出错检测能力这三方面进行综合平衡。</p>
<h4 id="检验和">检验和</h4><p>检验和根据数据D计算检错码C的计算过程:</p>
</li>
</ul>
<ol>
<li>将数据分为长度固定(一般是字节的整数倍)的数据段</li>
<li>根据反码运算规则累加分段后产生的每一段数据</li>
<li>将累加结果取反作为检错码C</li>
</ol>
<p><img src="http://7xv4w8.com1.z0.glb.clouddn.com/%E5%B7%AE%E9%94%99%E6%8E%A7%E5%88%B6-%E6%A3%80%E9%AA%8C%E5%92%8C.png" alt=""></p>
<ul>
<li>检验和方法简单，能检测出单段数据中连续多位二进制数错误</li>
<li>对于分布在多段数据中的二进制数错误，有可能无法检测出</li>
<li>检验和算法在计算机网络中常常被用来作为检错技术</li>
<li>为了提高传输网络的检错能力，需要和其他检错技术一起使用</li>
</ul>
<p><img src="http://7xv4w8.com1.z0.glb.clouddn.com/%E5%B7%AE%E9%94%99%E6%8E%A7%E5%88%B6-%E6%A3%80%E9%AA%8C%E5%92%8Cbug.png" alt=""></p>
<h4 id="循环冗余检验">循环冗余检验</h4><p>循环冗余检验(Cyclic Redundancy Check，CRC)的检错机制如下:</p>
<p><img src="http://7xv4w8.com1.z0.glb.clouddn.com/%E5%B7%AE%E9%94%99%E6%8E%A7%E5%88%B6-%E5%BE%AA%E7%8E%AF%E5%86%97%E4%BD%99%E6%A3%80%E9%AA%8C.png" alt=""></p>
<p>循环冗余码特点:</p>
<ul>
<li>通过精心挑选最高阶数为r的生成多项式G(X)</li>
<li>循环冗余检验可以检测出所有奇数位二进制数错，所有长度≤r的连续位错，和大多数长度≥r+1的连续位错。</li>
<li>目前Internet中常用的检错码是检验和与循环冗余检验(CRC)，CRC的检错能力远大于检验和。</li>
</ul>
<hr>
<h2 id="差错控制_—_确认和重传">差错控制 — 确认和重传</h2><p>学习内容有一下几点：</p>
<ul>
<li>[x] 数据传输和确认过程</li>
<li>[x] 重传机制</li>
<li>[x] 避免重复接收方法</li>
</ul>
<h3 id="数据传输和确认过程">数据传输和确认过程</h3><ul>
<li>发送端发送的数据帧由数据和检错码组成</li>
<li>接收端用检错码判别数据是否传输出错</li>
<li>在数据传输正确的情况下，接收端向发送 端发送确认应答(ACK)帧</li>
<li>发送端只有接收到接收端发送的确认应答 帧，才能确认数据帧正确传输。</li>
</ul>
<p><img src="http://7xv4w8.com1.z0.glb.clouddn.com/%E5%B7%AE%E9%94%99%E6%8E%A7%E5%88%B6-%E6%AD%A3%E5%B8%B8%E4%BC%A0%E8%BE%93%E8%BF%87%E7%A8%8B.png" alt=""></p>
<h3 id="重传机制">重传机制</h3><ul>
<li>接收端用检错码检测出数据传 输出错，不再发送确认应答帧</li>
<li>发送端在规定时间内没有接收 到确认应答帧，再次发送数据帧</li>
</ul>
<p><img src="http://7xv4w8.com1.z0.glb.clouddn.com/%E5%B7%AE%E9%94%99%E6%8E%A7%E5%88%B6-%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E5%87%BA%E9%94%99.png" alt=""></p>
<h3 id="序号和避免重复接收">序号和避免重复接收</h3><ul>
<li>确认应答帧在传输过程中出错</li>
<li>经过规定时间，发送端再次发送数据帧，接收端将重复接收数据帧。</li>
</ul>
<p><em>解决接收端重复接收数据帧问题的 方法是在发送的数据帧中增加序号</em></p>
<p><img src="http://7xv4w8.com1.z0.glb.clouddn.com/%E5%B7%AE%E9%94%99%E6%8E%A7%E5%88%B6-%E6%95%B0%E6%8D%AE%E9%87%8D%E5%A4%8D%E4%BC%A0%E8%BE%93.png" alt=""></p>
<ul>
<li>确认应答帧也需要携带确认序号n</li>
<li>确认序号为n说明小于n 的数据帧都已经正确接收</li>
</ul>
<p><img src="http://7xv4w8.com1.z0.glb.clouddn.com/%E5%B7%AE%E9%94%99%E6%8E%A7%E5%88%B6-%E9%81%BF%E5%85%8D%E9%87%8D%E5%A4%8D%E6%8E%A5%E6%94%B6.png" alt=""></p>
<ul>
<li>连续发送:在前一个数据确认之前可以发送下一个数据</li>
<li>累积确认:确认序号n 就确认了所有序号小于 n的数据帧。</li>
</ul>
<p><img src="http://7xv4w8.com1.z0.glb.clouddn.com/%E5%B7%AE%E9%94%99%E6%8E%A7%E5%88%B6-%E8%BF%9E%E7%BB%AD%E5%8F%91%E9%80%81%E5%92%8C%E7%B4%AF%E7%A7%AF%E7%A1%AE%E8%AE%A4.png" alt=""></p>
<ul>
<li>序号位数有限，比如2位</li>
<li><p>重复使用序号:</p>
<p>  ▷ 序号相同的没有被确认的 数据帧只能有一帧<br>  ▷ 接收端能够区分序号相同的不同数据帧</p>
</li>
</ul>
<p><img src="http://7xv4w8.com1.z0.glb.clouddn.com/%E5%B7%AE%E9%94%99%E6%8E%A7%E5%88%B6-%E9%87%8D%E5%A4%8D%E4%BD%BF%E7%94%A8%E5%BA%8F%E5%8F%B7.png" alt=""></p>
<h3 id="小结-1">小结</h3><ul>
<li>检错码:接收端判别数据是否正确</li>
<li>确认应答:发送端判别数据是否被正确接收</li>
<li>重传:出错数据必须重新发送</li>
<li>序号:避免接收端重复接收数据</li>
</ul>
<hr>
<h2 id="传输媒体">传输媒体</h2><p>学习内容有一下几点：</p>
<ul>
<li>[x] 同轴电缆</li>
<li>[x] 双绞线</li>
<li>[x] 光纤</li>
</ul>
<h3 id="同轴电缆">同轴电缆</h3><p>传输媒体也称为传输介质或传输媒介，用于构成数据传输系统中两个收<br>发器之间的信道。</p>
<p><img src="http://7xv4w8.com1.z0.glb.clouddn.com/%E4%BC%A0%E8%BE%93%E5%AA%92%E4%BD%93-%E4%BC%A0%E8%BE%93%E5%AA%92%E4%BD%93%E5%88%86%E7%B1%BB.png" alt=""></p>
<p><img src="http://7xv4w8.com1.z0.glb.clouddn.com/%E4%BC%A0%E8%BE%93%E5%AA%92%E4%BD%93-%E5%90%8C%E8%BD%B4%E7%94%B5%E7%BC%86%E7%BB%93%E6%9E%84.png" alt=""></p>
<p><strong>粗同轴电缆:</strong></p>
<ul>
<li>粗缆采用一种类似夹板的Tap装置进行安装</li>
<li>利用Tap上的引导针穿透电缆的绝缘层,直接与 导体相连</li>
<li>有一个外置收发器</li>
<li>可靠性好，抗干扰能力强</li>
</ul>
<p><img src="http://7xv4w8.com1.z0.glb.clouddn.com/%E4%BC%A0%E8%BE%93%E5%AA%92%E4%BD%93-%E7%B2%97%E5%90%8C%E8%BD%B4%E7%94%B5%E7%BC%86.png" alt=""></p>
<p><strong>细同轴电缆:</strong></p>
<ul>
<li>可靠性稍差</li>
<li>无外置收发器</li>
<li>轻便、灵活、成本较低</li>
</ul>
<p><img src="http://7xv4w8.com1.z0.glb.clouddn.com/%E4%BC%A0%E8%BE%93%E5%AA%92%E4%BD%93-%E7%BB%86%E5%90%8C%E8%BD%B4%E7%94%B5%E7%BC%86.png" alt=""></p>
<h3 id="双绞线">双绞线</h3><ul>
<li>双绞线由两根具有绝缘保护层的铜导线组成</li>
<li>把两根绝缘的铜导线按一定密度互相绞在一起，因此得名</li>
<li>实际使用时，双绞线是由多对双绞线一起包在一个绝缘电缆套管里的。</li>
</ul>
<p><img src="http://7xv4w8.com1.z0.glb.clouddn.com/%E4%BC%A0%E8%BE%93%E5%AA%92%E4%BD%93-%E5%8F%8C%E7%BB%9E%E7%BA%BF.png" alt=""></p>
<p><em>双绞线电缆的主要特性是线 路规格、扭绞间距、绝缘类型、 阻抗特性和外套材料</em></p>
<p><img src="http://7xv4w8.com1.z0.glb.clouddn.com/%E4%BC%A0%E8%BE%93%E5%AA%92%E4%BD%93-%E5%8F%8C%E7%BB%9E%E7%BA%BF%E7%A7%8D%E7%B1%BB.png" alt=""></p>
<p><img src="http://7xv4w8.com1.z0.glb.clouddn.com/%E4%BC%A0%E8%BE%93%E5%AA%92%E4%BD%93-%E5%8F%8C%E7%BB%9E%E7%BA%BF%E6%A0%87%E8%AF%86.png" alt=""></p>
<p><strong>优点:</strong></p>
<ol>
<li>可以实现全双工通信</li>
<li>价格便宜</li>
<li>柔软性好，容易布线</li>
</ol>
<p><strong>缺点:</strong></p>
<ol>
<li>频率特性不及同轴电缆</li>
<li>抗干扰能力差</li>
</ol>
<h3 id="光纤">光纤</h3><ul>
<li>光纤是光导纤维的简写，是一种由玻璃或塑料制成的纤维</li>
<li>光纤通信是指利用光纤传播光脉冲进行的通信过程。有光 脉冲相当于数字信号1，没有光脉冲相当于数字信号0。</li>
</ul>
<p><img src="http://7xv4w8.com1.z0.glb.clouddn.com/%E4%BC%A0%E8%BE%93%E5%AA%92%E4%BD%93-%E5%85%89%E7%BA%A4.png" alt=""></p>
<p><img src="http://7xv4w8.com1.z0.glb.clouddn.com/%E4%BC%A0%E8%BE%93%E5%AA%92%E4%BD%93-%E5%85%89%E7%BA%A4%E7%A7%8D%E7%B1%BB.png" alt=""></p>
<p><strong>优点:</strong></p>
<ol>
<li>容易布线</li>
<li>传输速率高</li>
<li>传输距离远</li>
<li>抗干扰性好</li>
<li>价格比同轴电缆便宜</li>
</ol>
<p><strong>缺点:</strong></p>
<ol>
<li>光端口成本高，尤其是单模光纤光端口</li>
</ol>
<p><img src="http://7xv4w8.com1.z0.glb.clouddn.com/%E4%BC%A0%E8%BE%93%E5%AA%92%E4%BD%93-%E5%85%89%E7%BA%A4%E4%BD%BF%E7%94%A8.png" alt=""></p>
<h3 id="小结-2">小结</h3><ul>
<li>双绞线和光纤是互补性很强的两种传输媒体</li>
<li>双绞线和光纤成为主流的传输媒体</li>
<li>同轴电缆在网络通信中逐渐被淘汰</li>
</ul>
<h2 id="结束">结束</h2><p>好了，到这里科普知识结束了，下节开始以太网的学习。</p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2017/07/02/function-stack/" itemprop="url">
                函数的参数是如何传递的
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2017-07-02T22:28:11+08:00" content="2017-07-02">
            2017-07-02
          </time>
        </span>

        

        
          
        
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><p>函数的参数是如何传递的</p>
<p><img src="http://pic.qqtn.com/file/2013/2015-5/2015050609100347328.jpg" alt=""></p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2017/03/10/union-found/" itemprop="url">
                数据结构与算法---> 并查集
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2017-03-10T11:32:05+08:00" content="2017-03-10">
            2017-03-10
          </time>
        </span>

        

        
          
        
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"></span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2017/03/05/bubble-sort/" itemprop="url">
                排序算法之冒泡排序和选择排序
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2017-03-05T22:28:11+08:00" content="2017-03-05">
            2017-03-05
          </time>
        </span>

        

        
          
        
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><p>从这周开始，每周我将写一些工作中常用的算法如下：</p>
<ol>
<li>冒泡排序和选择排序；</li>
<li>插入排序和希尔排序；</li>
<li>归并排序及其优化；</li>
<li>快速排序及其优化；</li>
<li>堆排序；</li>
</ol>
<p>下面开始正文：</p>
<h2 id="冒泡排序">冒泡排序</h2><p>冒泡排序可能是我们学习某种编程语言（大多数都是 C）之后，接触到的第一个排序算法。我在网上找了很多的博客之类的介绍冒泡排序的，但总是总是有点纰漏，比如 分析的和写的例子不一致（😂😂😂），很尴尬。下面我们详细来分析一下冒泡排序的过程：</p>
<p>待排序数组为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="number">6</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">9</span> &#125;</span><br></pre></td></tr></table></figure>
<p><strong>冒泡排序的原理是：<code>临近的``数字两两进行比较</code>,按照<code>从小到大</code>或者<code>从大到小</code>的顺序进行交换。</strong></p>
<p><strong>这里注意：是临近的两个数字两两进行比较，如果非，那就不是冒泡排序。</strong></p>
<p>起始数组如下：</p>
<p><img src="http://7xv4w8.com1.z0.glb.clouddn.com/%E5%86%92%E6%B3%A1-%E8%B5%B7%E5%A7%8B%E6%95%B0%E7%BB%84.png" alt="起始数组"></p>
<ol>
<li>第一趟排序</li>
</ol>
<p>第一次比较： <code>6 &gt; 2</code>  6 大于 2 进行交换，交换后：</p>
<p><img src="http://7xv4w8.com1.z0.glb.clouddn.com/%E5%86%92%E6%B3%A1-%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%AF%94%E8%BE%83.png" alt="00"></p>
<p>第二次比较： <code>6 &gt; 4</code>  6 大于 4 进行交换，交换后：</p>
<p><img src="http://7xv4w8.com1.z0.glb.clouddn.com/%E5%86%92%E6%B3%A1-%E7%AC%AC%E4%BA%8C%E6%AC%A1%E6%AF%94%E8%BE%83.png" alt=""></p>
<p>第三次比较： <code>6 &gt; 1</code>  6 大于 1 进行交换，交换后：</p>
<p><img src="http://7xv4w8.com1.z0.glb.clouddn.com/%E5%86%92%E6%B3%A1-%E7%AC%AC%E4%B8%89%E6%AC%A1%E6%AF%94%E8%BE%83.png" alt=""></p>
<p>第四次比较： <code>6 &gt; 5</code> 6 大于 5 进行交换，交换后：</p>
<p><img src="http://7xv4w8.com1.z0.glb.clouddn.com/%E5%86%92%E6%B3%A1-%E7%AC%AC%E5%9B%9B%E6%AC%A1%E6%AF%94%E8%BE%83.png" alt=""></p>
<p>第五次比较： <code>6 &lt; 9</code> 6 小于 9 不进行交换：</p>
<p><img src="http://7xv4w8.com1.z0.glb.clouddn.com/%E5%86%92%E6%B3%A1-%E7%AC%AC%E4%BA%94%E6%AC%A1%E6%AF%94%E8%BE%83.png" alt=""></p>
<p><strong>后面的第二、三、四、五、六的过程和上面的一样，最终如下面：</strong></p>
<p><img src="http://7xv4w8.com1.z0.glb.clouddn.com/%E5%86%92%E6%B3%A1-%E6%9C%80%E7%BB%88%E6%8E%92%E5%BA%8F.png" alt=""></p>
<p><strong>注意：第二次比较的时候，最后一位就不参与了，因为最大的已经冒了出来，第三次比较，倒数第二位不参与了，以此类推。</strong></p>
<p>至此，程序就很容易写出来了：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n ; i ++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n-i; j ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &lt; arr[j-<span class="number">1</span>]) &#123;</span><br><span class="line">                swap(&amp;arr[j], &amp;arr[j-<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="冒泡排序的优化">冒泡排序的优化</h2><p>我们看一下 每次排序的结果：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">第一次：<span class="number">2</span> <span class="number">4</span> <span class="number">1</span> <span class="number">5</span> <span class="number">6</span> <span class="number">9</span> </span><br><span class="line">第二次：<span class="number">2</span> <span class="number">1</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">9</span> </span><br><span class="line">第三次：<span class="number">1</span> <span class="number">2</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">9</span> </span><br><span class="line">第四次：<span class="number">1</span> <span class="number">2</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">9</span> </span><br><span class="line">第五次：<span class="number">1</span> <span class="number">2</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">9</span> </span><br><span class="line">第六次：<span class="number">1</span> <span class="number">2</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">9</span></span><br></pre></td></tr></table></figure>
<p>从中我们发现第三次的时候，已经排好序了，第四、五、六次没必要执行了，这就是我们要对冒泡排序进行优化的地方。</p>
<p>我们可以设置一个flag ，当没有发生交换的时候，记录一下，这时候数组已经有序了。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubbleSort2</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n &amp;&amp; flag ; i ++) &#123;</span><br><span class="line">        flag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n - i; j ++) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (arr[j] &lt; arr[j-<span class="number">1</span>]) &#123;</span><br><span class="line">                flag = <span class="number">1</span>;</span><br><span class="line">                swap(&amp;arr[j], &amp;arr[j-<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然，还有其他的优化方案，大家不妨搜下。</p>
<h2 id="选择排序">选择排序</h2><p>理解的前面的冒泡排序，选择排序是很容易理解的。选择排序顾名思义，每次循环要找出一个最小的值，然后再交换。</p>
<p>测试用例还是之前的：</p>
<p><img src="http://7xv4w8.com1.z0.glb.clouddn.com/%E5%86%92%E6%B3%A1-%E8%B5%B7%E5%A7%8B%E6%95%B0%E7%BB%84.png" alt="起始数组"></p>
<p>第一次大循环找到最小的值 <code>1</code> 然后和 <code>第0位</code>的交换，交换后：</p>
<p><img src="http://7xv4w8.com1.z0.glb.clouddn.com/%E9%80%89%E6%8B%A9-%E7%AC%AC%E4%B8%80%E6%AC%A1.png" alt=""></p>
<p>第二次大循环找到最小的值 <code>2</code> 然后和 <code>第1位</code>的交换，交换后：</p>
<p><img src="http://7xv4w8.com1.z0.glb.clouddn.com/%E9%80%89%E6%8B%A9-%E7%AC%AC%E4%B8%80%E6%AC%A1.png" alt=""></p>
<p>当然第三次大循环和第二次一样</p>
<p>第四次大循环找到最小的值 <code>5</code> 然后和 <code>第3位</code>的交换，交换后：</p>
<p><img src="http://7xv4w8.com1.z0.glb.clouddn.com/%E5%86%92%E6%B3%A1-%E6%9C%80%E7%BB%88%E6%8E%92%E5%BA%8F.png" alt=""><br>后面的就已经排序好了。</p>
<p><strong>从上面可以看出，选择排序是一个不断寻找最小值的排序方法。</strong></p>
<p>所以代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">selectSort</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> minIndex = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &lt; arr[minIndex]) &#123;</span><br><span class="line">                minIndex = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(&amp;arr[i], &amp;arr[minIndex]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>是不是很简单 😁😁😁！</p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2017/03/05/insert-sort/" itemprop="url">
                排序算法之插入排序
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2017-03-05T22:28:11+08:00" content="2017-03-05">
            2017-03-05
          </time>
        </span>

        

        
          
        
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><h1 id="排序算法之插入排序">排序算法之插入排序</h1><p>从这周开始，每周我将写一些工作中常用的算法如下：</p>
<ol>
<li>冒泡排序和选择排序；</li>
<li>插入排序和希尔排序；</li>
<li>归并排序及其优化；</li>
<li>快速排序及其优化；</li>
<li>堆排序；</li>
</ol>
<p>下面开始正文：</p>
<h2 id="插入排序">插入排序</h2><p>关于插入排序的理论部分就不说了，去看<a href="https://zh.wikipedia.org/wiki/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F" target="_blank" rel="external">维基百科</a>，里面有各种语言的实现版本。咱们看图说话，容易理解。</p>
<p>待排数组如下：</p>
<p><img src="http://7xv4w8.com1.z0.glb.clouddn.com/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E5%88%9D%E5%A7%8B%E6%95%B0%E7%BB%84.png" alt="插入排序初始数组"></p>
<h3 id="第一步">第一步</h3><p>我们首先考虑 <code>8</code> 这个元素，只有 <code>8</code> 这一个元素，所以就排好序了。</p>
<p><img src="http://7xv4w8.com1.z0.glb.clouddn.com/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F01.png" alt="插入排序01"></p>
<h3 id="第二步">第二步</h3><p>我们来考虑 <code>6</code> 这个元素：</p>
<p><img src="http://7xv4w8.com1.z0.glb.clouddn.com/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F02.png" alt="插入排序02"></p>
<p>我们要把 <code>6</code> 放在其前面数组中合适的位置，和它前面的 <code>8</code> 相比 <code>6</code> 比 <code>8</code> 要小，所以 <code>6</code> 和 <code>8</code> 要互换位置：</p>
<p><img src="http://7xv4w8.com1.z0.glb.clouddn.com/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F03.png" alt="插入排序03"></p>
<p>此时前两个元素就排好的位置：</p>
<p><img src="http://7xv4w8.com1.z0.glb.clouddn.com/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F04.png" alt="插入排序04"></p>
<h3 id="第三步">第三步</h3><p>我们来考虑 <code>2</code> 这个元素：</p>
<p><img src="http://7xv4w8.com1.z0.glb.clouddn.com/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F05.png" alt="插入排序05"><br>我们把 <code>2</code> 和 <code>8</code> 比，<code>2</code> 比 <code>8</code> 小，所以互换位置：</p>
<p><img src="http://7xv4w8.com1.z0.glb.clouddn.com/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F06.png" alt="插入排序06"><br>然后，把 <code>2</code> 和 <code>6</code> 比，<code>2</code> 比 <code>6</code> 小，所以互换位置：</p>
<p><img src="http://7xv4w8.com1.z0.glb.clouddn.com/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F07.png" alt="插入排序07"></p>
<p>至此前三个元素就排好的位置：</p>
<p><img src="http://7xv4w8.com1.z0.glb.clouddn.com/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F08.png" alt="插入排序08"></p>
<h3 id="第四步">第四步</h3><p>我们来考虑 <code>3</code> 这个元素：</p>
<p><img src="http://7xv4w8.com1.z0.glb.clouddn.com/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F09.png" alt="插入排序09"><br>我们把 <code>3</code> 和 <code>8</code> 比，<code>3</code> 比 <code>8</code> 小，所以互换位置：</p>
<p><img src="http://7xv4w8.com1.z0.glb.clouddn.com/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F10.png" alt="插入排序10"></p>
<p>然后，把 <code>3</code> 和 <code>6</code> 比，<code>3</code> 比 <code>6</code> 小，所以互换位置：</p>
<p><img src="http://7xv4w8.com1.z0.glb.clouddn.com/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F11.png" alt="插入排序11"><br>然后，把 <code>3</code> 和 <code>2</code> 比，<code>3</code> 比 <code>2</code> 大，所以不互换位置。</p>
<p><img src="http://7xv4w8.com1.z0.glb.clouddn.com/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F11.png" alt="插入排序11"><br>至此前四个元素就排好的位置：</p>
<p><img src="http://7xv4w8.com1.z0.glb.clouddn.com/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F12.png" alt="插入排序12"><br>后面就不一一列举了，思路尽在 一二三四步骤中。</p>
<h2 id="写程序">写程序</h2><p>上面的思路理解了，下面的程序就比较好写了：</p>
<p><img src="http://7xv4w8.com1.z0.glb.clouddn.com/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F13.png" alt="插入排序13"><br>我们从数组的索引为 <code>1</code> 的位置开始，因为索引为 <code>0</code> 的位置已经排好序（假设数组长度为 <code>n</code>）即：</p>
<figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">1</span><span class="comment">; i &lt; n; i++) &#123;</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>大范围的确定好了，我们要进行小范围的比较排序了，那么 <code>1</code>位置的元素假设为第 <code>j</code> 位，要和之前的 位置 <code>j-1</code>位置的元素比较，如果大于不需要交换，否则需要交换：那么：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt; <span class="number">0</span>; j--) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr[j] &lt; arr[j - <span class="number">1</span>]) &#123;</span><br><span class="line">        swap(&amp;arr[j], &amp;arr[j-<span class="number">1</span>]);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>故完整的如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt; <span class="number">0</span>; j--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[j] &lt; arr[j - <span class="number">1</span>]) &#123;</span><br><span class="line">            swap(&amp;arr[j], &amp;arr[j-<span class="number">1</span>]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然，也可以这么写(嗯，更好看，装下逼也是可以的😜😜😜)：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt; <span class="number">0</span> &amp;&amp; (arr[j] &lt; arr[j - <span class="number">1</span>]); j--) &#123;</span><br><span class="line">            swap(&amp;arr[j], &amp;arr[j-<span class="number">1</span>]);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="测试">测试</h2><p>下面我们开始测试。测试用例呢 分为四种，分别为：</p>
<ol>
<li>有序</li>
<li>近乎有序</li>
<li>随机</li>
<li>倒叙</li>
</ol>
<p>我们测试10W个数据，测试它的排序时间，<a href="https://coding.net/u/xiaerfei/p/baseAlgorithm/git/blob/master/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/SortHelper.c" target="_blank" rel="external">测试用例的程序在这里</a>，测试代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n  = <span class="number">100000</span>;</span><br><span class="line"><span class="comment">// 有序</span></span><br><span class="line"><span class="keyword">int</span> *a = generateSequenceArray(n);</span><br><span class="line"><span class="comment">// 近乎有序</span></span><br><span class="line"><span class="keyword">int</span> *b = generateRandomSequenceArray(n, <span class="number">100</span>);</span><br><span class="line"><span class="comment">// 随机</span></span><br><span class="line"><span class="keyword">int</span> *c = generateRandomArray(n,<span class="number">0</span>,n);</span><br><span class="line"><span class="comment">// 倒叙</span></span><br><span class="line"><span class="keyword">int</span> *d = generateReverseArray(n);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *a1 = copyGenerateRandomArray(a, n);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *b1 = copyGenerateRandomArray(b, n);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *c1 = copyGenerateRandomArray(c, n);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *d1 = copyGenerateRandomArray(d, n);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"**************有序*************\n"</span>);</span><br><span class="line">testSort(<span class="string">"插入排序　　"</span>, insertSort,a1, n);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n**************近乎有序*************\n"</span>);</span><br><span class="line">testSort(<span class="string">"插入排序　　"</span>, insertSort,b1, n);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n**************随机*************\n"</span>);</span><br><span class="line">testSort(<span class="string">"插入排序　　"</span>, insertSort,c1, n);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n**************倒叙*************\n"</span>);</span><br><span class="line">testSort(<span class="string">"插入排序　　"</span>, insertSort,d1, n);</span><br><span class="line"></span><br><span class="line"><span class="built_in">free</span>(a);<span class="built_in">free</span>(a1);</span><br><span class="line"></span><br><span class="line"><span class="built_in">free</span>(b);<span class="built_in">free</span>(b1);</span><br><span class="line"></span><br><span class="line"><span class="built_in">free</span>(c);<span class="built_in">free</span>(c1);</span><br><span class="line"></span><br><span class="line"><span class="built_in">free</span>(d);<span class="built_in">free</span>(d1);</span><br></pre></td></tr></table></figure>
<p>运行之后的log（这里是在MacBook Pro上测试的结果，其它可能不是这个时间，但大底相同）：</p>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span>有序<span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line">sortname:插入排序　　	 sorttime: 0.000647s</span><br><span class="line"></span><br><span class="line"><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span>近乎有序<span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line">sortname:插入排序　　	 sorttime: 0.051551s</span><br><span class="line"></span><br><span class="line"><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span>随机<span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line">sortname:插入排序　　	 sorttime: 18.110468s</span><br><span class="line"></span><br><span class="line"><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span>倒叙<span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line">sortname:插入排序　　	 sorttime: 36.259288s</span><br></pre></td></tr></table></figure>
<p><strong>由此可以看出：插入排序对于近乎有序的数组用时很少，当数组随机或者是最坏情况，那就比较耗时。</strong></p>
<p>那，我们能不能改进呢？ 答案是可以的</p>
<h2 id="插入排序的优化">插入排序的优化</h2><p>在上面的看图说话中，某个元素要想找到自己的位置，则必须和之前的比较，完了之后可能要交换位置，如果说该元素是最小的，且是最后一个，那要交换 <code>n-1</code> 个了。我们知道 交换元素 是比较耗时的操作，那能不能不交换元素，也能找到它的合适的位置呢？方法还是的有的！采用赋值的方法</p>
<p>我们看第四步：</p>
<p><img src="http://7xv4w8.com1.z0.glb.clouddn.com/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F09.png" alt="插入排序09"><br>进行比较之后 <code>3 比 8 小</code>，我们在这里不进行交换，而是将 <code>3</code> 这个值记录下来为 <code>e = 3</code>,然后将 <code>8 元素值</code> 赋值到 <code>3</code> 的位置</p>
<p><img src="http://7xv4w8.com1.z0.glb.clouddn.com/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F14.png" alt="插入排序14"><br>然后将 <code>e = 3</code> 和 <code>元素 6</code> 比较，<code>3 比 6 小</code>，将 <code>元素 6</code> 赋值给其后一位：</p>
<p><img src="http://7xv4w8.com1.z0.glb.clouddn.com/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F15.png" alt="插入排序15"><br>然后将 <code>e = 3</code> 和 <code>元素 2</code> 比较，<code>3 比 2 大</code>，所以 <code>元素 3</code> 就找到了自己的位置：</p>
<p><img src="http://7xv4w8.com1.z0.glb.clouddn.com/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F16.png" alt="插入排序16"><br>看完图之后，这个思路是不是很清晰，下面的程序也是非常好写的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">int</span> e = arr[i];<span class="comment">//将该元素记录下来</span></span><br><span class="line">   <span class="keyword">int</span> j;</span><br><span class="line">   <span class="keyword">for</span> (j = i; j &gt; <span class="number">0</span> &amp;&amp; arr[j - <span class="number">1</span>] &gt; e; j--) &#123;</span><br><span class="line">       arr[j] = arr[j - <span class="number">1</span>];</span><br><span class="line">   &#125;</span><br><span class="line">   arr[j] = e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="插入排序优化测试">插入排序优化测试</h3><p>我们利用前面的测试方法，测试一下：</p>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span>有序<span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line">sortname:插入排序　　	 sorttime: 0.000647s</span><br><span class="line">sortname:插入排序优化	 sorttime: 0.000554s</span><br><span class="line"></span><br><span class="line"><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span>近乎有序<span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line">sortname:插入排序　　	 sorttime: 0.051551s</span><br><span class="line">sortname:插入排序优化	 sorttime: 0.025874s</span><br><span class="line"></span><br><span class="line"><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span>随机<span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line">sortname:插入排序　　	 sorttime: 18.110468s</span><br><span class="line">sortname:插入排序优化	 sorttime: 8.335453s</span><br><span class="line"></span><br><span class="line"><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span>倒叙<span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line">sortname:插入排序　　	 sorttime: 36.259288s</span><br><span class="line">sortname:插入排序优化	 sorttime: 16.780035s</span><br></pre></td></tr></table></figure>
<p>看看测试时间，这个优化还是有明显的提高的！！！</p>
<p>不知道这一节你掌握了么？😜😜😜</p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2017/02/14/Multi-thread/" itemprop="url">
                iOS多线程
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2017-02-14T15:00:40+08:00" content="2017-02-14">
            2017-02-14
          </time>
        </span>

        

        
          
        
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><h2 id="iOS多线程">iOS多线程</h2><h3 id="前言">前言</h3><p>在这篇文章中我整理了iOS多线程开发需要的一些知识点、方法和事项。本文主要讲述三部分 NSThread、Operation 和 GCD。<br><br>本文不算是原创，是一些我觉得写的比较有质量文章的综合，文中摘抄了这些文章中的部分内容，在文中和文章末尾我已标注出处，之所以要摘抄是因为在需要之时，打开URL 是404 😂😂😂。我综合了这些文中给自己学习之用，也给大家方便查看之用，如有错误之处，见谅，不过欢迎指出。</p>
<h3 id="基本概念">基本概念</h3><p>我们先了解一线iOS多线程的一些基本概念(<a href="http://blog.leichunfeng.com/blog/2015/07/29/ios-concurrency-programming-operation-queues/#jtss-tsina" target="_blank" rel="external">这些基本概念参考了这里</a>)：</p>
<ul>
<li>进程（process）:指的是一个正在运行中的可执行文件。每一个进程都拥有独立的虚拟内存空间和系统资源，包括端口权限等，且至少包含一个主线程和任意数量的辅助线程（说白了就是：用于指代一个可执行程序，他可以包含多个线程）。另外，当一个进程的主线程退出时，这个进程就结束了；</li>
<li>线程（thread）:指的是一个独立的代码执行路径，也就是说线程是代码执行路径的最小分支。在 iOS 中，线程的底层实现是基于 <a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/Multithreading/Introduction/Introduction.html" target="_blank" rel="external">POSIX threads API</a> 的，也就是我们常说的 pthreads ；</li>
<li>任务（task），指的是我们需要执行的工作，是一个抽象的概念，用通俗的话说，就是一段代码。</li>
</ul>
<p><br></p>
<h4 id="串行_和_并发">串行 和 并发</h4><p>从本质上来说，串行和并发的主要区别在于允许同时执行的任务数量。</p>
<ul>
<li>串行：指的是一次只能执行一个任务，必须等一个任务执行完成后才能执行下一个任务；</li>
<li>并发：指的是允许多个任务在一段时间内同时执行。</li>
</ul>
<p><br></p>
<h4 id="同步_和_异步">同步 和 异步</h4><p>同步和异步操作的主要区别在于是否等待操作执行完成，亦即是否阻塞当前线程。</p>
<ul>
<li>同步操作：等待操作执行完成后再继续执行接下来的代码；</li>
<li>异步操作：它会在调用后立即返回，不会等待操作的执行结果。</li>
</ul>
<p><br></p>
<h4 id="队列_和_线程">队列 和 线程</h4><p>在 iOS 中，有两种不同类型的队列，分别是串行队列和并发队列。正如我们上面所说的，串行队列一次只能执行一个任务，而并发队列则可以允许多个任务同时执行。iOS 系统就是使用这些队列来进行任务调度的，它会根据调度任务的需要和系统当前的负载情况动态地创建和销毁线程，而不需要我们手动地管理</p>
<p><br></p>
<h4 id="iOS中的几种多线程类型">iOS中的几种多线程类型</h4><p>iOS 中其实目前有 4 种多线程，他们分别是：</p>
<ul>
<li>Pthreads：非常底层的东东；</li>
<li>NSThread：封装性最差，最偏向于底层，主要基于thread使用；</li>
<li>GCD：基于C的API，直接使用比较方便，主要基于task使用；</li>
<li>NSOperation &amp; NSOperationQueue：基于GCD封装的NSObject对象，对于复杂的多线程项目使用比较方便，主要基于队列使用。</li>
</ul>
<hr>
<p>下面开始介绍这几种类型<br><br></p>
<h3 id="Pthreads">Pthreads</h3><p>POSIX线程（POSIX threads），简称Pthreads，是线程的POSIX标准。该标准定义了创建和操纵线程的一整套API。在类Unix操作系统（Unix、Linux、Mac OS X等）中，都使用Pthreads作为操作系统的线程。<br><br>这个需要自己管理线程的生命周期，创建和销毁，写起来也是相当麻烦，若非是写一些非常底层的几乎是用不到的，这里暂时略过，如需要可自行去理解。<br><br></p>
<h3 id="NSThread">NSThread</h3><p>NSThread是苹果封装的，并且是面向对象的，这对我们来说就简便了许多，但是它的生命周期还是需要我们手动管理的；NSThread除Pthreads之外唯一一个基于线程封装的，每一个NSThread对象代表着一个线程。(<a href="http://www.jianshu.com/p/8ed06312d8bd" target="_blank" rel="external">这部分参考了这里</a>)<br><br></p>
<h4 id="线程的创建">线程的创建</h4><p>NSThread提供了2种创建线程的方法:</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="typename">void</span>)<span class="string">detachNewThreadSelector:</span>(SEL)selector <span class="string">toTarget:</span>(id)target <span class="string">withObject:</span>(nullable id)argument;</span><br><span class="line">- (instancetype)<span class="string">initWithTarget:</span>(id)target <span class="string">selector:</span>(SEL)selector <span class="string">object:</span>(nullable id)argument</span><br></pre></td></tr></table></figure>
<ul>
<li>detach方法直接创建并启动一个线程去Selector，由于没有返回值，如果需要获取新创建的Thread，需要在执行的Selector中调用-[NSThread currentThread]获取;</li>
<li>init方法初始化线程并返回，线程的入口函数由Selector传入。线程创建出来之后需要手动调用-start方法启动;<br><br><h4 id="线程操作">线程操作</h4>NSThread给线程提供的主要操作方法有启动，睡眠，取消，退出<br><br><h4 id="启动">启动</h4>使用init方法将线程创建出来之后，线程并不会立即运行，需要手动调用-start方法才会启动线程：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)<span class="function">start <span class="title">NS_AVAILABLE</span><span class="params">(<span class="number">10</span>_5, <span class="number">2</span>_0)</span></span>;</span><br></pre></td></tr></table></figure>
<p>在启动之前可以设置 线程的名称(当然启动后也可以在Selecter 中设置也可以)：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (nullable, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *name <span class="built_in">NS_AVAILABLE</span>(<span class="number">10</span>_5, <span class="number">2</span>_0);</span><br></pre></td></tr></table></figure>
<p>不过优先级 需要在 start 之前 设置，否则会无效：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@<span class="function">property NSQualityOfService qualityOfService <span class="title">NS_AVAILABLE</span><span class="params">(<span class="number">10</span>_10, <span class="number">8</span>_0)</span></span>;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h4 id="睡眠">睡眠</h4><p>NSThread提供了2个让线程睡眠的方法:</p>
<ul>
<li>根据NSDate传入睡眠时间；</li>
<li>直接传入NSTimeInterval</li>
</ul>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="tag">void</span>)<span class="rule"><span class="attribute">sleepUntilDate</span>:<span class="value">(NSDate *)date</span></span>;</span><br><span class="line">+ (<span class="tag">void</span>)<span class="rule"><span class="attribute">sleepForTimeInterval</span>:<span class="value">(NSTimeInterval)ti</span></span>;</span><br></pre></td></tr></table></figure>
<p>这里讲一下  sleepUntilDate:  和   runloop的runUntilDate: 上的一些区别：</p>
<ul>
<li>sleepUntilDate:相当于执行一个sleep的任务。在执行过程中，即使有其他任务传入runloop，runloop也不会立即响应，必须sleep任务完成之后，才会响应其他任务；</li>
<li>runUntilDate:虽然会阻塞线程，阻塞过程中并不妨碍新任务的执行。当有新任务的时候，会先执行接收到的新任务，新任务执行完之后，如果时间到了，再继续执行runUntilDate:之后的代码；</li>
</ul>
<p><br></p>
<h4 id="取消">取消</h4><p>NSThread提供了一个取消的方法和一个属性：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@property (readonly, getter=isCancelled) <span class="function">BOOL cancelled <span class="title">NS_AVAILABLE</span><span class="params">(<span class="number">10</span>_5, <span class="number">2</span>_0)</span></span>;</span><br><span class="line">- (<span class="keyword">void</span>)<span class="function">cancel <span class="title">NS_AVAILABLE</span><span class="params">(<span class="number">10</span>_5, <span class="number">2</span>_0)</span></span>;</span><br></pre></td></tr></table></figure>
<p>这里 cancel 方法要注意：调用-cancel方法并不会立刻取消线程，它仅仅是将cancelled属性设置为YES。cancelled也仅仅是一个用于记录状态的属性。线程取消的功能需要我们在main函数中自己实现；<br><br>要实现取消的功能，我们需要自己在线程的main函数中定期检查isCancelled状态来判断线程是否需要退出，当isCancelled为YES的时候，需要手动退出。<br></p>
<h4 id="退出">退出</h4><p>-exit函数可以让线程立即退出。<br><br>停止方法会立即终止除主线程以外所有线程（无论是否在执行任务）并退出，需要在掌控所有线程状态的情况下调用此方法，否则可能会导致内存问题。<br></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">void</span>)<span class="built_in">exit</span>;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h4 id="主线程和当前线程">主线程和当前线程</h4><p>NSThread提供了非常方便的获取和判断主线程的API：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@property (readonly) <span class="function">BOOL isMainThread <span class="title">NS_AVAILABLE</span><span class="params">(<span class="number">10</span>_5, <span class="number">2</span>_0)</span></span>;</span><br><span class="line">+ (BOOL)<span class="function">isMainThread <span class="title">NS_AVAILABLE</span><span class="params">(<span class="number">10</span>_5, <span class="number">2</span>_0)</span></span>; <span class="comment">// reports whether current thread is main</span></span><br><span class="line">+ (NSThread *)<span class="function">mainThread <span class="title">NS_AVAILABLE</span><span class="params">(<span class="number">10</span>_5, <span class="number">2</span>_0)</span></span>;</span><br></pre></td></tr></table></figure>
<p>获取当前线程：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">+ </span>(NSThread *)currentThread;</span><br></pre></td></tr></table></figure>
<p>是否为多线程：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ <span class="list">(<span class="keyword">BOOL</span>)</span>isMultiThreaded<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>关于isMultiThreaded 苹果在这里作了解释(相信你能看懂 😜😜😜)：</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Return</span> <span class="type">Value</span></span><br><span class="line"><span class="type">YES</span> <span class="keyword">if</span> the application <span class="keyword">is</span> multithreaded, <span class="type">NO</span> otherwise.</span><br><span class="line"></span><br><span class="line"><span class="type">Discussion</span></span><br><span class="line"><span class="type">An</span> application <span class="keyword">is</span> considered multithreaded <span class="keyword">if</span> a thread was ever detached <span class="keyword">from</span> the main thread <span class="keyword">using</span> either detachNewThreadSelector:toTarget:withObject: <span class="keyword">or</span> start. <span class="type">If</span> you detached a thread <span class="keyword">in</span> your application <span class="keyword">using</span> a non-<span class="type">Cocoa</span> <span class="type">API</span>, such <span class="keyword">as</span> the <span class="type">POSIX</span> <span class="keyword">or</span> <span class="type">Multiprocessing</span> <span class="type">Services</span> <span class="type">APIs</span>, this <span class="keyword">method</span> could still <span class="keyword">return</span> <span class="type">NO</span>. <span class="type">The</span> detached thread does <span class="keyword">not</span> have to be currently running <span class="keyword">for</span> the application to be considered multithreaded—this <span class="keyword">method</span> only indicates whether a single thread has been spawned.</span><br></pre></td></tr></table></figure>
<p><br></p>
<h4 id="线程优先级">线程优先级</h4><p>NSThread有4个优先级的API：</p>
<p>这两个用于设置和获取当前线程的优先级：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="tag">double</span>)<span class="tag">threadPriority</span>;</span><br><span class="line">+ (<span class="tag">BOOL</span>)<span class="rule"><span class="attribute">setThreadPriority</span>:<span class="value">(double)p</span></span>;</span><br></pre></td></tr></table></figure>
<p>后两个通过对象设置和获取优先级：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@<span class="function">property <span class="keyword">double</span> threadPriority <span class="title">NS_AVAILABLE</span><span class="params">(<span class="number">10</span>_6, <span class="number">4</span>_0)</span></span>; <span class="comment">// To be deprecated; use qualityOfService below</span></span><br><span class="line">@<span class="function">property NSQualityOfService qualityOfService <span class="title">NS_AVAILABLE</span><span class="params">(<span class="number">10</span>_10, <span class="number">8</span>_0)</span></span>; <span class="comment">// read-only after the thread is started</span></span><br></pre></td></tr></table></figure>
<p>在iOS 8 之前：</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">[NSThread setThreadPriority:1.0]</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>这个方法的优先级的数值设置让人困惑，因为你不知道你应该设置多大的值是比较合适的，因此在iOS8之后，threadPriority添加了一句注释：To be deprecated; use qualityOfService below <br><br>意为iOS 8以后推荐使用qualityOfService属性：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSInteger</span>, <span class="built_in">NSQualityOfService</span>) &#123;</span><br><span class="line">    <span class="built_in">NSQualityOfServiceUserInteractive</span> = <span class="number">0x21</span>, 最高优先级，用于用户交互事件</span><br><span class="line">    <span class="built_in">NSQualityOfServiceUserInitiated</span> = <span class="number">0x19</span>,   次高优先级，用于用户需要马上执行的事件</span><br><span class="line">    <span class="built_in">NSQualityOfServiceUtility</span> = <span class="number">0x11</span>,         普通优先级，用于普通任务       </span><br><span class="line">    <span class="built_in">NSQualityOfServiceBackground</span> = <span class="number">0x09</span>,      最低优先级，用于不重要的任务</span><br><span class="line">    <span class="built_in">NSQualityOfServiceDefault</span> = -<span class="number">1</span>            默认优先级，主线程和没有设置优先级的线程都默认为这个优先级</span><br><span class="line">&#125; <span class="built_in">NS_ENUM_AVAILABLE</span>(<span class="number">10</span>_10, <span class="number">8</span>_0);</span><br></pre></td></tr></table></figure>
<p>比如给线程设置次高优先级：</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">[newThread setQualityOfService:NSQualityOfServiceUserInitiated]</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p><br></p>
<h4 id="线程通讯">线程通讯</h4><p>创建线程之后，经常需要从主线程把耗时的任务丢给辅助线程，当任务完成之后辅助线程再把结果传回主线程传，这些线程通讯一般用的都是perform方法：</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)performSelectorOnMainThread:(<span class="type">SEL</span>)aSelector withObject:(nullable id)arg waitUntilDone:(<span class="type">BOOL</span>)wait modes:(nullable <span class="type">NSArray</span>&lt;<span class="type">NSString</span> *&gt; *)<span class="type">array</span>;</span><br><span class="line">- (<span class="type">void</span>)performSelectorOnMainThread:(<span class="type">SEL</span>)aSelector withObject:(nullable id)arg waitUntilDone:(<span class="type">BOOL</span>)wait;</span><br><span class="line">	// equivalent to the first <span class="keyword">method</span> <span class="keyword">with</span> kCFRunLoopCommonModes</span><br><span class="line">- (<span class="type">void</span>)performSelector:(<span class="type">SEL</span>)aSelector onThread:(<span class="type">NSThread</span> *)thr withObject:(nullable id)arg waitUntilDone:(<span class="type">BOOL</span>)wait modes:(nullable <span class="type">NSArray</span>&lt;<span class="type">NSString</span> *&gt; *)<span class="type">array</span> <span class="type">NS_AVAILABLE</span>(<span class="number">10_5</span>, <span class="number">2_0</span>);</span><br><span class="line">- (<span class="type">void</span>)performSelector:(<span class="type">SEL</span>)aSelector onThread:(<span class="type">NSThread</span> *)thr withObject:(nullable id)arg waitUntilDone:(<span class="type">BOOL</span>)wait <span class="type">NS_AVAILABLE</span>(<span class="number">10_5</span>, <span class="number">2_0</span>);</span><br><span class="line">	// equivalent to the first <span class="keyword">method</span> <span class="keyword">with</span> kCFRunLoopCommonModes</span><br></pre></td></tr></table></figure>
<p>①：将selector丢给主线程执行，可以指定runloop mode<br><br>②：将selector丢给主线程执行，runloop mode默认为common mode<br><br>③：将selector丢个指定线程执行，可以指定runloop mode<br><br>④：将selector丢个指定线程执行，runloop mode默认为default mode<br><br>一般用③④方法将任务丢给辅助线程，任务执行完成之后再使用①②方法将结果传回主线程<br><br>注意：perform方法只对拥有runloop的线程有效，如果创建的线程没有添加runloop，perform的selector将无法执行。<br><br><br></p>
<h4 id="线程通知">线程通知</h4><p>NSThread有三个线程相关的通知:</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FOUNDATION_EXPORT <span class="built_in">NSString</span> * <span class="keyword">const</span> <span class="built_in">NSWillBecomeMultiThreadedNotification</span>;</span><br><span class="line">FOUNDATION_EXPORT <span class="built_in">NSString</span> * <span class="keyword">const</span> <span class="built_in">NSDidBecomeSingleThreadedNotification</span>;</span><br><span class="line">FOUNDATION_EXPORT <span class="built_in">NSString</span> * <span class="keyword">const</span> <span class="built_in">NSThreadWillExitNotification</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>NSWillBecomeMultiThreadedNotification：由当前线程派生出第一个其他线程时发送；</li>
<li>NSDidBecomeSingleThreadedNotification：暂时不知道；</li>
<li>NSThreadWillExitNotification：线程退出时发送；</li>
</ul>
<p><br></p>
<h4 id="NSThread的简单使用">NSThread的简单使用</h4><p>NSThread 创建还是很简单的：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSThread</span> *thread = [[<span class="built_in">NSThread</span> alloc] initWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(threadAction) object:<span class="literal">nil</span>];</span><br><span class="line">thread<span class="variable">.name</span> = <span class="string">@"com.myCreate.www"</span>;</span><br><span class="line">[thread start];</span><br></pre></td></tr></table></figure>
<p>在线程启动之后会首先执行-threadAction，正常情况下threadAction方法执行结束之后，线程就会退出。为了线程可以长期复用接收消息，我们需要给线程加上runLoop</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)threadAction</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"当前线程：%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    <span class="built_in">NSRunLoop</span> *runLoop = [<span class="built_in">NSRunLoop</span> currentRunLoop];</span><br><span class="line">    [runLoop addPort:[<span class="built_in">NSMachPort</span> port] forMode:<span class="built_in">NSDefaultRunLoopMode</span>];</span><br><span class="line">    <span class="keyword">while</span> (![[<span class="built_in">NSThread</span> currentThread] isCancelled]) &#123;</span><br><span class="line">        [runLoop runMode:<span class="built_in">NSDefaultRunLoopMode</span> beforeDate:[<span class="built_in">NSDate</span> dateWithTimeIntervalSinceNow:<span class="number">10</span>]];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>自定义的线程默认是没有runloop的，调用-currentRunLoop，方法内部会为线程创建runloop；</li>
<li>如果没有数据源，runloop会在启动之后会立刻退出。所以需要给runloop添加一个数据源，这里添加的是NSPort数据源；</li>
<li>定期检查isCancelled，当外部调用-cancel方法将isCancelled置为YES的时候，线程可以退出；</li>
</ul>
<p><br></p>
<h4 id="结束线程">结束线程</h4><p>当我们想要结束线程的时候，我们可以使用CFRunLoopStop()配合-cancel来结束线程：</p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">[<span class="list">[<span class="keyword">NSThread</span> currentThread] cancel]<span class="comment">;</span></span><br><span class="line">CFRunLoopStop<span class="list">(<span class="keyword">CFRunLoopGetCurrent</span><span class="list">()</span>)</span><span class="comment">;</span></span></span></span><br></pre></td></tr></table></figure>
<p><br></p>
<h4 id="NSThread的一个小例子">NSThread的一个小例子</h4><p>这个例子很好的说明了NSThread使用时要注意些什么。<br><br>这个例子是：模拟售票<a href="http://www.jianshu.com/p/334bde6790be#" target="_blank" rel="external">这个例子来自这</a><br><br>情景：某演唱会门票发售，在广州和北京均开设窗口进行销售<br><br>下面是主要代码：新建两个线程<br></p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"***************售票开始****************"</span>);</span><br><span class="line"><span class="built_in">NSThread</span> *saleTicketsWindow_1 = [[<span class="built_in">NSThread</span> alloc] initWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(saleTicketsWindow_Action) object:<span class="literal">nil</span>];</span><br><span class="line">saleTicketsWindow_1<span class="variable">.name</span> = <span class="string">@"北京售票中心"</span>;</span><br><span class="line">[saleTicketsWindow_1 start];</span><br><span class="line">   </span><br><span class="line"><span class="built_in">NSThread</span> *saleTicketsWindow_2 = [[<span class="built_in">NSThread</span> alloc] initWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(saleTicketsWindow_Action) object:<span class="literal">nil</span>];</span><br><span class="line">saleTicketsWindow_2<span class="variable">.name</span> = <span class="string">@"广州售票中心"</span>;</span><br><span class="line">[saleTicketsWindow_2 start];</span><br></pre></td></tr></table></figure>
<p>开始执行售票<br></p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)saleTicketsWindow_Action</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (_ticketCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            _ticketCount --;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"剩余票数：%ld 窗口：%@"</span>, _ticketCount, [<span class="built_in">NSThread</span> currentThread]<span class="variable">.name</span>]);</span><br><span class="line">            [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">0.2</span>];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"***************售票完成****************"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">10</span> <span class="number">17</span>:<span class="number">54</span>:<span class="number">22.636</span> NSThreadTest[<span class="number">2323</span>:<span class="number">1382484</span>] 剩余票数：<span class="number">9</span> 窗口：广州售票中心</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">10</span> <span class="number">17</span>:<span class="number">54</span>:<span class="number">22.636</span> NSThreadTest[<span class="number">2323</span>:<span class="number">1382483</span>] 剩余票数：<span class="number">10</span> 窗口：北京售票中心</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">10</span> <span class="number">17</span>:<span class="number">54</span>:<span class="number">22.841</span> NSThreadTest[<span class="number">2323</span>:<span class="number">1382483</span>] 剩余票数：<span class="number">7</span> 窗口：北京售票中心</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">10</span> <span class="number">17</span>:<span class="number">54</span>:<span class="number">22.841</span> NSThreadTest[<span class="number">2323</span>:<span class="number">1382484</span>] 剩余票数：<span class="number">8</span> 窗口：广州售票中心</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">10</span> <span class="number">17</span>:<span class="number">54</span>:<span class="number">23.043</span> NSThreadTest[<span class="number">2323</span>:<span class="number">1382484</span>] 剩余票数：<span class="number">5</span> 窗口：广州售票中心</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">10</span> <span class="number">17</span>:<span class="number">54</span>:<span class="number">23.043</span> NSThreadTest[<span class="number">2323</span>:<span class="number">1382483</span>] 剩余票数：<span class="number">6</span> 窗口：北京售票中心</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">10</span> <span class="number">17</span>:<span class="number">54</span>:<span class="number">23.244</span> NSThreadTest[<span class="number">2323</span>:<span class="number">1382484</span>] 剩余票数：<span class="number">4</span> 窗口：广州售票中心</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">10</span> <span class="number">17</span>:<span class="number">54</span>:<span class="number">23.244</span> NSThreadTest[<span class="number">2323</span>:<span class="number">1382483</span>] 剩余票数：<span class="number">3</span> 窗口：北京售票中心</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">10</span> <span class="number">17</span>:<span class="number">54</span>:<span class="number">23.449</span> NSThreadTest[<span class="number">2323</span>:<span class="number">1382483</span>] 剩余票数：<span class="number">1</span> 窗口：北京售票中心</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">10</span> <span class="number">17</span>:<span class="number">54</span>:<span class="number">23.449</span> NSThreadTest[<span class="number">2323</span>:<span class="number">1382484</span>] 剩余票数：<span class="number">2</span> 窗口：广州售票中心</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">10</span> <span class="number">17</span>:<span class="number">54</span>:<span class="number">23.655</span> NSThreadTest[<span class="number">2323</span>:<span class="number">1382483</span>] 剩余票数：<span class="number">0</span> 窗口：北京售票中心</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">10</span> <span class="number">17</span>:<span class="number">54</span>:<span class="number">23.655</span> NSThreadTest[<span class="number">2323</span>:<span class="number">1382484</span>] ***************售票完成****************</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">10</span> <span class="number">17</span>:<span class="number">54</span>:<span class="number">23.656</span> NSThreadTest[<span class="number">2323</span>:<span class="number">1382484</span>] 线程退出了：广州售票中心</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">10</span> <span class="number">17</span>:<span class="number">54</span>:<span class="number">23.861</span> NSThreadTest[<span class="number">2323</span>:<span class="number">1382483</span>] ***************售票完成****************</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">10</span> <span class="number">17</span>:<span class="number">54</span>:<span class="number">23.861</span> NSThreadTest[<span class="number">2323</span>:<span class="number">1382483</span>] 线程退出了：北京售票中心</span><br></pre></td></tr></table></figure>
<p>可以看到，票的销售过程中出现了剩余数量错乱的情况，这就是线程同步问题。<br><br>售票是一个典型的需要线程同步的场景，由于售票渠道有很多，而票的资源是有限的，当多个渠道在短时间内卖出大量的票的时候，如果没有同步机制来管理票的数量，将会导致票的总数和售出票数对应不上的错误。<br></p>
<p>iOS实现线程加锁有几种方式，现在使用NSLock或@synchronized两种方式都可行<br></p>
<p>使用NSLock:<br></p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    [_lock lock];</span><br><span class="line">    <span class="keyword">if</span> (_ticketCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        _ticketCount --;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"剩余票数：%ld 窗口：%@"</span>, _ticketCount, [<span class="built_in">NSThread</span> currentThread]<span class="variable">.name</span>]);</span><br><span class="line">        [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">0.2</span>];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"***************售票完成****************"</span>);</span><br><span class="line">        [_lock unlock];</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    [_lock unlock];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用@synchronized:<br></p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">@synchronized</span>(<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (_ticketCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            _ticketCount --;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"剩余票数：%ld 窗口：%@"</span>, _ticketCount, [<span class="built_in">NSThread</span> currentThread]<span class="variable">.name</span>]);</span><br><span class="line">            [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">0.2</span>];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"***************售票完成****************"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="NSOperation">NSOperation</h3><p>NSOperation 只是一个抽象类，所以不能封装任务，因此，如果我们想要使用它来执行具体任务的话，就必须创建自己的子类或使用它的 2 个子类。分别是：NSInvocationOperation 和 NSBlockOperation 。创建一个 Operation 后，需要调用 start 方法来启动任务，它会 默认在当前队列同步执行。当然你也可以在中途取消一个任务，只需要调用其 cancel 方法即可。</p>
<h4 id="NSInvocationOperation">NSInvocationOperation</h4><p>下面是NSInvocationOperation的简单使用，可以看到 NSInvocationOperation 开始任务之后是在主线程执行任务的。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.创建对象</span></span><br><span class="line"><span class="built_in">NSInvocationOperation</span> *operation = [[<span class="built_in">NSInvocationOperation</span> alloc] initWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(invocationAction) object:<span class="literal">nil</span>];</span><br><span class="line"><span class="comment">//2.开始执行</span></span><br><span class="line">[operation start];</span><br><span class="line"><span class="comment">//3.结果</span></span><br><span class="line"><span class="comment">/*</span><br><span class="line"> 2016-05-06 05:53:43.219 NSOperationTest[5885:2491863] NSInvocationOperation --- &lt;NSThread: 0x7fa269c06dc0&gt;&#123;number = 1, name = main&#125;</span><br><span class="line"> 是在主线程</span><br><span class="line"> */</span></span><br></pre></td></tr></table></figure>
<h4 id="NSBlockOperation">NSBlockOperation</h4><p>NSBlockOperation 默认会在当前线程执行任务。但是 NSBlockOperation 还有一个方法：addExecutionBlock: ，通过这个方法可以给 Operation 添加多个执行 Block。这样 Operation 中的任务 会并发执行，它会 在主线程和其它的多个线程执行这些任务.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">NSBlockOperation *blockOperation = [NSBlockOperation blockOperationWithBlock:^&#123;</span><br><span class="line">    NSLog(@<span class="string">"NSBlockOperation --- %@"</span>, [NSThread currentThread]);</span><br><span class="line">&#125;];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    [blockOperation addExecutionBlock:^&#123;</span><br><span class="line">        NSLog(@<span class="string">"NSBlockOperation 第%d次：%@"</span>, i, [NSThread currentThread]);</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br><span class="line">[blockOperation start];</span><br><span class="line"></span><br><span class="line"> <span class="number">2016</span>-<span class="number">05</span>-<span class="number">06</span> <span class="number">05</span>:<span class="number">57</span>:<span class="number">46.227</span> NSBlockOperationTest[<span class="number">5921</span>:<span class="number">2510961</span>] NSBlockOperation --- &lt;NSThread: <span class="number">0x7fc4c0401af0</span>&gt;&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line"> </span><br><span class="line"> <span class="number">2016</span>-<span class="number">05</span>-<span class="number">06</span> <span class="number">06</span>:<span class="number">01</span>:<span class="number">25.939</span> NSBlockOperationTest[<span class="number">5939</span>:<span class="number">2525676</span>] NSBlockOperation 第<span class="number">2</span>次：&lt;NSThread: <span class="number">0x7fb6cbe04590</span>&gt;&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line"> <span class="number">2016</span>-<span class="number">05</span>-<span class="number">06</span> <span class="number">06</span>:<span class="number">01</span>:<span class="number">25.940</span> NSBlockOperationTest[<span class="number">5939</span>:<span class="number">2525676</span>] NSBlockOperation 第<span class="number">3</span>次：&lt;NSThread: <span class="number">0x7fb6cbe04590</span>&gt;&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line"> <span class="number">2016</span>-<span class="number">05</span>-<span class="number">06</span> <span class="number">06</span>:<span class="number">01</span>:<span class="number">25.940</span> NSBlockOperationTest[<span class="number">5939</span>:<span class="number">2525676</span>] NSBlockOperation 第<span class="number">4</span>次：&lt;NSThread: <span class="number">0x7fb6cbe04590</span>&gt;&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line"> <span class="number">2016</span>-<span class="number">05</span>-<span class="number">06</span> <span class="number">06</span>:<span class="number">01</span>:<span class="number">25.940</span> NSBlockOperationTest[<span class="number">5939</span>:<span class="number">2525717</span>] NSBlockOperation 第<span class="number">0</span>次：&lt;NSThread: <span class="number">0x7fb6cbf03040</span>&gt;&#123;number = <span class="number">2</span>, name = (null)&#125;</span><br><span class="line"> <span class="number">2016</span>-<span class="number">05</span>-<span class="number">06</span> <span class="number">06</span>:<span class="number">01</span>:<span class="number">25.940</span> NSBlockOperationTest[<span class="number">5939</span>:<span class="number">2525710</span>] NSBlockOperation 第<span class="number">1</span>次：&lt;NSThread: <span class="number">0x7fb6cbc3f6e0</span>&gt;&#123;number = <span class="number">3</span>, name = (null)&#125;</span><br></pre></td></tr></table></figure>
<p>注意：addExecutionBlock 方法必须在 start() 方法之前执行，否则就会报错：</p>
<figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Terminating app due <span class="keyword">to</span> uncaught exception <span class="attribute">'NSInvalidArgumentException</span>', reason: '*** -[NSBlockOperation addExecutionBlock:]: blocks cannot be added <span class="keyword">after</span> the operation has started executing <span class="keyword">or</span> finished'</span><br></pre></td></tr></table></figure>
<h4 id="NSOperationQueue">NSOperationQueue</h4><p>在 NSOperationQueue 中，任务不会在当前线程执行。当任务添加到队列，会自动调用任务的 start() 方法，所有任务是并行执行的。maxConcurrentOperationCount 可以设置最大任务并行数量，当设置为 1 时，在某种意义上就是串行了。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">    <span class="built_in">NSOperationQueue</span> *queue = [[<span class="built_in">NSOperationQueue</span> alloc] init];</span><br><span class="line">    <span class="built_in">NSBlockOperation</span> *blockOperation = [<span class="built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"NSBlockOperation --- %@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    &#125;];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        [blockOperation addExecutionBlock:^&#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"NSBlockOperation 第%d次：%@"</span>, i, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;</span><br><span class="line">    [queue addOperation:blockOperation];</span><br><span class="line">或者是：</span><br><span class="line">       [queue addOperationWithBlock:^&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"addOperationWithBlock 第%d次：%@"</span>, i, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">        &#125;</span><br><span class="line">        [[<span class="built_in">NSOperationQueue</span> mainQueue] addOperationWithBlock:^&#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"addOperationWithBlock %@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;];</span><br></pre></td></tr></table></figure>
<p>eg:NSOperation 有一个非常实用的功能，那就是添加依赖。比如有 3 个任务：A: 从服务器上下载一张图片，B：给这张图片加个水印，C：把图片返回给服务器。这时就可以用到依赖了:</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSBlockOperation</span> *operation1 = [<span class="built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class="line">       <span class="built_in">NSLog</span>(<span class="string">@"下载图片 --- %@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">   &#125;];</span><br><span class="line">   <span class="built_in">NSBlockOperation</span> *operation2 = [<span class="built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class="line">       <span class="built_in">NSLog</span>(<span class="string">@"打水印 --- %@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">   &#125;];</span><br><span class="line">   <span class="built_in">NSBlockOperation</span> *operation3 = [<span class="built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class="line">       <span class="built_in">NSLog</span>(<span class="string">@"上传图片 --- %@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">   &#125;];</span><br><span class="line">   [operation2 addDependency:operation1];</span><br><span class="line">   [operation3 addDependency:operation2];</span><br><span class="line">   <span class="built_in">NSOperationQueue</span> *operationQueue = [[<span class="built_in">NSOperationQueue</span> alloc] init];</span><br><span class="line">   [operationQueue addOperations:@[operation1,operation2,operation3] waitUntilFinished:<span class="literal">NO</span>];</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2016</span>-<span class="number">05</span>-<span class="number">06</span> <span class="number">06</span>:<span class="number">26</span>:<span class="number">12.732</span> NSOperationQueueTest[<span class="number">6061</span>:<span class="number">2650250</span>] 下载图片 --- &lt;NSThread: <span class="number">0x7fc589e1d740</span>&gt;&#123;number = <span class="number">3</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">05</span>-<span class="number">06</span> <span class="number">06</span>:<span class="number">26</span>:<span class="number">12.733</span> NSOperationQueueTest[<span class="number">6061</span>:<span class="number">2650257</span>] 打水印 --- &lt;NSThread: <span class="number">0x7fc589f01320</span>&gt;&#123;number = <span class="number">4</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">05</span>-<span class="number">06</span> <span class="number">06</span>:<span class="number">26</span>:<span class="number">12.734</span> NSOperationQueueTest[<span class="number">6061</span>:<span class="number">2650257</span>] 上传图片 --- &lt;NSThread: <span class="number">0x7fc589f01320</span>&gt;&#123;number = <span class="number">4</span>, name = (null)&#125;</span><br></pre></td></tr></table></figure>
<p>注意：不能添加相互依赖，会死锁，比如 A依赖B，B依赖A。<br><br>     可以使用 removeDependency 来解除依赖关系。<br><br>     可以在不同的队列之间依赖，反正就是这个依赖是添加到任务身上的，和队列没关系。<br></p>
<p>另外还有以下方法：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSOperation</span></span><br><span class="line"><span class="built_in">BOOL</span> executing; <span class="comment">//判断任务是否正在执行</span></span><br><span class="line"><span class="built_in">BOOL</span> finished; <span class="comment">//判断任务是否完成</span></span><br><span class="line"><span class="keyword">void</span> (^completionBlock)(<span class="keyword">void</span>); <span class="comment">//用来设置完成后需要执行的操作</span></span><br><span class="line">- (<span class="keyword">void</span>)cancel; <span class="comment">//取消任务</span></span><br><span class="line">- (<span class="keyword">void</span>)waitUntilFinished; <span class="comment">//阻塞当前线程直到此任务执行完毕</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">NSOperationQueue</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">NSUInteger</span> operationCount; <span class="comment">//获取队列的任务数</span></span><br><span class="line">- (<span class="keyword">void</span>)cancelAllOperations; <span class="comment">//取消队列中所有的任务</span></span><br><span class="line">- (<span class="keyword">void</span>)waitUntilAllOperationsAreFinished; <span class="comment">//阻塞当前线程直到此队列中的所有任务执行完毕</span></span><br><span class="line">[queue setSuspended:<span class="literal">YES</span>]; <span class="comment">// 暂停queue</span></span><br><span class="line">[queue setSuspended:<span class="literal">NO</span>]; <span class="comment">// 继续queue</span></span><br></pre></td></tr></table></figure>
<p>关于NSOperationQueue中 ：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@property (nullable, assign <span class="comment">/* actually retain */</span>) <span class="keyword">dispatch_queue_t</span> <span class="function">underlyingQueue <span class="title">NS_AVAILABLE</span><span class="params">(<span class="number">10</span>_10, <span class="number">8</span>_0)</span></span>;</span><br></pre></td></tr></table></figure>
<p><a href="http://stackoverflow.com/questions/16563410/get-underlying-dispatch-queue-t-from-nsoperationqueue" target="_blank" rel="external">在这里有介绍其用法</a><br><br><a href="http://stackoverflow.com/questions/31062196/can-nsoperation-have-a-lower-qualityofservice-than-nsoperationqueue/31076475#31076475" target="_blank" rel="external">这里也有解释</a><br><br>这里是苹果的解释：</p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Discussion</span><br><span class="line">The default <span class="built_in">value</span> <span class="operator">of</span> this property is nil. You can <span class="built_in">set</span> <span class="operator">the</span> <span class="built_in">value</span> <span class="operator">of</span> this property <span class="built_in">to</span> <span class="operator">an</span> existing <span class="built_in">dispatch</span> queue <span class="built_in">to</span> have enqueued operations interspersed <span class="operator">with</span> blocks submitted <span class="built_in">to</span> that <span class="built_in">dispatch</span> queue.</span><br><span class="line"></span><br><span class="line">The <span class="built_in">value</span> <span class="operator">of</span> this property should only be <span class="built_in">set</span> <span class="keyword">if</span> there are no operations <span class="operator">in</span> <span class="operator">the</span> queue; setting <span class="operator">the</span> <span class="built_in">value</span> <span class="operator">of</span> this property when operationCount is <span class="operator">not</span> equal <span class="built_in">to</span> <span class="number">0</span> raises <span class="operator">an</span> invalidArgumentException. The <span class="built_in">value</span> <span class="operator">of</span> this property must <span class="operator">not</span> be <span class="operator">the</span> <span class="built_in">value</span> returned <span class="keyword">by</span> dispatch_get_main_queue(). The quality-<span class="operator">of</span>-service level <span class="built_in">set</span> <span class="keyword">for</span> <span class="operator">the</span> underlying <span class="built_in">dispatch</span> queue overrides <span class="keyword">any</span> <span class="built_in">value</span> <span class="built_in">set</span> <span class="keyword">for</span> <span class="operator">the</span> operation queue<span class="string">'s qualityOfService property.</span></span><br></pre></td></tr></table></figure>
<h4 id="自定义Operation">自定义Operation</h4><p>后面会有专门有一节介绍</p>
<hr>
<h3 id="GCD">GCD</h3><p>Grand Central Dispatch 是苹果为多核的并行运算提出的解决方案，所以会自动合理地利用更多的CPU内核（比如双核、四核），最重要的是它会自动管理线程的生命周期（创建线程、调度任务、销毁线程），完全不需要我们管理，我们只需要告诉干什么就行。</p>
<p>在 GCD 中，加入了两个非常重要的概念： 任务 和 队列。 任务即你要执行的，同步、异步和队列 前面已经讲解过。<br></p>
<pre><code>放到串行队列的任务，<span class="keyword">GCD</span> 会 FIFO（先进先出） 地取出来一个，执行一个，然后取下一个，这样一个一个的执行。&lt;br/&gt;

放到并行队列的任务，<span class="keyword">GCD</span> 也会 FIFO的取出来，但不同的是，它取出来一个就会放到别的线程，然后再取出来一个又放到另一个的线程。这样由于取的动作很快，忽略不计，看起来，所有的任务都是一起执行的。不过需要注意，<span class="keyword">GCD</span> 会根据系统资源控制并行的数量，所以如果任务很多，它并不会让所有任务同时执行。&lt;br/&gt;
</code></pre><h4 id="创建队列">创建队列</h4><p>先讲概念：</p>
<p>GCD中的FIFO队列称为dispatch queue，用来保证先进来的任务先得到执行。</p>
<p> dispatch queue分三种</p>
<ul>
<li>Serial：又叫private dispatch queues，同时只执行一个任务。Serial queue常用于同步访问特定的资源或数据。当你创建多个Serial queue时，虽然各自是同步，但serial queue之间是并发执行。(DISPATCH_QUEUE_SERIAL)</li>
<li>Concurrent：又叫global dispatch queue，可以并发的执行多个任务，但执行完成顺序是随机的。(DISPATCH_QUEUE_CONCURRENT)</li>
<li>Main dispatch queue：全局可用的serial queue，在应用程序主线程上执行任务。</li>
</ul>
<p>公开的5个不同队列：<br> 运行在主线程中的main queue，<br> 3个不同优先级的后台队列（High Priority Queue，Default Priority Queue，Low Priority Queue），<br> 以及一个优先级更低的后台队列Background Priority Queue（用于I/O）</p>
<p> 5种队列，主队列（main queue）,四种通用调度队列，自己定制的队列。四种通用调度队列为</p>
<ul>
<li>QOS_CLASS_USER_INTERACTIVE：user interactive等级表示任务需要被立即执行提供好的体验，用来更新UI，响应事件等。这个等级最好保持小规模。</li>
<li>QOS_CLASS_USER_INITIATED：  user initiated等级表示任务由UI发起异步执行。适用场景是需要及时结果同时又可以继续交互的时候。</li>
<li>QOS_CLASS_UTILITY：         utility等级表示需要长时间运行的任务，伴有用户可见进度指示器。经常会用来做计算，I/O，网络，持续的数据填充等任务。这个任务节能。</li>
<li>QOS_CLASS_BACKGROUND：      background等级表示用户不会察觉的任务，使用它来处理预加载，或者不需要用户交互和对时间不敏感的任务。</li>
</ul>
<h5 id="主队列">主队列</h5><p>这是一个特殊的 串行队列,它用于刷新 UI，任何需要刷新 UI 的工作都要在主队列执行.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dispatch_queue_t</span> <span class="built_in">queue</span> = dispatch_get_main_queue();</span><br></pre></td></tr></table></figure>
<h5 id="自定义的队列">自定义的队列</h5><p>其中第一个参数是标识符，用于 DEBUG 的时候标识唯一的队列，可以为空.</p>
<p>第二个参数用来表示创建的队列是串行的还是并行的，传入 DISPATCH_QUEUE_SERIAL 或 NULL 表示创建串行队列。传入 DISPATCH_QUEUE_CONCURRENT 表示创建并行队列。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dispatch_queue_t</span></span><br><span class="line">dispatch_queue_create(<span class="keyword">const</span> <span class="keyword">char</span> *_Nullable label,</span><br><span class="line">		<span class="keyword">dispatch_queue_attr_t</span> _Nullable attr);</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 串行队列</span></span><br><span class="line"><span class="keyword">dispatch_queue_t</span> createQueue = dispatch_queue_create(<span class="string">"com.testQueue"</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">dispatch_queue_t</span> createQueue = dispatch_queue_create(<span class="string">"com.testQueue"</span>, DISPATCH_QUEUE_SERIAL);</span><br><span class="line"><span class="comment">// 并行队列</span></span><br><span class="line"><span class="keyword">dispatch_queue_t</span> createQueue = dispatch_queue_create(<span class="string">"com.testQueue"</span>, DISPATCH_QUEUE_CONCURRENT);</span><br></pre></td></tr></table></figure>
<p>系统还提供了 全局并行队列</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dispatch_queue_t</span> createQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p>全局队列有这几种优先级：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hexcolor">#def</span>ine DISPATCH_QUEUE_PRIORITY_HIGH <span class="number">2</span></span><br><span class="line"><span class="hexcolor">#def</span>ine DISPATCH_QUEUE_PRIORITY_DEFAULT <span class="number">0</span></span><br><span class="line"><span class="hexcolor">#def</span>ine DISPATCH_QUEUE_PRIORITY_LOW (-<span class="number">2</span>)</span><br><span class="line"><span class="hexcolor">#def</span>ine DISPATCH_QUEUE_PRIORITY_BACKGROUND INT16_MIN</span><br></pre></td></tr></table></figure>
<h5 id="创建任务">创建任务</h5><p>同步任务：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_sync</span>(queue, ^&#123;</span><br><span class="line">    </span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">"com.testQueue"</span>, DISPATCH_QUEUE_SERIAL);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"async之前 - %@"</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line"><span class="built_in">dispatch_sync</span>(queue, ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"async1 - %@"</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">dispatch_sync</span>(queue, ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"async2 - %@"</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">dispatch_sync</span>(queue, ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"async3 - %@"</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"async之后 - %@"</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br></pre></td></tr></table></figure>
<p>log:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2016</span>-<span class="number">05</span>-<span class="number">05</span> <span class="number">07</span>:<span class="number">03</span>:<span class="number">01.137</span> syncTest[<span class="number">5181</span>:<span class="number">1954382</span>] async之前 - &lt;NSThread: <span class="number">0x7fd7e9400ec0</span>&gt;&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">05</span>-<span class="number">05</span> <span class="number">07</span>:<span class="number">03</span>:<span class="number">01.138</span> syncTest[<span class="number">5181</span>:<span class="number">1954382</span>] async1 - &lt;NSThread: <span class="number">0x7fd7e9400ec0</span>&gt;&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">05</span>-<span class="number">05</span> <span class="number">07</span>:<span class="number">03</span>:<span class="number">01.138</span> syncTest[<span class="number">5181</span>:<span class="number">1954382</span>] async2 - &lt;NSThread: <span class="number">0x7fd7e9400ec0</span>&gt;&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">05</span>-<span class="number">05</span> <span class="number">07</span>:<span class="number">03</span>:<span class="number">01.138</span> syncTest[<span class="number">5181</span>:<span class="number">1954382</span>] async3 - &lt;NSThread: <span class="number">0x7fd7e9400ec0</span>&gt;&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">05</span>-<span class="number">05</span> <span class="number">07</span>:<span class="number">03</span>:<span class="number">01.138</span> syncTest[<span class="number">5181</span>:<span class="number">1954382</span>] async之后 - &lt;NSThread: <span class="number">0x7fd7e9400ec0</span>&gt;&#123;number = <span class="number">1</span>, name = main&#125;</span><br></pre></td></tr></table></figure>
<p>注意：</p>
<p>1.同步队列无论设置是DISPATCH_QUEUE_SERIAL还是DISPATCH_QUEUE_CONCURRENT，任务都是在主线程执行,会阻塞主线程</p>
<p>2.dispatch_sync 中 queue 不能是 dispatch_get_main_queue() 即为主线程队列，否则会creash</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NSLog</span>(<span class="at_rule">@<span class="string">"dispatch_sync  enter"</span>);</span></span><br><span class="line"><span class="function">dispatch_sync</span>(<span class="function">dispatch_get_main_queue</span>(), ^&#123;</span><br><span class="line">    <span class="function">NSLog</span>(<span class="at_rule">@<span class="string">"dispatch_sync action"</span>);</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="function">NSLog</span>(<span class="at_rule">@<span class="string">"dispatch_sync leave"</span>);</span></span><br></pre></td></tr></table></figure>
<p>异步任务：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_async</span>(createQueue, ^&#123;</span><br><span class="line">    </span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//并行队列 DISPATCH_QUEUE_CONCURRENT</span></span><br><span class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">"com.testQueue"</span>, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"async之前 - %@"</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line"><span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"async1 - %@"</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"async2 - %@"</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"async3 - %@"</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"async之后 - %@"</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br></pre></td></tr></table></figure>
<p>log:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">21</span> <span class="number">07</span>:<span class="number">19</span>:<span class="number">53.817</span> asyncTest[<span class="number">13930</span>:<span class="number">8566716</span>] async之前 - &lt;NSThread: <span class="number">0x600000066a40</span>&gt;&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">21</span> <span class="number">07</span>:<span class="number">19</span>:<span class="number">53.818</span> asyncTest[<span class="number">13930</span>:<span class="number">8566716</span>] async之后 - &lt;NSThread: <span class="number">0x600000066a40</span>&gt;&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">21</span> <span class="number">07</span>:<span class="number">20</span>:<span class="number">59.683</span> asyncTest[<span class="number">13930</span>:<span class="number">8566864</span>] async2 - &lt;NSThread: <span class="number">0x60800007d700</span>&gt;&#123;number = <span class="number">4</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">21</span> <span class="number">07</span>:<span class="number">20</span>:<span class="number">59.683</span> asyncTest[<span class="number">13930</span>:<span class="number">8566862</span>] async3 - &lt;NSThread: <span class="number">0x60000007a9c0</span>&gt;&#123;number = <span class="number">3</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">21</span> <span class="number">07</span>:<span class="number">20</span>:<span class="number">59.683</span> asyncTest[<span class="number">13930</span>:<span class="number">8566867</span>] async1 - &lt;NSThread: <span class="number">0x60000007ad00</span>&gt;&#123;number = <span class="number">5</span>, name = (null)&#125;</span><br></pre></td></tr></table></figure>
<h4 id="队列组">队列组</h4><h5 id="创建队列-1">创建队列</h5><p>group 可以分为 串行和并行的，区别在于DISPATCH_QUEUE_SERIAL和DISPATCH_QUEUE_CONCURRENT设置不同</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dispatch_group_t</span> group = dispatch_group_create();</span><br><span class="line"><span class="keyword">dispatch_queue_t</span> <span class="built_in">queue</span> = dispatch_queue_create(<span class="string">"com.testQueue"</span>, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">dispatch_group_async(group, <span class="built_in">queue</span>, ^&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        NSLog(@<span class="string">"group-01 - %@"</span>, [NSThread currentThread]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);    </span><br><span class="line">dispatch_group_async(group, <span class="built_in">queue</span>, ^&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        NSLog(@<span class="string">"group-03 - %@"</span>, [NSThread currentThread]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>log: 串行,但是异步的，不会阻塞当前线程</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">21</span> <span class="number">08</span>:<span class="number">05</span>:<span class="number">14.110</span> GCDTest[<span class="number">14034</span>:<span class="number">8745909</span>] group-<span class="number">01</span> - &lt;NSThread: <span class="number">0x60000027d100</span>&gt;&#123;number = <span class="number">4</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">21</span> <span class="number">08</span>:<span class="number">05</span>:<span class="number">14.111</span> GCDTest[<span class="number">14034</span>:<span class="number">8745909</span>] group-<span class="number">01</span> - &lt;NSThread: <span class="number">0x60000027d100</span>&gt;&#123;number = <span class="number">4</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">21</span> <span class="number">08</span>:<span class="number">05</span>:<span class="number">14.112</span> GCDTest[<span class="number">14034</span>:<span class="number">8745909</span>] group-<span class="number">01</span> - &lt;NSThread: <span class="number">0x60000027d100</span>&gt;&#123;number = <span class="number">4</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">21</span> <span class="number">08</span>:<span class="number">05</span>:<span class="number">14.112</span> GCDTest[<span class="number">14034</span>:<span class="number">8745909</span>] group-<span class="number">01</span> - &lt;NSThread: <span class="number">0x60000027d100</span>&gt;&#123;number = <span class="number">4</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">21</span> <span class="number">08</span>:<span class="number">05</span>:<span class="number">14.112</span> GCDTest[<span class="number">14034</span>:<span class="number">8745909</span>] group-<span class="number">01</span> - &lt;NSThread: <span class="number">0x60000027d100</span>&gt;&#123;number = <span class="number">4</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">21</span> <span class="number">08</span>:<span class="number">05</span>:<span class="number">19.589</span> GCDTest[<span class="number">14034</span>:<span class="number">8745909</span>] group-<span class="number">03</span> - &lt;NSThread: <span class="number">0x60000027d100</span>&gt;&#123;number = <span class="number">4</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">21</span> <span class="number">08</span>:<span class="number">05</span>:<span class="number">19.590</span> GCDTest[<span class="number">14034</span>:<span class="number">8745909</span>] group-<span class="number">03</span> - &lt;NSThread: <span class="number">0x60000027d100</span>&gt;&#123;number = <span class="number">4</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">21</span> <span class="number">08</span>:<span class="number">05</span>:<span class="number">19.590</span> GCDTest[<span class="number">14034</span>:<span class="number">8745909</span>] group-<span class="number">03</span> - &lt;NSThread: <span class="number">0x60000027d100</span>&gt;&#123;number = <span class="number">4</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">21</span> <span class="number">08</span>:<span class="number">05</span>:<span class="number">19.591</span> GCDTest[<span class="number">14034</span>:<span class="number">8745909</span>] group-<span class="number">03</span> - &lt;NSThread: <span class="number">0x60000027d100</span>&gt;&#123;number = <span class="number">4</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">21</span> <span class="number">08</span>:<span class="number">05</span>:<span class="number">19.591</span> GCDTest[<span class="number">14034</span>:<span class="number">8745909</span>] group-<span class="number">03</span> - &lt;NSThread: <span class="number">0x60000027d100</span>&gt;&#123;number = <span class="number">4</span>, name = (null)&#125;</span><br></pre></td></tr></table></figure>
<p>并行:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">21</span> <span class="number">08</span>:<span class="number">09</span>:<span class="number">46.984</span> GCDTest[<span class="number">14058</span>:<span class="number">8768392</span>] group-<span class="number">03</span> - &lt;NSThread: <span class="number">0x608000273900</span>&gt;&#123;number = <span class="number">4</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">21</span> <span class="number">08</span>:<span class="number">09</span>:<span class="number">46.984</span> GCDTest[<span class="number">14058</span>:<span class="number">8768371</span>] group-<span class="number">01</span> - &lt;NSThread: <span class="number">0x608000273200</span>&gt;&#123;number = <span class="number">3</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">21</span> <span class="number">08</span>:<span class="number">09</span>:<span class="number">46.984</span> GCDTest[<span class="number">14058</span>:<span class="number">8768392</span>] group-<span class="number">03</span> - &lt;NSThread: <span class="number">0x608000273900</span>&gt;&#123;number = <span class="number">4</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">21</span> <span class="number">08</span>:<span class="number">09</span>:<span class="number">46.984</span> GCDTest[<span class="number">14058</span>:<span class="number">8768371</span>] group-<span class="number">01</span> - &lt;NSThread: <span class="number">0x608000273200</span>&gt;&#123;number = <span class="number">3</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">21</span> <span class="number">08</span>:<span class="number">09</span>:<span class="number">46.985</span> GCDTest[<span class="number">14058</span>:<span class="number">8768392</span>] group-<span class="number">03</span> - &lt;NSThread: <span class="number">0x608000273900</span>&gt;&#123;number = <span class="number">4</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">21</span> <span class="number">08</span>:<span class="number">09</span>:<span class="number">46.985</span> GCDTest[<span class="number">14058</span>:<span class="number">8768371</span>] group-<span class="number">01</span> - &lt;NSThread: <span class="number">0x608000273200</span>&gt;&#123;number = <span class="number">3</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">21</span> <span class="number">08</span>:<span class="number">09</span>:<span class="number">46.985</span> GCDTest[<span class="number">14058</span>:<span class="number">8768392</span>] group-<span class="number">03</span> - &lt;NSThread: <span class="number">0x608000273900</span>&gt;&#123;number = <span class="number">4</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">21</span> <span class="number">08</span>:<span class="number">09</span>:<span class="number">46.985</span> GCDTest[<span class="number">14058</span>:<span class="number">8768371</span>] group-<span class="number">01</span> - &lt;NSThread: <span class="number">0x608000273200</span>&gt;&#123;number = <span class="number">3</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">21</span> <span class="number">08</span>:<span class="number">09</span>:<span class="number">46.985</span> GCDTest[<span class="number">14058</span>:<span class="number">8768392</span>] group-<span class="number">03</span> - &lt;NSThread: <span class="number">0x608000273900</span>&gt;&#123;number = <span class="number">4</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">21</span> <span class="number">08</span>:<span class="number">09</span>:<span class="number">46.986</span> GCDTest[<span class="number">14058</span>:<span class="number">8768371</span>] group-<span class="number">01</span> - &lt;NSThread: <span class="number">0x608000273200</span>&gt;&#123;number = <span class="number">3</span>, name = (null)&#125;</span><br></pre></td></tr></table></figure>
<h5 id="监听任务组事件的执行完毕">监听任务组事件的执行完毕</h5><p>1.dispatch_group_notify </p>
<p>用来监听任务组事件的执行完毕, 异步执行闭包，不会阻塞</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span></span><br><span class="line"><span class="title">dispatch_group_notify</span><span class="params">(dispatch_group_t group,</span><br><span class="line">	dispatch_queue_t <span class="built_in">queue</span>,</span><br><span class="line">	dispatch_block_t block)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">dispatch_group_t group = dispatch_group_create<span class="list">()</span><span class="comment">;</span></span><br><span class="line">dispatch_queue_t queue = dispatch_queue_create<span class="list">(<span class="string">"com.testQueue"</span>, DISPATCH_QUEUE_CONCURRENT)</span><span class="comment">;</span></span><br><span class="line">dispatch_group_async<span class="list">(<span class="keyword">group</span>, queue, ^&#123;</span><br><span class="line">    [[NSThread currentThread] setName:@<span class="string">"group-01-thread"</span>]<span class="comment">;</span></span><br><span class="line">    for <span class="list">(<span class="keyword">int</span> i = <span class="number">0</span><span class="comment">; i &lt; 3; i++) &#123;</span></span><br><span class="line">        NSLog<span class="list">(@<span class="string">"group-01 - %@"</span>, [NSThread currentThread])</span><span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><span class="comment">;</span></span><br><span class="line">dispatch_group_async<span class="list">(<span class="keyword">group</span>, queue, ^&#123;</span><br><span class="line">    [[NSThread currentThread] setName:@<span class="string">"group-03-thread"</span>]<span class="comment">;</span></span><br><span class="line">    for <span class="list">(<span class="keyword">int</span> i = <span class="number">0</span><span class="comment">; i &lt; 3; i++) &#123;</span></span><br><span class="line">        NSLog<span class="list">(@<span class="string">"group-03 - %@"</span>, [NSThread currentThread])</span><span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><span class="comment">;</span></span><br><span class="line">NSLog<span class="list">(@<span class="string">"notify leave"</span>)</span><span class="comment">;</span></span><br><span class="line">dispatch_group_notify<span class="list">(<span class="keyword">group</span>, dispatch_get_main_queue<span class="list">()</span>, ^&#123;</span><br><span class="line">    NSLog<span class="list">(@<span class="string">"notify 完成 - %@"</span>, [NSThread currentThread])</span><span class="comment">;</span></span><br><span class="line">&#125;)</span><span class="comment">;</span></span><br><span class="line">NSLog<span class="list">(@<span class="string">"notify leave"</span>)</span><span class="comment">;</span></span></span></span><br></pre></td></tr></table></figure>
<p>log:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">22</span> <span class="number">07</span>:<span class="number">03</span>:<span class="number">18.150</span> GCDTest[<span class="number">19000</span>:<span class="number">9806166</span>] notify leave</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">22</span> <span class="number">07</span>:<span class="number">03</span>:<span class="number">18.150</span> GCDTest[<span class="number">19000</span>:<span class="number">9813919</span>] group-<span class="number">01</span> - &lt;NSThread: <span class="number">0x60000026b700</span>&gt;&#123;number = <span class="number">5</span>, name = group-<span class="number">01</span>-thread&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">22</span> <span class="number">07</span>:<span class="number">03</span>:<span class="number">18.150</span> GCDTest[<span class="number">19000</span>:<span class="number">9814304</span>] group-<span class="number">03</span> - &lt;NSThread: <span class="number">0x608000277800</span>&gt;&#123;number = <span class="number">6</span>, name = group-<span class="number">03</span>-thread&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">22</span> <span class="number">07</span>:<span class="number">03</span>:<span class="number">18.151</span> GCDTest[<span class="number">19000</span>:<span class="number">9806166</span>] notify leave</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">22</span> <span class="number">07</span>:<span class="number">03</span>:<span class="number">18.151</span> GCDTest[<span class="number">19000</span>:<span class="number">9813919</span>] group-<span class="number">01</span> - &lt;NSThread: <span class="number">0x60000026b700</span>&gt;&#123;number = <span class="number">5</span>, name = group-<span class="number">01</span>-thread&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">22</span> <span class="number">07</span>:<span class="number">03</span>:<span class="number">18.151</span> GCDTest[<span class="number">19000</span>:<span class="number">9814304</span>] group-<span class="number">03</span> - &lt;NSThread: <span class="number">0x608000277800</span>&gt;&#123;number = <span class="number">6</span>, name = group-<span class="number">03</span>-thread&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">22</span> <span class="number">07</span>:<span class="number">03</span>:<span class="number">18.152</span> GCDTest[<span class="number">19000</span>:<span class="number">9813919</span>] group-<span class="number">01</span> - &lt;NSThread: <span class="number">0x60000026b700</span>&gt;&#123;number = <span class="number">5</span>, name = group-<span class="number">01</span>-thread&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">22</span> <span class="number">07</span>:<span class="number">03</span>:<span class="number">18.152</span> GCDTest[<span class="number">19000</span>:<span class="number">9814304</span>] group-<span class="number">03</span> - &lt;NSThread: <span class="number">0x608000277800</span>&gt;&#123;number = <span class="number">6</span>, name = group-<span class="number">03</span>-thread&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">22</span> <span class="number">07</span>:<span class="number">03</span>:<span class="number">18.157</span> GCDTest[<span class="number">19000</span>:<span class="number">9806166</span>] notify 完成 - &lt;NSThread: <span class="number">0x60800007b6c0</span>&gt;&#123;number = <span class="number">1</span>, name = main&#125;</span><br></pre></td></tr></table></figure>
<p>2.dispatch_group_wait   </p>
<p>会阻塞当前进程，等所有任务都完成或等待超时。设置等待时间，在等待时间结束后，如果还没有执行完任务组，则返回。返回0代表执行成功，非0则执行失败</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">dispatch_group_wait</span>(<span class="params">dispatch_group_t <span class="keyword">group</span>, dispatch_time_t timeout</span>)</span>;</span><br></pre></td></tr></table></figure>
<p>超时时间 可以根据需要设置，系统提供了两个宏：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hexcolor">#def</span>ine DISPATCH_TIME_NOW (<span class="number">0</span>ull)</span><br><span class="line"><span class="hexcolor">#def</span>ine DISPATCH_TIME_FOREVER (~<span class="number">0</span>ull)</span><br></pre></td></tr></table></figure>
<p>在此之前介绍一下时间：</p>
<p>iOS系统 GCD 中提供了一下几种时间</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hexcolor">#def</span>ine NSEC_PER_SEC  <span class="number">1000000000</span>ull</span><br><span class="line"><span class="hexcolor">#def</span>ine NSEC_PER_MSEC <span class="number">1000000</span>ull</span><br><span class="line"><span class="hexcolor">#def</span>ine USEC_PER_SEC  <span class="number">1000000</span>ull</span><br><span class="line"><span class="hexcolor">#def</span>ine NSEC_PER_USEC <span class="number">1000</span>ull</span><br></pre></td></tr></table></figure>
<p>关键词解释：    </p>
<ul>
<li>NSEC：纳秒</li>
<li>USEC：微秒</li>
<li>MSEC：毫秒</li>
<li>SEC：秒</li>
<li>PER：每</li>
</ul>
<p>故：</p>
<table>
<thead>
<tr>
<th>宏</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>NSEC_PER_SEC</td>
<td style="text-align:center">每秒有多少纳秒</td>
</tr>
<tr>
<td>NSEC_PER_MSEC</td>
<td style="text-align:center">每毫秒有多少纳秒</td>
</tr>
<tr>
<td>USEC_PER_SEC</td>
<td style="text-align:center">每秒有多少微秒</td>
</tr>
<tr>
<td>NSEC_PER_USEC</td>
<td style="text-align:center">每微秒有多少纳秒</td>
</tr>
</tbody>
</table>
<p>所以，延时1秒可以写成如下几种：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dispatch_time<span class="list">(<span class="keyword">DISPATCH_TIME_NOW</span>, <span class="number">1</span> <span class="variable">* NSEC_PER_SEC);</span><br><span class="line">dispatch_time(DISPATCH_TIME_NOW, 1000 *</span> USEC_PER_SEC)</span><span class="comment">;</span></span><br><span class="line">dispatch_time<span class="list">(<span class="keyword">DISPATCH_TIME_NOW</span>, USEC_PER_SEC <span class="variable">* NSEC_PER_USEC);</span><br><span class="line">dispatch_time(DISPATCH_TIME_NOW, NSEC_PER_MSEC *</span> NSEC_PER_USEC)</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>绝对时间，dispatch_group_wait 想等到2016年09月22日23:20:53 的时候超时，那么要使用 dispatch_walltime函数将NSdate 转化为dispatch_time，下面是方法：</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- (dispatch_time_t)switchDateToDispatch_time_tWithDate:(NSDate *)<span class="type">date</span></span><br><span class="line">&#123;</span><br><span class="line">    NSTimeInterval interval;</span><br><span class="line">    double <span class="keyword">second</span>,subsecond;</span><br><span class="line">    struct timespec <span class="property">time</span>;</span><br><span class="line">    dispatch_time_t milestone;</span><br><span class="line">    interval=[<span class="type">date</span> timeIntervalSince1970];</span><br><span class="line">    </span><br><span class="line">    subsecond = modf(interval, &amp;<span class="keyword">second</span>);</span><br><span class="line">    <span class="property">time</span>.tv_sec = <span class="keyword">second</span>;</span><br><span class="line">    <span class="property">time</span>.tv_nsec= subsecond*NSEC_PER_SEC;</span><br><span class="line">    </span><br><span class="line">    milestone = dispatch_walltime(&amp;<span class="property">time</span>, <span class="number">0</span>);</span><br><span class="line"><span class="command">    return</span> milestone;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>好了时间说完了，该说示例了：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dispatch_group_t</span> group = dispatch_group_create();</span><br><span class="line"><span class="keyword">dispatch_queue_t</span> <span class="built_in">queue</span> = dispatch_queue_create(<span class="string">"com.testQueue"</span>, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">dispatch_group_async(group, <span class="built_in">queue</span>, ^&#123;</span><br><span class="line">    [[NSThread currentThread] setName:@<span class="string">"group-01-thread"</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        NSLog(@<span class="string">"group-01 - %@"</span>, [NSThread currentThread]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_group_async(group, <span class="built_in">queue</span>, ^&#123;</span><br><span class="line">    [[NSThread currentThread] setName:@<span class="string">"group-03-thread"</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        NSLog(@<span class="string">"group-03 - %@"</span>, [NSThread currentThread]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">NSLog(@<span class="string">"dispatch_group_wait 之前"</span>);</span><br><span class="line"><span class="keyword">long</span> value = dispatch_group_wait(group, DISPATCH_TIME_FOREVER);</span><br><span class="line">NSLog(@<span class="string">"dispatch_group_wait 之后 value = %ld"</span>,value);</span><br></pre></td></tr></table></figure>
<p>log:</p>
<p>① DISPATCH_TIME_FOREVER 可以看到会阻塞当前线程直到任务全部完成</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">22</span> <span class="number">07</span>:<span class="number">15</span>:<span class="number">14.211</span> GCDTest[<span class="number">19022</span>:<span class="number">9870397</span>] dispatch_group_wait 之前</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">22</span> <span class="number">07</span>:<span class="number">15</span>:<span class="number">14.211</span> GCDTest[<span class="number">19022</span>:<span class="number">9874488</span>] group-<span class="number">01</span> - &lt;NSThread: <span class="number">0x608000268f40</span>&gt;&#123;number = <span class="number">5</span>, name = group-<span class="number">01</span>-thread&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">22</span> <span class="number">07</span>:<span class="number">15</span>:<span class="number">14.211</span> GCDTest[<span class="number">19022</span>:<span class="number">9874995</span>] group-<span class="number">03</span> - &lt;NSThread: <span class="number">0x608000268500</span>&gt;&#123;number = <span class="number">6</span>, name = group-<span class="number">03</span>-thread&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">22</span> <span class="number">07</span>:<span class="number">15</span>:<span class="number">14.211</span> GCDTest[<span class="number">19022</span>:<span class="number">9874488</span>] group-<span class="number">01</span> - &lt;NSThread: <span class="number">0x608000268f40</span>&gt;&#123;number = <span class="number">5</span>, name = group-<span class="number">01</span>-thread&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">22</span> <span class="number">07</span>:<span class="number">15</span>:<span class="number">14.211</span> GCDTest[<span class="number">19022</span>:<span class="number">9874995</span>] group-<span class="number">03</span> - &lt;NSThread: <span class="number">0x608000268500</span>&gt;&#123;number = <span class="number">6</span>, name = group-<span class="number">03</span>-thread&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">22</span> <span class="number">07</span>:<span class="number">15</span>:<span class="number">14.211</span> GCDTest[<span class="number">19022</span>:<span class="number">9874488</span>] group-<span class="number">01</span> - &lt;NSThread: <span class="number">0x608000268f40</span>&gt;&#123;number = <span class="number">5</span>, name = group-<span class="number">01</span>-thread&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">22</span> <span class="number">07</span>:<span class="number">15</span>:<span class="number">14.212</span> GCDTest[<span class="number">19022</span>:<span class="number">9874995</span>] group-<span class="number">03</span> - &lt;NSThread: <span class="number">0x608000268500</span>&gt;&#123;number = <span class="number">6</span>, name = group-<span class="number">03</span>-thread&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">22</span> <span class="number">07</span>:<span class="number">15</span>:<span class="number">14.212</span> GCDTest[<span class="number">19022</span>:<span class="number">9870397</span>] dispatch_group_wait 之后 value = <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>② DISPATCH_TIME_NOW dispatch_group_wait 并未阻塞当前线程 但是 返回非零值，表明任务执行失败或者超时，这明显是超时</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">22</span> <span class="number">07</span>:<span class="number">18</span>:<span class="number">21.506</span> GCDTest[<span class="number">19041</span>:<span class="number">9887622</span>] dispatch_group_wait 之前</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">22</span> <span class="number">07</span>:<span class="number">18</span>:<span class="number">21.506</span> GCDTest[<span class="number">19041</span>:<span class="number">9891849</span>] group-<span class="number">01</span> - &lt;NSThread: <span class="number">0x608000274700</span>&gt;&#123;number = <span class="number">3</span>, name = group-<span class="number">01</span>-thread&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">22</span> <span class="number">07</span>:<span class="number">18</span>:<span class="number">21.506</span> GCDTest[<span class="number">19041</span>:<span class="number">9891894</span>] group-<span class="number">03</span> - &lt;NSThread: <span class="number">0x608000274680</span>&gt;&#123;number = <span class="number">4</span>, name = group-<span class="number">03</span>-thread&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">22</span> <span class="number">07</span>:<span class="number">18</span>:<span class="number">21.506</span> GCDTest[<span class="number">19041</span>:<span class="number">9887622</span>] dispatch_group_wait 之后 value = <span class="number">49</span></span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">22</span> <span class="number">07</span>:<span class="number">18</span>:<span class="number">21.506</span> GCDTest[<span class="number">19041</span>:<span class="number">9891849</span>] group-<span class="number">01</span> - &lt;NSThread: <span class="number">0x608000274700</span>&gt;&#123;number = <span class="number">3</span>, name = group-<span class="number">01</span>-thread&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">22</span> <span class="number">07</span>:<span class="number">18</span>:<span class="number">21.507</span> GCDTest[<span class="number">19041</span>:<span class="number">9891894</span>] group-<span class="number">03</span> - &lt;NSThread: <span class="number">0x608000274680</span>&gt;&#123;number = <span class="number">4</span>, name = group-<span class="number">03</span>-thread&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">22</span> <span class="number">07</span>:<span class="number">18</span>:<span class="number">21.507</span> GCDTest[<span class="number">19041</span>:<span class="number">9891849</span>] group-<span class="number">01</span> - &lt;NSThread: <span class="number">0x608000274700</span>&gt;&#123;number = <span class="number">3</span>, name = group-<span class="number">01</span>-thread&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">22</span> <span class="number">07</span>:<span class="number">18</span>:<span class="number">21.508</span> GCDTest[<span class="number">19041</span>:<span class="number">9891894</span>] group-<span class="number">03</span> - &lt;NSThread: <span class="number">0x608000274680</span>&gt;&#123;number = <span class="number">4</span>, name = group-<span class="number">03</span>-thread&#125;</span><br></pre></td></tr></table></figure>
<p>③ 自定义时间 会阻塞当前的线程</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这里让线程 睡眠2s</span></span><br><span class="line">    dispatch_group_async(group, <span class="built_in">queue</span>, ^&#123;</span><br><span class="line">        [[NSThread currentThread] setName:@<span class="string">"group-03-thread"</span>];</span><br><span class="line">        [NSThread sleepForTimeInterval:<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            NSLog(@<span class="string">"group-03 - %@"</span>, [NSThread currentThread]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"><span class="keyword">long</span> value = dispatch_group_wait(group, dispatch_time(DISPATCH_TIME_NOW, (<span class="keyword">int64_t</span>)(<span class="number">5</span>*NSEC_PER_SEC)));</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">22</span> <span class="number">07</span>:<span class="number">37</span>:<span class="number">32.478</span> GCDTest[<span class="number">19217</span>:<span class="number">10005760</span>] dispatch_group_wait 之前</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">22</span> <span class="number">07</span>:<span class="number">37</span>:<span class="number">32.478</span> GCDTest[<span class="number">19217</span>:<span class="number">10006060</span>] group-<span class="number">01</span> - &lt;NSThread: <span class="number">0x608000274140</span>&gt;&#123;number = <span class="number">3</span>, name = group-<span class="number">01</span>-thread&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">22</span> <span class="number">07</span>:<span class="number">37</span>:<span class="number">32.479</span> GCDTest[<span class="number">19217</span>:<span class="number">10006060</span>] group-<span class="number">01</span> - &lt;NSThread: <span class="number">0x608000274140</span>&gt;&#123;number = <span class="number">3</span>, name = group-<span class="number">01</span>-thread&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">22</span> <span class="number">07</span>:<span class="number">37</span>:<span class="number">32.479</span> GCDTest[<span class="number">19217</span>:<span class="number">10006060</span>] group-<span class="number">01</span> - &lt;NSThread: <span class="number">0x608000274140</span>&gt;&#123;number = <span class="number">3</span>, name = group-<span class="number">01</span>-thread&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">22</span> <span class="number">07</span>:<span class="number">37</span>:<span class="number">34.482</span> GCDTest[<span class="number">19217</span>:<span class="number">10006057</span>] group-<span class="number">03</span> - &lt;NSThread: <span class="number">0x608000273f80</span>&gt;&#123;number = <span class="number">4</span>, name = group-<span class="number">03</span>-thread&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">22</span> <span class="number">07</span>:<span class="number">37</span>:<span class="number">34.483</span> GCDTest[<span class="number">19217</span>:<span class="number">10006057</span>] group-<span class="number">03</span> - &lt;NSThread: <span class="number">0x608000273f80</span>&gt;&#123;number = <span class="number">4</span>, name = group-<span class="number">03</span>-thread&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">22</span> <span class="number">07</span>:<span class="number">37</span>:<span class="number">34.483</span> GCDTest[<span class="number">19217</span>:<span class="number">10006057</span>] group-<span class="number">03</span> - &lt;NSThread: <span class="number">0x608000273f80</span>&gt;&#123;number = <span class="number">4</span>, name = group-<span class="number">03</span>-thread&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">22</span> <span class="number">07</span>:<span class="number">37</span>:<span class="number">34.484</span> GCDTest[<span class="number">19217</span>:<span class="number">10005760</span>] dispatch_group_wait 之后 value = <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>3.dispatch_group_enter  dispatch_group_leave<br>这里 dispatch_group_enter 和 dispatch_group_leave 需要成对出现,否则dispatch_group_notify不会回调用（这里可能会崩溃，不过在我测试中没有发现）</p>
<p>①这是 dispatch_queue_t 的例子：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">dispatch_group_t group = dispatch_group_create<span class="list">()</span><span class="comment">;</span></span><br><span class="line">dispatch_queue_t queue = dispatch_queue_create<span class="list">(<span class="string">"com.testQueue"</span>, DISPATCH_QUEUE_CONCURRENT)</span><span class="comment">;</span></span><br><span class="line">dispatch_group_enter<span class="list">(<span class="keyword">group</span>)</span><span class="comment">;</span></span><br><span class="line">dispatch_group_async<span class="list">(<span class="keyword">group</span>, queue, ^&#123;</span><br><span class="line">    [[NSThread currentThread] setName:@<span class="string">"group-01-thread"</span>]<span class="comment">;</span></span><br><span class="line">    for <span class="list">(<span class="keyword">int</span> i = <span class="number">0</span><span class="comment">; i &lt; 3; i++) &#123;</span></span><br><span class="line">        NSLog<span class="list">(@<span class="string">"group-01 - %@"</span>, [NSThread currentThread])</span><span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line">    dispatch_group_leave<span class="list">(<span class="keyword">group</span>)</span><span class="comment">;</span></span><br><span class="line">&#125;)</span><span class="comment">;</span></span><br><span class="line">dispatch_group_enter<span class="list">(<span class="keyword">group</span>)</span><span class="comment">;</span></span><br><span class="line">dispatch_group_async<span class="list">(<span class="keyword">group</span>, queue, ^&#123;</span><br><span class="line">    [[NSThread currentThread] setName:@<span class="string">"group-03-thread"</span>]<span class="comment">;</span></span><br><span class="line">    [NSThread sleepForTimeInterval:<span class="number">2</span>]<span class="comment">;</span></span><br><span class="line">    for <span class="list">(<span class="keyword">int</span> i = <span class="number">0</span><span class="comment">; i &lt; 3; i++) &#123;</span></span><br><span class="line">        NSLog<span class="list">(@<span class="string">"group-03 - %@"</span>, [NSThread currentThread])</span><span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line">    dispatch_group_leave<span class="list">(<span class="keyword">group</span>)</span><span class="comment">;</span></span><br><span class="line">&#125;)</span><span class="comment">;</span></span><br><span class="line">dispatch_group_notify<span class="list">(<span class="keyword">group</span>, dispatch_get_main_queue<span class="list">()</span>, ^&#123;</span><br><span class="line">    NSLog<span class="list">(@<span class="string">"notify 完成 - %@"</span>, [NSThread currentThread])</span><span class="comment">;</span></span><br><span class="line">&#125;)</span><span class="comment">;</span></span></span></span><br></pre></td></tr></table></figure>
<p>②这是NSOperationQueue的例子：</p>
<figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">dispatch_group_t <span class="keyword">group</span> = dispatch_group_create();</span><br><span class="line">NSOperationQueue *queue = [[NSOperationQueue alloc] init];</span><br><span class="line">dispatch_group_enter(<span class="keyword">group</span>);</span><br><span class="line">NSBlockOperation *<span class="built_in">block</span>Operation_1 = [NSBlockOperation <span class="built_in">block</span>OperationWithBlock:^&#123;</span><br><span class="line">    NSLog(@<span class="string">"NSBlockOperation 1 --- %@"</span>, [NSThread currentThread]);</span><br><span class="line">    [NSThread sleepForTimeInterval:<span class="number">2</span>];</span><br><span class="line">    dispatch_group_leave(<span class="keyword">group</span>);</span><br><span class="line">&#125;];</span><br><span class="line">dispatch_group_enter(<span class="keyword">group</span>);</span><br><span class="line">NSBlockOperation *<span class="built_in">block</span>Operation_2 = [NSBlockOperation <span class="built_in">block</span>OperationWithBlock:^&#123;</span><br><span class="line">    NSLog(@<span class="string">"NSBlockOperation 2 --- %@"</span>, [NSThread currentThread]);</span><br><span class="line">    dispatch_group_leave(<span class="keyword">group</span>);</span><br><span class="line">&#125;];</span><br><span class="line">[<span class="built_in">block</span>Operation_1 <span class="built_in">set</span>Name:@<span class="string">"blockOperation_1"</span>];</span><br><span class="line">[<span class="built_in">block</span>Operation_1 <span class="built_in">set</span>Name:@<span class="string">"blockOperation_2"</span>];</span><br><span class="line">[queue addOperation:<span class="built_in">block</span>Operation_1];</span><br><span class="line">[queue addOperation:<span class="built_in">block</span>Operation_2];</span><br><span class="line">dispatch_group_notify(<span class="keyword">group</span>, dispatch_get_main_queue(), ^&#123;</span><br><span class="line">    NSLog(@<span class="string">"notify 完成 - %@"</span>, [NSThread currentThread]);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h5 id="dispatch_once">dispatch_once</h5><p>dispatch_once 大家都不会陌生，但我认为还是有必要强调一次，dispatch_once_t 必须为静态变量</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line"><span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">    <span class="comment">// to do something</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h5 id="dispatch_after">dispatch_after</h5><p>dispatch_after 能让我们添加进队列的任务延时（这里说延时不严谨，后面会说到）执行</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">NSLog(@<span class="string">"begin"</span>);</span><br><span class="line"><span class="keyword">double</span> delayInSeconds = <span class="number">1.0</span>;</span><br><span class="line"><span class="keyword">dispatch_time_t</span> popTime = dispatch_time(DISPATCH_TIME_NOW, (<span class="keyword">int64_t</span>)(delayInSeconds * NSEC_PER_SEC));</span><br><span class="line">dispatch_after(popTime, dispatch_get_main_queue(), ^&#123;</span><br><span class="line">    NSLog(@<span class="string">"end"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>虽然可以提供NStimer 的功能，但它不是，看下面官方文档：</p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Enqueue <span class="operator">a</span> block <span class="keyword">for</span> execution <span class="keyword">at</span> <span class="operator">the</span> specified <span class="built_in">time</span>.</span><br></pre></td></tr></table></figure>
<p>Enqueue，就是入队，指的就是将一个Block在特定的延时以后，加入到指定的队列中，不是在特定的时间后立即运行！。这里有个例子:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dispatch_queue_t</span> <span class="built_in">queue</span> = dispatch_queue_create(<span class="string">"com.testQueue"</span>, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">NSLog(@<span class="string">"begin"</span>);</span><br><span class="line">dispatch_async(<span class="built_in">queue</span>, ^&#123;</span><br><span class="line">    [[NSThread currentThread] setName:@<span class="string">"group-01-thread"</span>];</span><br><span class="line">    [NSThread sleepForTimeInterval:<span class="number">10</span>];</span><br><span class="line">    NSLog(@<span class="string">"dispatch_group_async"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//1.使用 dispatch_after 延后工作</span></span><br><span class="line"><span class="keyword">double</span> delayInSeconds = <span class="number">5.0</span>;</span><br><span class="line"><span class="keyword">dispatch_time_t</span> popTime = dispatch_time(DISPATCH_TIME_NOW, (<span class="keyword">int64_t</span>)(delayInSeconds * NSEC_PER_SEC));</span><br><span class="line">dispatch_after(popTime, <span class="built_in">queue</span>, ^&#123;</span><br><span class="line">    NSLog(@<span class="string">"dispatch_time"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>log:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">23</span> <span class="number">22</span>:<span class="number">56</span>:<span class="number">05.258</span> GCDTest[<span class="number">20684</span>:<span class="number">11209748</span>] begin</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">23</span> <span class="number">22</span>:<span class="number">56</span>:<span class="number">15.263</span> GCDTest[<span class="number">20684</span>:<span class="number">11209796</span>] dispatch_group_async</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">23</span> <span class="number">22</span>:<span class="number">56</span>:<span class="number">15.263</span> GCDTest[<span class="number">20684</span>:<span class="number">11209796</span>] dispatch_time</span><br></pre></td></tr></table></figure>
<p>从结果也验证了，dispatch_after只是延时提交block，并不是延时后立即执行。所以想用dispatch_after精确控制运行状态的朋友可要注意了~</p>
<h5 id="dispatch_apply">dispatch_apply</h5><p>dispatch_apply的作用是在一个队列（串行或并行）上“运行”多次block，不过会阻塞当前线程，按执行最长任务时间阻塞(异步，同步是所有任务时间总和)，用时间要小心：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dispatch_queue_t</span> <span class="built_in">queue</span> = dispatch_queue_create(<span class="string">"com.testQueue"</span>, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">NSLog(@<span class="string">"apply 之前"</span>);</span><br><span class="line">dispatch_apply(<span class="number">3</span>, <span class="built_in">queue</span>, ^(<span class="keyword">size_t</span> y) &#123;</span><br><span class="line">    <span class="keyword">switch</span> (y) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:[NSThread sleepForTimeInterval:<span class="number">1</span>];<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:[NSThread sleepForTimeInterval:<span class="number">2</span>];<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:[NSThread sleepForTimeInterval:<span class="number">3</span>];<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:<span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    NSLog(@<span class="string">"%ld"</span>,y);</span><br><span class="line">&#125;);</span><br><span class="line">NSLog(@<span class="string">"apply 之后"</span>);</span><br></pre></td></tr></table></figure>
<p>log:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">23</span> <span class="number">23</span>:<span class="number">30</span>:<span class="number">24.984</span> GCDTest[<span class="number">20779</span>:<span class="number">11373252</span>] apply 之前</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">23</span> <span class="number">23</span>:<span class="number">30</span>:<span class="number">25.985</span> GCDTest[<span class="number">20779</span>:<span class="number">11373252</span>] <span class="number">0</span></span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">23</span> <span class="number">23</span>:<span class="number">30</span>:<span class="number">26.987</span> GCDTest[<span class="number">20779</span>:<span class="number">11373585</span>] <span class="number">1</span></span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">23</span> <span class="number">23</span>:<span class="number">30</span>:<span class="number">27.988</span> GCDTest[<span class="number">20779</span>:<span class="number">11373584</span>] <span class="number">2</span></span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">23</span> <span class="number">23</span>:<span class="number">30</span>:<span class="number">27.988</span> GCDTest[<span class="number">20779</span>:<span class="number">11373252</span>] apply 之后</span><br></pre></td></tr></table></figure>
<p>将其放在异步线程去执行，这样就不阻塞主线程了：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">NSLog(@<span class="string">"dispatch_async 之前"</span>);</span><br><span class="line">dispatch_async(dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>), ^&#123;</span><br><span class="line">    <span class="keyword">dispatch_queue_t</span> <span class="built_in">queue</span> = dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">//使用dispatch_apply可以运行的更快</span></span><br><span class="line">    NSLog(@<span class="string">"apply 之前"</span>);</span><br><span class="line">    dispatch_apply(<span class="number">3</span>, <span class="built_in">queue</span>, ^(<span class="keyword">size_t</span> y) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (y) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:[NSThread sleepForTimeInterval:<span class="number">1</span>];<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:[NSThread sleepForTimeInterval:<span class="number">2</span>];<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:[NSThread sleepForTimeInterval:<span class="number">3</span>];<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        NSLog(@<span class="string">"%ld"</span>,y);</span><br><span class="line">    &#125;);</span><br><span class="line">    NSLog(@<span class="string">"apply 之后"</span>);</span><br><span class="line">&#125;);</span><br><span class="line">NSLog(@<span class="string">"dispatch_async 之后"</span>);</span><br></pre></td></tr></table></figure>
<p>log:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">23</span> <span class="number">23</span>:<span class="number">38</span>:<span class="number">21.221</span> GCDTest[<span class="number">20817</span>:<span class="number">11403936</span>] dispatch_async 之前</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">23</span> <span class="number">23</span>:<span class="number">38</span>:<span class="number">21.222</span> GCDTest[<span class="number">20817</span>:<span class="number">11403936</span>] dispatch_async 之后</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">23</span> <span class="number">23</span>:<span class="number">38</span>:<span class="number">21.222</span> GCDTest[<span class="number">20817</span>:<span class="number">11404070</span>] apply 之前</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">23</span> <span class="number">23</span>:<span class="number">38</span>:<span class="number">22.223</span> GCDTest[<span class="number">20817</span>:<span class="number">11404070</span>] <span class="number">0</span></span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">23</span> <span class="number">23</span>:<span class="number">38</span>:<span class="number">23.226</span> GCDTest[<span class="number">20817</span>:<span class="number">11404072</span>] <span class="number">1</span></span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">23</span> <span class="number">23</span>:<span class="number">38</span>:<span class="number">24.225</span> GCDTest[<span class="number">20817</span>:<span class="number">11404069</span>] <span class="number">2</span></span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">23</span> <span class="number">23</span>:<span class="number">38</span>:<span class="number">24.226</span> GCDTest[<span class="number">20817</span>:<span class="number">11404070</span>] apply 之后</span><br></pre></td></tr></table></figure>
<h5 id="dispatch_barrier_async">dispatch_barrier_async</h5><p>dispatch_barrier_async的作用就是向某个队列插入一个block，当目前正在执行的block运行完成后，阻塞这个block后面添加的block，只运行这个block直到完成，然后再继续后续的任务。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">dispatch_group_t group = dispatch_group_create<span class="list">()</span><span class="comment">;</span></span><br><span class="line">//    dispatch_queue_t queue = dispatch_get_global_queue<span class="list">(<span class="keyword">DISPATCH_QUEUE_PRIORITY_DEFAULT</span>, <span class="number">0</span>)</span><span class="comment">;</span></span><br><span class="line">dispatch_queue_t queue = dispatch_queue_create<span class="list">(<span class="string">"com.testQueue"</span>, DISPATCH_QUEUE_CONCURRENT)</span><span class="comment">;</span></span><br><span class="line">dispatch_group_async<span class="list">(<span class="keyword">group</span>, queue, ^&#123;</span><br><span class="line">    NSLog<span class="list">(@<span class="string">"group-01 - %@"</span>, [NSThread currentThread])</span><span class="comment">;</span></span><br><span class="line">&#125;)</span><span class="comment">;</span></span><br><span class="line"></span><br><span class="line">dispatch_barrier_async<span class="list">(<span class="keyword">queue</span>, ^&#123;</span><br><span class="line">    NSLog<span class="list">(@<span class="string">"barrier - %@"</span>, [NSThread currentThread])</span><span class="comment">;</span></span><br><span class="line">&#125;)</span><span class="comment">;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">dispatch_group_async<span class="list">(<span class="keyword">group</span>, queue, ^&#123;</span><br><span class="line">    for <span class="list">(<span class="keyword">int</span> i = <span class="number">0</span><span class="comment">; i &lt; 3; i++) &#123;</span></span><br><span class="line">        NSLog<span class="list">(@<span class="string">"group-02 - %@"</span>, [NSThread currentThread])</span><span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><span class="comment">;</span></span><br><span class="line"></span><br><span class="line">dispatch_group_async<span class="list">(<span class="keyword">group</span>, queue, ^&#123;</span><br><span class="line">    for <span class="list">(<span class="keyword">int</span> i = <span class="number">0</span><span class="comment">; i &lt; 3; i++) &#123;</span></span><br><span class="line">        NSLog<span class="list">(@<span class="string">"group-03 - %@"</span>, [NSThread currentThread])</span><span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><span class="comment">;</span></span></span></span><br></pre></td></tr></table></figure>
<p>log:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">23</span> <span class="number">23</span>:<span class="number">54</span>:<span class="number">08.478</span> GCDTest[<span class="number">20928</span>:<span class="number">11478999</span>] group-<span class="number">01</span> - &lt;NSThread: <span class="number">0x608000265700</span>&gt;&#123;number = <span class="number">3</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">23</span> <span class="number">23</span>:<span class="number">54</span>:<span class="number">08.478</span> GCDTest[<span class="number">20928</span>:<span class="number">11478999</span>] barrier - &lt;NSThread: <span class="number">0x608000265700</span>&gt;&#123;number = <span class="number">3</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">23</span> <span class="number">23</span>:<span class="number">54</span>:<span class="number">08.480</span> GCDTest[<span class="number">20928</span>:<span class="number">11478999</span>] group-<span class="number">02</span> - &lt;NSThread: <span class="number">0x608000265700</span>&gt;&#123;number = <span class="number">3</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">23</span> <span class="number">23</span>:<span class="number">54</span>:<span class="number">08.480</span> GCDTest[<span class="number">20928</span>:<span class="number">11478997</span>] group-<span class="number">03</span> - &lt;NSThread: <span class="number">0x60000026c680</span>&gt;&#123;number = <span class="number">4</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">23</span> <span class="number">23</span>:<span class="number">54</span>:<span class="number">08.481</span> GCDTest[<span class="number">20928</span>:<span class="number">11478999</span>] group-<span class="number">02</span> - &lt;NSThread: <span class="number">0x608000265700</span>&gt;&#123;number = <span class="number">3</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">23</span> <span class="number">23</span>:<span class="number">54</span>:<span class="number">08.481</span> GCDTest[<span class="number">20928</span>:<span class="number">11478997</span>] group-<span class="number">03</span> - &lt;NSThread: <span class="number">0x60000026c680</span>&gt;&#123;number = <span class="number">4</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">23</span> <span class="number">23</span>:<span class="number">54</span>:<span class="number">08.482</span> GCDTest[<span class="number">20928</span>:<span class="number">11478999</span>] group-<span class="number">02</span> - &lt;NSThread: <span class="number">0x608000265700</span>&gt;&#123;number = <span class="number">3</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">23</span> <span class="number">23</span>:<span class="number">54</span>:<span class="number">08.482</span> GCDTest[<span class="number">20928</span>:<span class="number">11478997</span>] group-<span class="number">03</span> - &lt;NSThread: <span class="number">0x60000026c680</span>&gt;&#123;number = <span class="number">4</span>, name = (null)&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>dispatch<em>barrier\</em>(a)sync 只在自己创建的并发队列上有效，在全局(Global)并发队列、串行队列上，效果跟dispatch_(a)sync效果一样。</li>
<li>既然在串行队列上跟dispatch_(a)sync效果一样，那就要小心别死锁！</li>
</ul>
<p>在dispatch_get_global_queue：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">23</span> <span class="number">23</span>:<span class="number">56</span>:<span class="number">14.201</span> GCDTest[<span class="number">20946</span>:<span class="number">11496633</span>] group-<span class="number">01</span> - &lt;NSThread: <span class="number">0x608000263780</span>&gt;&#123;number = <span class="number">3</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">23</span> <span class="number">23</span>:<span class="number">56</span>:<span class="number">14.201</span> GCDTest[<span class="number">20946</span>:<span class="number">11497029</span>] group-<span class="number">02</span> - &lt;NSThread: <span class="number">0x600000277200</span>&gt;&#123;number = <span class="number">5</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">23</span> <span class="number">23</span>:<span class="number">56</span>:<span class="number">14.201</span> GCDTest[<span class="number">20946</span>:<span class="number">11497030</span>] group-<span class="number">03</span> - &lt;NSThread: <span class="number">0x608000265840</span>&gt;&#123;number = <span class="number">6</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">23</span> <span class="number">23</span>:<span class="number">56</span>:<span class="number">14.201</span> GCDTest[<span class="number">20946</span>:<span class="number">11497028</span>] barrier - &lt;NSThread: <span class="number">0x608000265680</span>&gt;&#123;number = <span class="number">4</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">23</span> <span class="number">23</span>:<span class="number">56</span>:<span class="number">14.201</span> GCDTest[<span class="number">20946</span>:<span class="number">11497029</span>] group-<span class="number">02</span> - &lt;NSThread: <span class="number">0x600000277200</span>&gt;&#123;number = <span class="number">5</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">23</span> <span class="number">23</span>:<span class="number">56</span>:<span class="number">14.201</span> GCDTest[<span class="number">20946</span>:<span class="number">11497030</span>] group-<span class="number">03</span> - &lt;NSThread: <span class="number">0x608000265840</span>&gt;&#123;number = <span class="number">6</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">23</span> <span class="number">23</span>:<span class="number">56</span>:<span class="number">14.202</span> GCDTest[<span class="number">20946</span>:<span class="number">11497029</span>] group-<span class="number">02</span> - &lt;NSThread: <span class="number">0x600000277200</span>&gt;&#123;number = <span class="number">5</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">23</span> <span class="number">23</span>:<span class="number">56</span>:<span class="number">14.202</span> GCDTest[<span class="number">20946</span>:<span class="number">11497030</span>] group-<span class="number">03</span> - &lt;NSThread: <span class="number">0x608000265840</span>&gt;&#123;number = <span class="number">6</span>, name = (null)&#125;</span><br></pre></td></tr></table></figure>
<h5 id="暂停与恢复">暂停与恢复</h5><ul>
<li>dispatch_suspend(queue); 暂停队列</li>
<li>dispatch_resume(queue); 恢复队列</li>
</ul>
<p>dispatch_suspend函数对已经执行的处理没有影响。挂起后，追加到 Dispatch Queue 中但尚未执行的处理在此之后停止执行。而dispatch_resume则使得这些处理能够继续执行。</p>
<p>这里有个例子（<a href="https://github.com/ChenYilong/ParseSourceCodeStudy/blob/master/01_Parse的多线程处理思路/Parse的底层多线程处理思路.md#parse-ios-sdk介绍" target="_blank" rel="external">参考来自这里</a>）</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t queue1 = dispatch_queue_create<span class="list">(<span class="string">"com.queue1"</span>, <span class="number">0</span>)</span><span class="comment">;</span></span><br><span class="line">dispatch_queue_t queue2 = dispatch_queue_create<span class="list">(<span class="string">"com.queue2"</span>, <span class="number">0</span>)</span><span class="comment">;</span></span><br><span class="line">dispatch_group_t group  = dispatch_group_create<span class="list">()</span><span class="comment">;</span></span><br><span class="line">dispatch_async<span class="list">(<span class="keyword">queue1</span>, ^&#123;</span><br><span class="line">    NSLog<span class="list">(@<span class="string">"任务 1 ： queue 1..."</span>)</span><span class="comment">;</span></span><br><span class="line">    sleep<span class="list">(<span class="number">1</span>)</span><span class="comment">;</span></span><br><span class="line">    NSLog<span class="list">(@<span class="string">"✅完成任务 1"</span>)</span><span class="comment">;</span></span><br><span class="line">&#125;)</span><span class="comment">;</span></span><br><span class="line"></span><br><span class="line">dispatch_async<span class="list">(<span class="keyword">queue2</span>, ^&#123;</span><br><span class="line">    NSLog<span class="list">(@<span class="string">"任务 1 ： queue 2..."</span>)</span><span class="comment">;</span></span><br><span class="line">    sleep<span class="list">(<span class="number">1</span>)</span><span class="comment">;</span></span><br><span class="line">    NSLog<span class="list">(@<span class="string">"✅完成任务 2"</span>)</span><span class="comment">;</span></span><br><span class="line">&#125;)</span><span class="comment">;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">dispatch_group_async<span class="list">(<span class="keyword">group</span>, queue1, ^&#123;</span><br><span class="line">    NSLog<span class="list">(@<span class="string">"🚫正在暂停 1"</span>)</span><span class="comment">;</span></span><br><span class="line">    dispatch_suspend<span class="list">(<span class="keyword">queue1</span>)</span><span class="comment">;</span></span><br><span class="line">&#125;)</span><span class="comment">;</span></span><br><span class="line">dispatch_group_async<span class="list">(<span class="keyword">group</span>, queue2, ^&#123;</span><br><span class="line">    NSLog<span class="list">(@<span class="string">"🚫正在暂停 2"</span>)</span><span class="comment">;</span></span><br><span class="line">    dispatch_suspend<span class="list">(<span class="keyword">queue2</span>)</span><span class="comment">;</span></span><br><span class="line">&#125;)</span><span class="comment">;</span></span><br><span class="line">dispatch_group_wait<span class="list">(<span class="keyword">group</span>, DISPATCH_TIME_FOREVER)</span><span class="comment">;</span></span><br><span class="line">NSLog<span class="list">(@<span class="string">"＝＝＝＝＝＝＝等待两个queue完成, 再往下进行..."</span>)</span><span class="comment">;</span></span><br><span class="line">dispatch_async<span class="list">(<span class="keyword">queue1</span>, ^&#123;</span><br><span class="line">    NSLog<span class="list">(@<span class="string">"任务 2 ： queue 1"</span>)</span><span class="comment">;</span></span><br><span class="line">&#125;)</span><span class="comment">;</span></span><br><span class="line">dispatch_async<span class="list">(<span class="keyword">queue2</span>, ^&#123;</span><br><span class="line">    NSLog<span class="list">(@<span class="string">"任务 2 ： queue 2"</span>)</span><span class="comment">;</span></span><br><span class="line">&#125;)</span><span class="comment">;</span></span><br><span class="line">NSLog<span class="list">(@<span class="string">"🔴为什么这个NSLog会在上面两个NSLog之前打印❓❓答：dispatch_suspend的作用‼️"</span>)</span><span class="comment">;</span></span><br><span class="line"></span><br><span class="line">dispatch_resume<span class="list">(<span class="keyword">queue1</span>)</span><span class="comment">;</span></span><br><span class="line">dispatch_resume<span class="list">(<span class="keyword">queue2</span>)</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>log:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">24</span> <span class="number">22</span>:<span class="number">12</span>:<span class="number">58.646</span> GCDTest[<span class="number">22178</span>:<span class="number">12407680</span>] 任务 <span class="number">1</span> ： <span class="built_in">queue</span> <span class="number">1.</span>..</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">24</span> <span class="number">22</span>:<span class="number">12</span>:<span class="number">58.646</span> GCDTest[<span class="number">22178</span>:<span class="number">12408707</span>] 任务 <span class="number">1</span> ： <span class="built_in">queue</span> <span class="number">2.</span>..</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">24</span> <span class="number">22</span>:<span class="number">12</span>:<span class="number">59.650</span> GCDTest[<span class="number">22178</span>:<span class="number">12407680</span>] ✅完成任务 <span class="number">1</span></span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">24</span> <span class="number">22</span>:<span class="number">12</span>:<span class="number">59.650</span> GCDTest[<span class="number">22178</span>:<span class="number">12408707</span>] ✅完成任务 <span class="number">2</span></span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">24</span> <span class="number">22</span>:<span class="number">12</span>:<span class="number">59.650</span> GCDTest[<span class="number">22178</span>:<span class="number">12407680</span>] 🚫正在暂停 <span class="number">1</span></span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">24</span> <span class="number">22</span>:<span class="number">12</span>:<span class="number">59.650</span> GCDTest[<span class="number">22178</span>:<span class="number">12408707</span>] 🚫正在暂停 <span class="number">2</span></span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">24</span> <span class="number">22</span>:<span class="number">12</span>:<span class="number">59.650</span> GCDTest[<span class="number">22178</span>:<span class="number">12407286</span>] ＝＝＝＝＝＝＝等待两个<span class="built_in">queue</span>完成, 再往下进行...</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">24</span> <span class="number">22</span>:<span class="number">12</span>:<span class="number">59.651</span> GCDTest[<span class="number">22178</span>:<span class="number">12407286</span>] 🔴为什么这个NSLog会在上面两个NSLog之前打印❓❓答：dispatch_suspend的作用‼️</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">24</span> <span class="number">22</span>:<span class="number">12</span>:<span class="number">59.651</span> GCDTest[<span class="number">22178</span>:<span class="number">12408707</span>] 任务 <span class="number">2</span> ： <span class="built_in">queue</span> <span class="number">1</span></span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">24</span> <span class="number">22</span>:<span class="number">12</span>:<span class="number">59.651</span> GCDTest[<span class="number">22178</span>:<span class="number">12407680</span>] 任务 <span class="number">2</span> ： <span class="built_in">queue</span> <span class="number">2</span></span><br></pre></td></tr></table></figure>
<h4 id="Dispatch_Source_（信号源)">Dispatch Source （信号源)</h4><p>GCD中除了主要的 Dispatch Queue 外，还有不太引人注目的 Dispatch Source .它是BSD系内核惯有功能kqueue的包装。kqueue 是在 XNU 内核中发生各种事件时，在应用程序编程方执行处理的技术。其 CPU 负荷非常小，尽量不占用资源。kqueue 可以说是应用程序处理 XNU 内核中发生的各种事件的方法中最优秀的一种。</p>
<p>Dispatch Source是GCD中的一个基本类型，从字面意思可称为调度源，它的作用是当有一些特定的较底层的系统事件发生时，调度源会捕捉到这些事件，然后可以做其他的逻辑处理，调度源有多种类型，分别监听对应类型的系统事件。</p>
<p>Dispatch Source 可处理的所有事件。如下表所示：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th style="text-align:center">内容</th>
</tr>
</thead>
<tbody>
<tr>
<td>DISPATCH_SOURCE_TYPE_DATA_ADD</td>
<td style="text-align:center">变量增加</td>
</tr>
<tr>
<td>DISPATCH_SOURCE_TYPE_DATA_OR</td>
<td style="text-align:center">变量OR</td>
</tr>
<tr>
<td>DISPATCH_SOURCE_TYPE_MACH_SEND</td>
<td style="text-align:center">MACH端口发送</td>
</tr>
<tr>
<td>DISPATCH_SOURCE_TYPE_MACH_RECV</td>
<td style="text-align:center">MACH端口接收</td>
</tr>
<tr>
<td>DISPATCH_SOURCE_TYPE_PROC</td>
<td style="text-align:center">监测到与进程相关的事件</td>
</tr>
<tr>
<td>DISPATCH_SOURCE_TYPE_READ</td>
<td style="text-align:center">可读取文件映像</td>
</tr>
<tr>
<td>DISPATCH_SOURCE_TYPE_SIGNAL</td>
<td style="text-align:center">接收信号</td>
</tr>
<tr>
<td>DISPATCH_SOURCE_TYPE_TIMER</td>
<td style="text-align:center">定时器</td>
</tr>
<tr>
<td>DISPATCH_SOURCE_TYPE_VNODE</td>
<td style="text-align:center">文件系统有变更</td>
</tr>
<tr>
<td>DISPATCH_SOURCE_TYPE_WRITE</td>
<td style="text-align:center">可写入文件映像</td>
</tr>
</tbody>
</table>
<p> 其中DISPATCH_SOURCE_TYPE_DATA_ADD和DISPATCH_SOURCE_TYPE_DATA_OR是常用的两个，其它用于Mac开发的比较多。</p>
<p> 在任一线程上调用它的的一个函数 dispatch_source_merge_data 后，会执行 Dispatch Source 事先定义好的句柄（可以把句柄简单理解为一个 block ）。</p>
<p>这个过程叫 Custom event ,用户事件。是 dispatch source 支持处理的一种事件。</p>
<p>例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">dispatch_source_t</span> queueSource = dispatch_source_create(DISPATCH_SOURCE_TYPE_DATA_ADD, <span class="number">0</span>, <span class="number">0</span>, dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line"> __block NSUInteger totalComplete = <span class="number">0</span>;</span><br><span class="line">dispatch_source_set_event_handler(queueSource, ^&#123;</span><br><span class="line">    <span class="comment">//当处理事件被最终执行时，计算后的数据可以通过dispatch_source_get_data来获取。</span></span><br><span class="line">    <span class="comment">//这个数据的值在每次响应事件执行后会被重置，所以totalComplete的值是最终累积的值。</span></span><br><span class="line">    NSUInteger value = dispatch_source_get_data(queueSource);</span><br><span class="line">    totalComplete += value;</span><br><span class="line">    NSLog(@<span class="string">"进度：%@"</span>, @((CGFloat)totalComplete/<span class="number">100</span>));</span><br><span class="line">&#125;);</span><br><span class="line">  <span class="comment">/*</span><br><span class="line">  分派源创建时默认处于暂停状态，在分派源分派处理程序之前必须先恢复。</span><br><span class="line">  因为忘记恢复分派源的状态而产生bug是常见的事儿。</span><br><span class="line">  恢复的方法是调用 dispatch_resume :</span><br><span class="line">  */</span></span><br><span class="line"> dispatch_resume(queueSource);</span><br><span class="line"> </span><br><span class="line"> <span class="comment">/*</span><br><span class="line">  在每次循环中执行加1操作。也可以传递已处理记录的数目或已写入的字节数。</span><br><span class="line">  在任何线程中都可以调用 dispatch_source_merge_data 。</span><br><span class="line">  需要注意的是，不可以传递0值(事件不会被触发)，同样也不可以传递负数(会无穷大)。</span><br><span class="line">  */</span></span><br><span class="line"> <span class="keyword">dispatch_queue_t</span> <span class="built_in">queue</span> = dispatch_queue_create(<span class="string">"com.sourcequeue"</span>, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line"> <span class="keyword">for</span> (NSUInteger index = <span class="number">0</span>; index &lt; <span class="number">10</span>; index++) &#123;</span><br><span class="line">     dispatch_async(<span class="built_in">queue</span>, ^&#123;</span><br><span class="line">         dispatch_source_merge_data(queueSource, <span class="number">1</span>);</span><br><span class="line">         [NSThread sleepForTimeInterval:<span class="number">1</span>];</span><br><span class="line">     &#125;);</span><br><span class="line"> &#125;</span><br><span class="line"> NSLog(@<span class="string">"queue for 循环 完成"</span>);</span><br></pre></td></tr></table></figure>
<p>log:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">25</span> <span class="number">09</span>:<span class="number">35</span>:<span class="number">20.128</span> GCDTest[<span class="number">22525</span>:<span class="number">12717227</span>] <span class="built_in">queue</span> <span class="keyword">for</span> 循环 完成</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">25</span> <span class="number">09</span>:<span class="number">35</span>:<span class="number">20.129</span> GCDTest[<span class="number">22525</span>:<span class="number">12718440</span>] 进度：<span class="number">0.3</span></span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">25</span> <span class="number">09</span>:<span class="number">35</span>:<span class="number">20.129</span> GCDTest[<span class="number">22525</span>:<span class="number">12718440</span>] 进度：<span class="number">0.4</span></span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">25</span> <span class="number">09</span>:<span class="number">35</span>:<span class="number">20.129</span> GCDTest[<span class="number">22525</span>:<span class="number">12718440</span>] 进度：<span class="number">0.6</span></span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">25</span> <span class="number">09</span>:<span class="number">35</span>:<span class="number">20.130</span> GCDTest[<span class="number">22525</span>:<span class="number">12718440</span>] 进度：<span class="number">0.9</span></span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">25</span> <span class="number">09</span>:<span class="number">35</span>:<span class="number">20.130</span> GCDTest[<span class="number">22525</span>:<span class="number">12718440</span>] 进度：<span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>可以看到 0.1~1 并没有全部打印，而是跳过：</p>
<p>这是 DispatchSource 能通过合并事件的方式确保在高负载下正常工作 的能力</p>
<p>在同一时间，只有一个处理 block 的实例被分配，如果这个处理方法还没有执行完毕，另一个事件就发生了，事件会以指定方式（ADD或 OR）进行累积。DispatchSource能通过合并事件（block）的方式确保在高负载下正常工作。当处理事件被最终执行时，计算后的数据可以通过 dispatch_source_get_data 来获取。这个数据的值在每次响应时间执行后会被重置，所以上面的例子中进度条 totalComplete 的值是最终积累的值，而 block 不是每次都执行的。但能确保进度条能从0.0到1.0的正常执行。</p>
<h4 id="Dispatch_Semaphore_信号量">Dispatch Semaphore 信号量</h4><p>为了展示作用，举个反例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dispatch_queue_t</span> <span class="built_in">queue</span> = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</span><br><span class="line"> NSMutableArray *<span class="built_in">array</span> = [[NSMutableArray alloc] init];</span><br><span class="line"> <span class="keyword">dispatch_group_t</span> group = dispatch_group_create();</span><br><span class="line"> <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; <span class="number">100000</span>; ++i) &#123;</span><br><span class="line">     dispatch_group_async(group, <span class="built_in">queue</span>, ^&#123;</span><br><span class="line">         [<span class="built_in">array</span> addObject:[NSNumber numberWithInt:i]];</span><br><span class="line">     &#125;);</span><br><span class="line"> &#125;</span><br><span class="line"> dispatch_group_wait(group, DISPATCH_TIME_FOREVER);</span><br><span class="line"> NSLog(@<span class="string">"%@"</span>,  @([<span class="built_in">array</span> count]));</span><br></pre></td></tr></table></figure>
<p>然后就发生了崩溃：</p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">malloc: *** error <span class="keyword">for</span> object <span class="number">0x7f88ed03ca00</span>: pointer being freed was <span class="operator">not</span> allocated</span><br><span class="line">*** <span class="built_in">set</span> <span class="operator">a</span> <span class="built_in">breakpoint</span> <span class="operator">in</span> malloc_error_break <span class="built_in">to</span> debug</span><br></pre></td></tr></table></figure>
<p>这种资源抢夺的情况，一般的做法是使用串行队列，或者像下面一样的同步队列，得以解决：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dispatch_queue_t</span> <span class="built_in">queue</span> = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</span><br><span class="line">NSMutableArray *<span class="built_in">array</span> = [[NSMutableArray alloc] init];</span><br><span class="line"><span class="keyword">dispatch_group_t</span> group = dispatch_group_create();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; <span class="number">1000</span>; ++i) &#123;</span><br><span class="line">    dispatch_sync(<span class="built_in">queue</span>, ^&#123;</span><br><span class="line">        [<span class="built_in">array</span> addObject:[NSNumber numberWithInt:i]];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">dispatch_group_wait(group, DISPATCH_TIME_FOREVER);</span><br><span class="line">NSLog(@<span class="string">"%@"</span>,  @([<span class="built_in">array</span> count]));</span><br></pre></td></tr></table></figure>
<p>dispatch_semaphore_t 的作用之一就是解决这种资源抢夺的情况,下面展示下展示使用 dispatch_semaphore_t 的解决方案：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dispatch_queue_t</span> <span class="built_in">queue</span> = dispatch_queue_create(<span class="string">"com.semaphore"</span>, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line"><span class="keyword">dispatch_semaphore_t</span> semaphore = dispatch_semaphore_create(<span class="number">1</span>);</span><br><span class="line">NSMutableArray *<span class="built_in">array</span> = [[NSMutableArray alloc] init];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">    dispatch_async(<span class="built_in">queue</span>, ^&#123;</span><br><span class="line">        dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</span><br><span class="line">        NSLog(@<span class="string">"🔴%@  index = %d"</span>,[NSThread currentThread],i);</span><br><span class="line">        [<span class="built_in">array</span> addObject:@(i)];</span><br><span class="line">        dispatch_semaphore_signal(semaphore);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">dispatch_barrier_async(<span class="built_in">queue</span>, ^&#123;</span><br><span class="line">    NSLog(@<span class="string">"🔴类名与方法名：%s（在第%d行），描述：%@"</span>, __PRETTY_FUNCTION__, __LINE__, @([<span class="built_in">array</span> count]));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>测试,设置：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dispatch_semaphore_t</span> semaphore = dispatch_semaphore_create(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p>可以发现 程序会永远停留在：</p>
<figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">等待<span class="keyword">Dispatch</span> Semaphore</span><br><span class="line">一直等待，直到<span class="keyword">Dispatch</span> Semaphore的计数值达到大于等于<span class="number">1</span></span><br><span class="line">dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</span><br></pre></td></tr></table></figure>
<p><a href="http://www.cnblogs.com/snailHL/p/3906112.html" target="_blank" rel="external">关于信号量这里有非常详细的解释</a></p>
<p>dispatch_semaphore是GCD用来同步的一种方式，与他相关的共有三个函数，分别是</p>
<p>dispatch_semaphore_create，dispatch_semaphore_signal，dispatch_semaphore_wait。</p>
<p>下面我们逐一介绍三个函数：</p>
<p>①dispatch_semaphore_create的声明为：</p>
<pre><code><span class="keyword">dispatch_semaphore_t</span>  dispatch_semaphore_create(<span class="keyword">long</span> value);

传入的参数为<span class="keyword">long</span>，输出一个<span class="keyword">dispatch_semaphore_t</span>类型且值为value的信号量。

值得注意的是，这里的传入的参数value必须大于或等于<span class="number">0</span>，否则dispatch_semaphore_create会返回<span class="literal">NULL</span>。

（关于信号量，我就不在这里累述了，网上很多介绍这个的。我们这里主要讲一下dispatch_semaphore这三个函数的用法）。
</code></pre><p>②dispatch_semaphore_signal的声明为：</p>
<pre><code><span class="keyword">long</span> dispatch_semaphore_signal(dispatch_semaphore_t dsema)

这个函数会使传入的信号量dsema的值加<span class="number">1</span>；（至于返回值，待会儿再讲）
dispatch_semaphore_signal的返回值为<span class="keyword">long</span>类型，当返回值为<span class="number">0</span>时表示当前并没有线程等待其处理的信号量，其处理

的信号量的值加<span class="number">1</span>即可。当返回值不为<span class="number">0</span>时，表示其当前有（一个或多个）线程等待其处理的信号量，并且该函数唤醒了一

个等待的线程（当线程有优先级时，唤醒优先级最高的线程；否则随机唤醒）。

dispatch_semaphore_wait的返回值也为<span class="keyword">long</span>型。当其返回<span class="number">0</span>时表示在timeout之前，该函数所处的线程被成功唤醒。

当其返回不为<span class="number">0</span>时，表示timeout发生。
</code></pre><p>③dispatch_semaphore_wait的声明为：</p>
<pre><code>long dispatch_semaphore_wait(dispatch_semaphore_t dsema, dispatch_time_t <span class="keyword">timeout</span>)；

这个函数会使传入的信号量dsema的值减<span class="number">1</span>；

这个函数的作用是这样的，如果dsema信号量的值大于<span class="number">0</span>，该函数所处线程就继续执行下面的语句，并且将信号量的值减<span class="number">1</span>；

如果desema的值为<span class="number">0</span>，那么这个函数就阻塞当前线程等待<span class="keyword">timeout</span>（注意<span class="keyword">timeout</span>的类型为dispatch_time_t，

不能直接传入整形或float型数），如果等待的期间desema的值被dispatch_semaphore_signal函数加<span class="number">1</span>了，

且该函数（即dispatch_semaphore_wait）所处线程获得了信号量，那么就继续向下执行并将信号量减<span class="number">1</span>。

如果等待期间没有获取到信号量或者信号量的值一直为<span class="number">0</span>，那么等到<span class="keyword">timeout</span>时，其所处线程自动执行其后语句。
</code></pre><p>关于信号量，这里有一个很形象的解释：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">停车场剩余<span class="number">4</span>个车位，那么即使同时来了四辆车也能停的下。如果此时来了五辆车，那么就有一辆需要等待。</span><br><span class="line">信号量的值就相当于剩余车位的数目，dispatch_semaphore_<span class="built_in">wait</span>函数就相当于来了一辆车，dispatch_semaphore_signal</span><br><span class="line">就相当于走了一辆车。停车位的剩余数目在初始化的时候就已经指明了（dispatch_semaphore_create（long value）），</span><br><span class="line">调用一次dispatch_semaphore_signal，剩余的车位就增加一个；调用一次dispatch_semaphore_<span class="built_in">wait</span>剩余车位就减少一个；</span><br><span class="line">当剩余车位为<span class="number">0</span>时，再来车（即调用dispatch_semaphore_<span class="built_in">wait</span>）就只能等待。有可能同时有几辆车等待一个停车位。有些车主</span><br><span class="line">没有耐心，给自己设定了一段等待时间，这段时间内等不到停车位就走了，如果等到了就开进去停车。而有些车主就像把车停在这，</span><br><span class="line">所以就一直等下去。</span><br></pre></td></tr></table></figure>
<p>本文到此就结束了</p>
<hr>
<p>参考：</p>
<p><a href="https://github.com/ChenYilong/ParseSourceCodeStudy/blob/master/01_Parse的多线程处理思路/Parse的底层多线程处理思路.md" target="_blank" rel="external">Parse源码浅析系列（一）—Parse的底层多线程处理思路：GCD高级用法</a></p>
<p><a href="http://www.cnblogs.com/snailHL/p/3906112.html" target="_blank" rel="external">关于dispatch_semaphore的使用</a></p>
<p><a href="http://tutuge.me/2015/04/03/something-about-gcd/#避免死锁！" target="_blank" rel="external">GCD使用经验与技巧浅谈</a></p>
<p><a href="http://blog.leichunfeng.com/blog/2015/07/29/ios-concurrency-programming-operation-queues/#jtss-tsina" target="_blank" rel="external">iOS 并发编程之 Operation Queues</a></p>
<p><a href="http://www.jianshu.com/p/0b0d9b1f1f19" target="_blank" rel="external">关于iOS多线程，你看我就够了</a></p>
<p><a href="http://www.jianshu.com/p/8ed06312d8bd" target="_blank" rel="external">小笨狼漫谈多线程：NSThread</a></p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2016/08/16/RegularExpression/" itemprop="url">
                iOS 正则表达式
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2016-08-16T21:59:49+08:00" content="2016-08-16">
            2016-08-16
          </time>
        </span>

        

        
          
        
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><h3 id="正则表达式">正则表达式</h3><h5 id="界定符">界定符</h5><p>表示一个正则表达式的开始和结束</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/[<span class="number">0</span>-<span class="number">9</span>]/</span><br></pre></td></tr></table></figure>
<p>在iOS中不加界定符</p>
<h5 id="原子">原子</h5><p>①可见原子<br><br>Unicode 编码表中用键盘输出后可见的字符</p>
<figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-<span class="ruby"> 标点；“<span class="number">_</span>?. 等等</span><br><span class="line"></span>-<span class="ruby"> 英文数字a-z,<span class="constant">A</span>-<span class="constant">Z</span>,<span class="number">0</span>-<span class="number">9</span></span><br><span class="line"></span>-<span class="ruby"> 数理化公式符号</span><br><span class="line"></span>-<span class="ruby"> 其他可见字符</span></span><br></pre></td></tr></table></figure>
<p>②不可见原子<br><br>Unicode 编码表中用键盘输出后不可见的字符</p>
<figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-<span class="ruby"> 换行符\n</span><br><span class="line"></span>-<span class="ruby"> 回车 \r</span><br><span class="line"></span>-<span class="ruby"> 制表符 \t</span><br><span class="line"></span>-<span class="ruby"> 空格</span><br><span class="line"></span>-<span class="ruby"> 其他不可见符号</span></span><br></pre></td></tr></table></figure>
<h5 id="元字符">元字符</h5><p>①原子的筛选方式</p>
<figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-<span class="ruby"> |   匹配两个或者多个分支选择</span><br><span class="line"></span>-<span class="ruby"> []  匹配方括号中的任意一个原子</span><br><span class="line"></span>-<span class="ruby"> [^] 匹配除方括号中的原子之外的任意字符</span></span><br></pre></td></tr></table></figure>
<p>②原子的集合</p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- .  匹配除换行符之外的任意字符</span><br><span class="line">- <span class="command">\d</span> 匹配任意一个十进制数字，即<span class="special">[</span>0-9<span class="special">]</span></span><br><span class="line">- <span class="command">\D</span> 匹配任意一个非十进制数字，即<span class="special">[</span>^0-9<span class="special">]</span></span><br><span class="line">- <span class="command">\s</span> 匹配一个不可见原子，即<span class="special">[</span><span class="command">\f</span><span class="command">\n</span><span class="command">\r</span><span class="command">\t</span><span class="command">\v</span><span class="special">]</span></span><br><span class="line">- <span class="command">\S</span> 匹配一个可见原子，即<span class="special">[</span>^<span class="command">\f</span><span class="command">\n</span><span class="command">\r</span><span class="command">\t</span><span class="command">\v</span><span class="special">]</span></span><br><span class="line">- <span class="command">\w</span> 匹配任意一个数字、字母或下划线，即<span class="special">[</span>0-9a-zA-Z_<span class="special">]</span></span><br><span class="line">- <span class="command">\W</span> 匹配任意一个非数字、字母或下划线，即<span class="special">[</span>^0-9a-zA-Z_<span class="special">]</span></span><br></pre></td></tr></table></figure>
<h5 id="量词">量词</h5><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-<span class="ruby"> &#123;n&#125;   表示其前面的原子恰好出现 n 次</span><br><span class="line"></span>-<span class="ruby"> &#123;n,&#125;  表示其前面的原子至少出现 n 次</span><br><span class="line"></span>-<span class="ruby"> &#123;n,m&#125; 表示其前面的原子恰好出现 n 次，最多出现m次</span><br><span class="line"></span>-<span class="ruby"> *     匹配<span class="number">0</span>次、<span class="number">1</span>次或者多次其之前的原子，即&#123;<span class="number">0</span>,&#125; </span><br><span class="line"></span>-<span class="ruby"> +     匹配一次或者多次其之前的原子，即&#123;<span class="number">1</span>,&#125;</span><br><span class="line"></span>-<span class="ruby"> ?     匹配<span class="number">0</span>次或者<span class="number">1</span>次其之前的原子，即&#123;<span class="number">0</span>,<span class="number">1</span>&#125;</span></span><br></pre></td></tr></table></figure>
<h5 id="边界控制与模式单元">边界控制与模式单元</h5><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-<span class="ruby"> ^  匹配字符串开始的位置</span><br><span class="line"></span>-<span class="ruby"> <span class="variable">$ </span> 匹配字符串结尾的位置</span><br><span class="line"></span>-<span class="ruby"> () 匹配其中的整体为一个原子</span></span><br></pre></td></tr></table></figure>
<h5 id="修正模式">修正模式</h5><p>常见的修正模式</p>
<figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-<span class="ruby"> <span class="constant">U</span> 懒惰匹配</span><br><span class="line"></span>-<span class="ruby"> i 忽略英文字母大小写</span><br><span class="line"></span>-<span class="ruby"> x 忽略空白</span><br><span class="line"></span>-<span class="ruby"> s 让元字符 <span class="string">` . `</span> 匹配包括换行符在内所有字符</span><br><span class="line"></span>-<span class="ruby"> e iOS 暂未知</span></span><br></pre></td></tr></table></figure>
<hr>
<p>好以上是正则的简单介绍，详细请看这个：<a href="http://www.jb51.net/tools/zhengze.html" target="_blank" rel="external">正则表达式30分钟入门教程</a></p>
<h3 id="iOS_正则表达式">iOS 正则表达式</h3><p>服务器每次返回的时间格式是这个样子的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2016</span>-<span class="number">08</span>-<span class="number">13</span>T13:<span class="number">06</span>:<span class="number">48</span>Z</span><br></pre></td></tr></table></figure>
<p>显示的时候只要年月日 或者是时分秒：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2016</span>-<span class="number">08</span>-<span class="number">13</span></span><br><span class="line"><span class="number">13</span>:<span class="number">06</span>:<span class="number">48</span></span><br></pre></td></tr></table></figure>
<p>这里常用的有两种方法<br></p>
<ol>
<li>使用 NSDateFormatter 格式化，来解析这时间格式的字符串，转换成 NSDate 格式，然后在格式化一次转换成相应的格式（这种方法感觉很蛋疼，折腾了两次）；<br></li>
<li>使用 NSString 分割方法:</li>
</ol>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">-</span> (<span class="tag">NSArray</span>&lt;<span class="tag">NSString</span> *&gt; *)<span class="rule"><span class="attribute">componentsSeparatedByString</span>:<span class="value">(NSString *)separator</span></span>;</span><br></pre></td></tr></table></figure>
<p>以 “T” 进行分割，最终得出自己想要的字符串；</p>
<hr>
<p>这两种方法是常用的方法，但是用起来总感觉不爽，后来想想还可以用 正则表达式，那就试试</p>
<h3 id="使用正则表达式来解析这个时间格式">使用正则表达式来解析这个时间格式</h3><p>在iOS中通常使用 “NSRegularExpression” 进行字符串匹配，一般是这个样子：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">     <span class="built_in">NSString</span> *string = <span class="string">@"字符串xxxx"</span>;</span><br><span class="line">     <span class="built_in">NSString</span> *regexString = <span class="string">@"正则表达式"</span>;</span><br><span class="line">     <span class="built_in">NSRegularExpression</span> *regex = [<span class="built_in">NSRegularExpression</span> regularExpressionWithPattern:regexString options:<span class="built_in">NSRegularExpressionCaseInsensitive</span> error:<span class="literal">nil</span>];</span><br><span class="line">     <span class="built_in">NSArray</span> *matches = [regex matchesInString:string options:<span class="built_in">NSMatchingReportProgress</span> range:<span class="built_in">NSMakeRange</span>(<span class="number">0</span>, string<span class="variable">.length</span>)];</span><br><span class="line">     <span class="keyword">for</span> (<span class="built_in">NSTextCheckingResult</span> *match <span class="keyword">in</span> matches) &#123;</span><br><span class="line"><span class="comment">// do something...</span></span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>下面我们来写这个正则来匹配出  年月日 和 时分秒。具体的正则写法请自行Google，不过我在这里介绍一个好网站<a href="https://regexper.com" target="_blank" rel="external">regexper</a>可以分析你写的正则表达式；匹配时间的正则我已经写好了：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^(\\d&#123;<span class="number">4</span>&#125;-\\d&#123;<span class="number">1</span>,<span class="number">2</span>&#125;-\\d&#123;<span class="number">1</span>,<span class="number">2</span>&#125;)T(\\d&#123;<span class="number">1</span>,<span class="number">2</span>&#125;:\\d&#123;<span class="number">1</span>,<span class="number">2</span>&#125;:\\d&#123;<span class="number">1</span>,<span class="number">2</span>&#125;)Z$</span><br></pre></td></tr></table></figure>
<p>在正则表达式中 有group之分，看上面的正则：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">group<span class="preprocessor">#<span class="number">1</span>:</span></span><br><span class="line">(\\d&#123;<span class="number">4</span>&#125;-\\d&#123;<span class="number">1</span>,<span class="number">2</span>&#125;-\\d&#123;<span class="number">1</span>,<span class="number">2</span>&#125;)</span><br><span class="line">group<span class="preprocessor">#<span class="number">2</span>:</span></span><br><span class="line">(\\d&#123;<span class="number">1</span>,<span class="number">2</span>&#125;:\\d&#123;<span class="number">1</span>,<span class="number">2</span>&#125;:\\d&#123;<span class="number">1</span>,<span class="number">2</span>&#125;)</span><br></pre></td></tr></table></figure>
<p>group#1 匹配的是年月日，group#2匹配的是时分秒，正则匹配之后，我们是可以分别取出这两个group匹配出来的值的；在iOS中“NSRegularExpression”类，也是有的；下面是匹配：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *string = <span class="string">@"2016-08-13T13:06:48Z"</span>;</span><br><span class="line"><span class="built_in">NSString</span> *regexString = <span class="string">@"^(\\d&#123;4&#125;-\\d&#123;1,2&#125;-\\d&#123;1,2&#125;)T(\\d&#123;1,2&#125;:\\d&#123;1,2&#125;:\\d&#123;1,2&#125;)Z$"</span>;</span><br><span class="line"><span class="built_in">NSRegularExpression</span> *regex = [<span class="built_in">NSRegularExpression</span> regularExpressionWithPattern:regexString options:<span class="built_in">NSRegularExpressionCaseInsensitive</span> error:<span class="literal">nil</span>];</span><br><span class="line"><span class="built_in">NSArray</span> *matches = [regex matchesInString:string options:<span class="built_in">NSMatchingReportProgress</span> range:<span class="built_in">NSMakeRange</span>(<span class="number">0</span>, string<span class="variable">.length</span>)];</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">NSTextCheckingResult</span> *match <span class="keyword">in</span> matches) &#123;</span><br><span class="line">    <span class="built_in">NSString</span>* group0 = [string substringWithRange:[match rangeAtIndex:<span class="number">0</span>]];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"group0 :%@"</span>, group0);</span><br><span class="line">    <span class="built_in">NSString</span>* group1 = [string substringWithRange:[match rangeAtIndex:<span class="number">1</span>]];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"group1 :%@"</span>, group1);</span><br><span class="line">    <span class="built_in">NSString</span>* group2 = [string substringWithRange:[match rangeAtIndex:<span class="number">2</span>]];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"group2 :%@"</span>, group2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用正则匹配出来之后，NSTextCheckingResult 中 使用 “[match rangeAtIndex:xxx]” 可以取出来。在这里NSTextCheckingResult 中 ：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">NSTextCheckingResult 类属性numberOfRanges 为<span class="number">3</span></span><br><span class="line">[match rangeAtIndex:<span class="number">0</span>] 匹配的是全量即：<span class="number">2016</span>-<span class="number">08</span>-<span class="number">13</span>T13:<span class="number">06</span>:<span class="number">48</span>Z</span><br><span class="line">[match rangeAtIndex:<span class="number">1</span>] 匹配的是：<span class="number">2016</span>-<span class="number">08</span>-<span class="number">13</span></span><br><span class="line">[match rangeAtIndex:<span class="number">2</span>] 匹配的是：<span class="number">13</span>:<span class="number">06</span>:<span class="number">48</span></span><br></pre></td></tr></table></figure>
<p>这下处理不就简单了许多。</p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2016/06/30/CATransition/" itemprop="url">
                CATransition 转场动画
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2016-06-30T07:39:42+08:00" content="2016-06-30">
            2016-06-30
          </time>
        </span>

        

        
          
        
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><h3 id="CATransition_转场动画">CATransition 转场动画</h3><p>转场动画就是从一个场景以动画的形式过渡到另一个场景，navigation的push就是一种转场方式（后面会介绍如何自定义）。<br>转场动画一般分为这几个步骤：<br>(1)初始化转场动画<br>(2)设置转场类型属性等<br>(3)设置转场后的新视图并添加动画到图层<br>下表列出了常用的转场类型(注意私有API是苹果官方没有公开的动画类型，但是目前通过仍然可以使用)：</p>
<h5 id="公开API">公开API</h5><table>
<thead>
<tr>
<th style="text-align:left">动画类型</th>
<th style="text-align:right">说明</th>
<th style="text-align:center">对应常量</th>
<th>是否支持方向设置</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">fade</td>
<td style="text-align:right">淡出效果</td>
<td style="text-align:center">kCATransitionFade</td>
<td>是</td>
</tr>
<tr>
<td style="text-align:left">movein</td>
<td style="text-align:right">新视图移动到旧视图上</td>
<td style="text-align:center">kCATransitionMoveIn</td>
<td>是</td>
</tr>
<tr>
<td style="text-align:left">push</td>
<td style="text-align:right">新视图推出旧视图</td>
<td style="text-align:center">kCATransitionPush</td>
<td>是</td>
</tr>
<tr>
<td style="text-align:left">reveal</td>
<td style="text-align:right">移开旧视图显示新视图</td>
<td style="text-align:center">kCATransitionReveal</td>
<td>是</td>
</tr>
</tbody>
</table>
<h5 id="私有API———-私有API只能通过字符串访问">私有API———-私有API只能通过字符串访问</h5><table>
<thead>
<tr>
<th style="text-align:left">动画类型</th>
<th style="text-align:right">说明</th>
<th style="text-align:center">对应常量</th>
<th>是否支持方向设置</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">cube</td>
<td style="text-align:right">立方体翻转效果</td>
<td style="text-align:center">无</td>
<td>是</td>
</tr>
<tr>
<td style="text-align:left">oglFlip</td>
<td style="text-align:right">翻转效果</td>
<td style="text-align:center">无</td>
<td>是</td>
</tr>
<tr>
<td style="text-align:left">suckEffect</td>
<td style="text-align:right">收缩效果</td>
<td style="text-align:center">无</td>
<td>否</td>
</tr>
<tr>
<td style="text-align:left">rippleEffect</td>
<td style="text-align:right">水滴波纹效果</td>
<td style="text-align:center">无</td>
<td>否</td>
</tr>
<tr>
<td style="text-align:left">pageCurl</td>
<td style="text-align:right">向上翻页效果</td>
<td style="text-align:center">无</td>
<td>是</td>
</tr>
<tr>
<td style="text-align:left">pageUnCurl</td>
<td style="text-align:right">向下翻页效果</td>
<td style="text-align:center">无</td>
<td>是</td>
</tr>
<tr>
<td style="text-align:left">cameralIrisHollowOpen</td>
<td style="text-align:right">摄像头打开效果</td>
<td style="text-align:center">无</td>
<td>否</td>
</tr>
<tr>
<td style="text-align:left">cameraIrisHollowClose</td>
<td style="text-align:right">摄像头关闭效果</td>
<td style="text-align:center">无</td>
<td>否</td>
</tr>
</tbody>
</table>
<h5 id="另外对于支持方向设置的动画类型还包含子类型">另外对于支持方向设置的动画类型还包含子类型</h5><table>
<thead>
<tr>
<th style="text-align:left">动画子类型</th>
<th style="text-align:right">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">kCATransitionFromRight</td>
<td style="text-align:right">从右侧转场</td>
</tr>
<tr>
<td style="text-align:left">kCATransitionFromLeft</td>
<td style="text-align:right">从左侧转场</td>
</tr>
<tr>
<td style="text-align:left">kCATransitionFromTop</td>
<td style="text-align:right">从顶部转场</td>
</tr>
<tr>
<td style="text-align:left">kCATransitionFromBottom</td>
<td style="text-align:right">从底部转场</td>
</tr>
</tbody>
</table>
<p>下面是一个小例子：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CATransition</span> *transition = [<span class="built_in">CATransition</span> animation];</span><br><span class="line">transition<span class="variable">.duration</span> = <span class="number">1.0</span>f;</span><br><span class="line">transition<span class="variable">.type</span> = <span class="string">@"cube"</span>;</span><br><span class="line"></span><br><span class="line">transition<span class="variable">.subtype</span> = k<span class="built_in">CATransitionFromRight</span>;</span><br><span class="line"><span class="built_in">UIView</span> *cubeView = [[<span class="built_in">UIView</span> alloc] initWithFrame:<span class="built_in">CGRectMake</span>(<span class="number">100</span>, <span class="number">100</span>, <span class="number">200</span>, <span class="number">300</span>)];</span><br><span class="line">cubeView<span class="variable">.backgroundColor</span> = [<span class="built_in">UIColor</span> cyanColor];</span><br><span class="line">[<span class="keyword">self</span><span class="variable">.view</span><span class="variable">.layer</span> addAnimation:transition forKey:<span class="string">@"cubeView"</span>];</span><br><span class="line">[<span class="keyword">self</span><span class="variable">.view</span> addSubview:cubeView];</span><br></pre></td></tr></table></figure>
<h4 id="感谢一下博客">感谢一下博客</h4><p><a href="http://www.cnblogs.com/kenshincui/p/3972100.html#autoid-3-3-0" target="_blank" rel="external">http://www.cnblogs.com/kenshincui/p/3972100.html#autoid-3-3-0</a></p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">&raquo;</a>
  </nav>

 </div>

        

        
      </div>

      
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      <section class="site-overview">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" src="/images/default_avatar.jpg" alt="Share" itemprop="image"/>
          <p class="site-author-name" itemprop="name">Share</p>
        </div>
        <p class="site-description motion-element" itemprop="description">just do it !</p>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">16</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          <div class="site-state-item site-state-categories">
            
              <span class="site-state-item-count">0</span>
              <span class="site-state-item-name">分类</span>
              
          </div>

          <div class="site-state-item site-state-tags">
            <a href="/tags">
              <span class="site-state-item-count">0</span>
              <span class="site-state-item-name">标签</span>
              </a>
          </div>

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        <div class="links-of-author motion-element">
          
        </div>

      </section>

      

    </div>
  </aside>


    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner"> <div class="copyright" >
  
  &copy; &nbsp;  2015 - 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="icon-next-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Share</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>


 </div>
    </footer>

    <div class="back-to-top"></div>
  </div>

  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  
  
    
    

  


  
  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script>
  <script type="text/javascript" src="/js/fancy-box.js?v=0.4.5.1"></script>


  <script type="text/javascript" src="/js/helpers.js?v=0.4.5.1"></script>
  

  <script type="text/javascript" src="/vendors/velocity/velocity.min.js"></script>
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js"></script>

  <script type="text/javascript" src="/js/motion_global.js?v=0.4.5.1" id="motion.global"></script>




  <script type="text/javascript" src="/js/nav-toggle.js?v=0.4.5.1"></script>
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  

  <script type="text/javascript">
    $(document).ready(function () {
      if (CONFIG.sidebar === 'always') {
        displaySidebar();
      }
      if (isMobile()) {
        FastClick.attach(document.body);
      }
    });
  </script>

  
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
      processEscapes: true,
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
  });
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for (i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>


  
  

  
  <script type="text/javascript" src="/js/lazyload.js"></script>
  <script type="text/javascript">
    $(function () {
      $("#posts").find('img').lazyload({
        placeholder: "/images/loading.gif",
        effect: "fadeIn"
      });
    });
  </script>
</body>
</html>
