<!doctype html>
<html class="theme-next use-motion theme-next-mist">
<head>
  

<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />








  <link rel="stylesheet" type="text/css" href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5"/>




<link rel="stylesheet" type="text/css" href="/css/main.css?v=0.4.5.1"/>


    <meta name="description" content="just do it !" />



  <meta name="keywords" content="Hexo,next" />





  <link rel="shorticon icon" type="image/x-icon" href="/favicon.ico?v=0.4.5.1" />


<meta name="description" content="just do it !">
<meta property="og:type" content="website">
<meta property="og:title" content="吾生也有涯，而知也无涯">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="吾生也有涯，而知也无涯">
<meta property="og:description" content="just do it !">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="吾生也有涯，而知也无涯">
<meta name="twitter:description" content="just do it !">


<script type="text/javascript" id="hexo.configuration">
  var CONFIG = {
    scheme: 'Mist',
    sidebar: 'post'
  };
</script>



  <title> 吾生也有涯，而知也无涯 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  <!--[if lte IE 8]>
  <div style=' clear: both; height: 59px; padding:0 0 0 15px; position: relative;margin:0 auto;'>
    <a href="http://windows.microsoft.com/en-US/internet-explorer/products/ie/home?ocid=ie6_countdown_bannercode">
      <img src="http://7u2nvr.com1.z0.glb.clouddn.com/picouterie.jpg" border="0" height="42" width="820"
           alt="You are using an outdated browser. For a faster, safer browsing experience, upgrade for free today or use other browser ,like chrome firefox safari."
           style='margin-left:auto;margin-right:auto;display: block;'/>
    </a>
  </div>
<![endif]-->
  






  <div class="container one-column 
   page-home 
">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><h1 class="site-meta">
  <span class="logo-line-before"><i></i></span>
  <a href="/" class="brand" rel="start">
      <span class="logo">
        <i class="icon-next-logo"></i>
      </span>
      <span class="site-title">吾生也有涯，而知也无涯</span>
  </a>
  <span class="logo-line-after"><i></i></span>
</h1>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu ">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            <i class="menu-item-icon icon-next-home"></i> <br />
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            <i class="menu-item-icon icon-next-archives"></i> <br />
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            <i class="menu-item-icon icon-next-tags"></i> <br />
            标签
          </a>
        </li>
      

      
      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div id="content" class="content"> 
  <section id="posts" class="posts-expand">
    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2017/07/02/Chris Lattner on the Realm WWDC 2017 Swift panel/" itemprop="url">
                Chris Lattner on the Realm WWDC 2017 Swift panel
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2017-07-02T22:28:11+08:00" content="2017-07-02">
            2017-07-02
          </time>
        </span>

        

        
          
        
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><p>Chris Lattner 做客 <a href="https://news.realm.io/news/wwdc-2017-swift-panel/" target="_blank" rel="external">Realm WWDC 2017 Swift panel</a>。这里是我觉得有趣的并将其简明扼要编辑下来的一些复述（这里我仅仅关注了Chris Lattner，但是其他的一些小组成员-Kamilah Taylor, Kevin Ballard, and Jesse Squires 也谈论了一些非常有趣的事情。如果你想要听的话，<a href="https://news.realm.io/news/wwdc-2017-swift-panel/" target="_blank" rel="external">点击这里</a>）。</p>
<h2 id="在辩论会上讨论开放_Swift_evolution_的开发过程_是否是一件好事">在辩论会上讨论开放 Swift evolution 的开发过程 是否是一件好事</h2><p>Chris Lattner：我认为这里面既有好又有坏。我想这种方式是非常好的（指开源），Swift团队确实从大家获得了很多有价值的反馈。但是有时很沮丧，在大家来来回回的争吵中明白什么是权衡设计优化。</p>
<p><code>很多的语言设计都权衡设计优化。这得益于有一个真正能提出不同异议的社区。</code></p>
<p>许多语言的设计都是关于权衡和平衡。没有一个人能提出一个多方位完美答案。你必须选择一些在某些方面很好但在其他方面不好的一点。这就是权衡利弊。除非大家真正能提出不同异议，否则你就做不到这些。这非常棒！</p>
<p>对我而言，令我沮丧的是，当核心团队出来时说，“我们不会谈论改变关键字”，但事实是疯狂的讨论是否改变关键字。这不是最有效的，但至少容易忽视。</p>
<h2 id="比较Swift_4版本与Swift_3版本">比较Swift 4版本与Swift 3版本</h2><p>Chris Lattner：Swift 3开始出现了一大堆的目标，但随着时间的流逝，这些目标被打折扣。<br>这是我的锅！<img src="http://pic.qqtn.com/file/2013/2015-5/2015050609100347328.jpg" alt="二哈"><br>管理软件很难，计划很难，然后开源，成千上万的人在项目的版本上下降中感觉没有任何的计划。嗯，确实没有什么计划！</p>
<p>Swift 3大约在一半左右，主要目标从ABI稳定性转变为源码稳定性。我认为这是最正确的事情。我们在Swift 3开发大约在一半左右的一段时间内意识到，随着社区的壮大，大家编写越来越多的代码，代码的不可破坏性变得非常重要。说Swift源码不稳定的原因之一是，在开放源代码发布之前，大家没有去大量的争论，讨论，争吵和主要的一些问题。你真的需要这样做，才能够更好。</p>
<h2 id="离开苹果">离开苹果</h2><p>Chris Lattner：一个积极的代码提交者转向Swift对我来说是一个艰难的决定。我还是非常喜欢Swift，对我来非常重要，这也是我为什么在这里和参与核心小组会议以及Swift的进展。</p>
<p>Swift团队真的很棒。我怎么会说这个没有听起来很奇怪？失去我并不是一个很大的损失，因为大家有像Doug Gregor，Joe Groff和John McCall以及无数的其他人。许多人不知道Ted的事情是，他已经经营很长时间了。所以在很多方面来说，就是理所当然的发生了。Ted是很多事情的策划者。所以，苹果的Swift团队非常的棒。我确定你们已经看到了，所以某种意义上已经不需要我了。</p>
<p>现在他们是一个伟大的团队，有许多伟大的人，发挥自己的才能，但现在是时候继续前进。</p>
<h2 id="Swift作为一个服务器开发语言">Swift作为一个服务器开发语言</h2><p>Chris Lattner：从技术角度来看，Swift提供很多功能。如果将它与Go，Node.js，Ruby，PHP等进行比较，那么它们在计算方面：Swift代码运行速度更快。如果构建云应用程序，那么你将为CPU利用率付费，您通常也会为内存利用率付费。Swift不但跑得快、表现好、低内存，还能为你省钱。</p>
<p>Java的运行速度也是非常快的的。这是一个超级成熟的生态系统，虚拟机真的很好。这不是关于Java使用CPU利用率的问题，更重要的是，一个类似的Swift应用程序通常会使用大约三或四倍的内存。这可能是一个重要的问题。</p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2017/03/05/insert-sort/" itemprop="url">
                排序算法之插入排序
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2017-03-05T22:28:11+08:00" content="2017-03-05">
            2017-03-05
          </time>
        </span>

        

        
          
        
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><h1 id="排序算法之插入排序">排序算法之插入排序</h1><p>从这周开始，每周我将写一些工作中常用的算法如下：</p>
<ol>
<li>冒泡排序和选择排序；</li>
<li>插入排序和希尔排序；</li>
<li>归并排序及其优化；</li>
<li>快速排序及其优化；</li>
<li>堆排序；</li>
</ol>
<p>下面开始正文：</p>
<h2 id="插入排序">插入排序</h2><p>关于插入排序的理论部分就不说了，去看<a href="https://zh.wikipedia.org/wiki/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F" target="_blank" rel="external">维基百科</a>，里面有各种语言的实现版本。咱们看图说话，容易理解。</p>
<p>待排数组如下：</p>
<p><img src="http://7xv4w8.com1.z0.glb.clouddn.com/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E5%88%9D%E5%A7%8B%E6%95%B0%E7%BB%84.png" alt="插入排序初始数组"></p>
<h3 id="第一步">第一步</h3><p>我们首先考虑 <code>8</code> 这个元素，只有 <code>8</code> 这一个元素，所以就排好序了。</p>
<p><img src="http://7xv4w8.com1.z0.glb.clouddn.com/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F01.png" alt="插入排序01"></p>
<h3 id="第二步">第二步</h3><p>我们来考虑 <code>6</code> 这个元素：</p>
<p><img src="http://7xv4w8.com1.z0.glb.clouddn.com/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F02.png" alt="插入排序02"></p>
<p>我们要把 <code>6</code> 放在其前面数组中合适的位置，和它前面的 <code>8</code> 相比 <code>6</code> 比 <code>8</code> 要小，所以 <code>6</code> 和 <code>8</code> 要互换位置：</p>
<p><img src="http://7xv4w8.com1.z0.glb.clouddn.com/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F03.png" alt="插入排序03"></p>
<p>此时前两个元素就排好的位置：</p>
<p><img src="http://7xv4w8.com1.z0.glb.clouddn.com/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F04.png" alt="插入排序04"></p>
<h3 id="第三步">第三步</h3><p>我们来考虑 <code>2</code> 这个元素：</p>
<p><img src="http://7xv4w8.com1.z0.glb.clouddn.com/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F05.png" alt="插入排序05"><br>我们把 <code>2</code> 和 <code>8</code> 比，<code>2</code> 比 <code>8</code> 小，所以互换位置：</p>
<p><img src="http://7xv4w8.com1.z0.glb.clouddn.com/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F06.png" alt="插入排序06"><br>然后，把 <code>2</code> 和 <code>6</code> 比，<code>2</code> 比 <code>6</code> 小，所以互换位置：</p>
<p><img src="http://7xv4w8.com1.z0.glb.clouddn.com/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F07.png" alt="插入排序07"></p>
<p>至此前三个元素就排好的位置：</p>
<p><img src="http://7xv4w8.com1.z0.glb.clouddn.com/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F08.png" alt="插入排序08"></p>
<h3 id="第四步">第四步</h3><p>我们来考虑 <code>3</code> 这个元素：</p>
<p><img src="http://7xv4w8.com1.z0.glb.clouddn.com/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F09.png" alt="插入排序09"><br>我们把 <code>3</code> 和 <code>8</code> 比，<code>3</code> 比 <code>8</code> 小，所以互换位置：</p>
<p><img src="http://7xv4w8.com1.z0.glb.clouddn.com/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F10.png" alt="插入排序10"></p>
<p>然后，把 <code>3</code> 和 <code>6</code> 比，<code>3</code> 比 <code>6</code> 小，所以互换位置：</p>
<p><img src="http://7xv4w8.com1.z0.glb.clouddn.com/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F11.png" alt="插入排序11"><br>然后，把 <code>3</code> 和 <code>2</code> 比，<code>3</code> 比 <code>2</code> 大，所以不互换位置。</p>
<p><img src="http://7xv4w8.com1.z0.glb.clouddn.com/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F11.png" alt="插入排序11"><br>至此前四个元素就排好的位置：</p>
<p><img src="http://7xv4w8.com1.z0.glb.clouddn.com/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F12.png" alt="插入排序12"><br>后面就不一一列举了，思路尽在 一二三四步骤中。</p>
<h2 id="写程序">写程序</h2><p>上面的思路理解了，下面的程序就比较好写了：</p>
<p><img src="http://7xv4w8.com1.z0.glb.clouddn.com/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F13.png" alt="插入排序13"><br>我们从数组的索引为 <code>1</code> 的位置开始，因为索引为 <code>0</code> 的位置已经排好序（假设数组长度为 <code>n</code>）即：</p>
<figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">1</span><span class="comment">; i &lt; n; i++) &#123;</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>大范围的确定好了，我们要进行小范围的比较排序了，那么 <code>1</code>位置的元素假设为第 <code>j</code> 位，要和之前的 位置 <code>j-1</code>位置的元素比较，如果大于不需要交换，否则需要交换：那么：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt; <span class="number">0</span>; j--) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr[j] &lt; arr[j - <span class="number">1</span>]) &#123;</span><br><span class="line">        swap(&amp;arr[j], &amp;arr[j-<span class="number">1</span>]);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>故完整的如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt; <span class="number">0</span>; j--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[j] &lt; arr[j - <span class="number">1</span>]) &#123;</span><br><span class="line">            swap(&amp;arr[j], &amp;arr[j-<span class="number">1</span>]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然，也可以这么写(嗯，更好看，装下逼也是可以的😜😜😜)：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt; <span class="number">0</span> &amp;&amp; (arr[j] &lt; arr[j - <span class="number">1</span>]); j--) &#123;</span><br><span class="line">            swap(&amp;arr[j], &amp;arr[j-<span class="number">1</span>]);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="测试">测试</h2><p>下面我们开始测试。测试用例呢 分为四种，分别为：</p>
<ol>
<li>有序</li>
<li>近乎有序</li>
<li>随机</li>
<li>倒叙</li>
</ol>
<p>我们测试10W个数据，测试它的排序时间，<a href="https://coding.net/u/xiaerfei/p/baseAlgorithm/git/blob/master/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/SortHelper.c" target="_blank" rel="external">测试用例的程序在这里</a>，测试代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n  = <span class="number">100000</span>;</span><br><span class="line"><span class="comment">// 有序</span></span><br><span class="line"><span class="keyword">int</span> *a = generateSequenceArray(n);</span><br><span class="line"><span class="comment">// 近乎有序</span></span><br><span class="line"><span class="keyword">int</span> *b = generateRandomSequenceArray(n, <span class="number">100</span>);</span><br><span class="line"><span class="comment">// 随机</span></span><br><span class="line"><span class="keyword">int</span> *c = generateRandomArray(n,<span class="number">0</span>,n);</span><br><span class="line"><span class="comment">// 倒叙</span></span><br><span class="line"><span class="keyword">int</span> *d = generateReverseArray(n);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *a1 = copyGenerateRandomArray(a, n);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *b1 = copyGenerateRandomArray(b, n);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *c1 = copyGenerateRandomArray(c, n);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *d1 = copyGenerateRandomArray(d, n);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"**************有序*************\n"</span>);</span><br><span class="line">testSort(<span class="string">"插入排序　　"</span>, insertSort,a1, n);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n**************近乎有序*************\n"</span>);</span><br><span class="line">testSort(<span class="string">"插入排序　　"</span>, insertSort,b1, n);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n**************随机*************\n"</span>);</span><br><span class="line">testSort(<span class="string">"插入排序　　"</span>, insertSort,c1, n);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n**************倒叙*************\n"</span>);</span><br><span class="line">testSort(<span class="string">"插入排序　　"</span>, insertSort,d1, n);</span><br><span class="line"></span><br><span class="line"><span class="built_in">free</span>(a);<span class="built_in">free</span>(a1);</span><br><span class="line"></span><br><span class="line"><span class="built_in">free</span>(b);<span class="built_in">free</span>(b1);</span><br><span class="line"></span><br><span class="line"><span class="built_in">free</span>(c);<span class="built_in">free</span>(c1);</span><br><span class="line"></span><br><span class="line"><span class="built_in">free</span>(d);<span class="built_in">free</span>(d1);</span><br></pre></td></tr></table></figure>
<p>运行之后的log（这里是在MacBook Pro上测试的结果，其它可能不是这个时间，但大底相同）：</p>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span>有序<span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line">sortname:插入排序　　	 sorttime: 0.000647s</span><br><span class="line"></span><br><span class="line"><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span>近乎有序<span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line">sortname:插入排序　　	 sorttime: 0.051551s</span><br><span class="line"></span><br><span class="line"><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span>随机<span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line">sortname:插入排序　　	 sorttime: 18.110468s</span><br><span class="line"></span><br><span class="line"><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span>倒叙<span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line">sortname:插入排序　　	 sorttime: 36.259288s</span><br></pre></td></tr></table></figure>
<p><strong>由此可以看出：插入排序对于近乎有序的数组用时很少，当数组随机或者是最坏情况，那就比较耗时。</strong></p>
<p>那，我们能不能改进呢？ 答案是可以的</p>
<h2 id="插入排序的优化">插入排序的优化</h2><p>在上面的看图说话中，某个元素要想找到自己的位置，则必须和之前的比较，完了之后可能要交换位置，如果说该元素是最小的，且是最后一个，那要交换 <code>n-1</code> 个了。我们知道 交换元素 是比较耗时的操作，那能不能不交换元素，也能找到它的合适的位置呢？方法还是的有的！采用赋值的方法</p>
<p>我们看第四步：</p>
<p><img src="http://7xv4w8.com1.z0.glb.clouddn.com/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F09.png" alt="插入排序09"><br>进行比较之后 <code>3 比 8 小</code>，我们在这里不进行交换，而是将 <code>3</code> 这个值记录下来为 <code>e = 3</code>,然后将 <code>8 元素值</code> 赋值到 <code>3</code> 的位置</p>
<p><img src="http://7xv4w8.com1.z0.glb.clouddn.com/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F14.png" alt="插入排序14"><br>然后将 <code>e = 3</code> 和 <code>元素 6</code> 比较，<code>3 比 6 小</code>，将 <code>元素 6</code> 赋值给其后一位：</p>
<p><img src="http://7xv4w8.com1.z0.glb.clouddn.com/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F15.png" alt="插入排序15"><br>然后将 <code>e = 3</code> 和 <code>元素 2</code> 比较，<code>3 比 2 大</code>，所以 <code>元素 3</code> 就找到了自己的位置：</p>
<p><img src="http://7xv4w8.com1.z0.glb.clouddn.com/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F16.png" alt="插入排序16"><br>看完图之后，这个思路是不是很清晰，下面的程序也是非常好写的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">int</span> e = arr[i];<span class="comment">//将该元素记录下来</span></span><br><span class="line">   <span class="keyword">int</span> j;</span><br><span class="line">   <span class="keyword">for</span> (j = i; j &gt; <span class="number">0</span> &amp;&amp; arr[j - <span class="number">1</span>] &gt; e; j--) &#123;</span><br><span class="line">       arr[j] = arr[j - <span class="number">1</span>];</span><br><span class="line">   &#125;</span><br><span class="line">   arr[j] = e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="插入排序优化测试">插入排序优化测试</h3><p>我们利用前面的测试方法，测试一下：</p>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span>有序<span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line">sortname:插入排序　　	 sorttime: 0.000647s</span><br><span class="line">sortname:插入排序优化	 sorttime: 0.000554s</span><br><span class="line"></span><br><span class="line"><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span>近乎有序<span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line">sortname:插入排序　　	 sorttime: 0.051551s</span><br><span class="line">sortname:插入排序优化	 sorttime: 0.025874s</span><br><span class="line"></span><br><span class="line"><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span>随机<span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line">sortname:插入排序　　	 sorttime: 18.110468s</span><br><span class="line">sortname:插入排序优化	 sorttime: 8.335453s</span><br><span class="line"></span><br><span class="line"><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span>倒叙<span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line">sortname:插入排序　　	 sorttime: 36.259288s</span><br><span class="line">sortname:插入排序优化	 sorttime: 16.780035s</span><br></pre></td></tr></table></figure>
<p>看看测试时间，这个优化还是有明显的提高的！！！</p>
<p>不知道这一节你掌握了么？😜😜😜</p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2017/03/05/bubble-sort/" itemprop="url">
                排序算法之冒泡排序和选择排序
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2017-03-05T22:28:11+08:00" content="2017-03-05">
            2017-03-05
          </time>
        </span>

        

        
          
        
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><p>从这周开始，每周我将写一些工作中常用的算法如下：</p>
<ol>
<li>冒泡排序和选择排序；</li>
<li>插入排序和希尔排序；</li>
<li>归并排序及其优化；</li>
<li>快速排序及其优化；</li>
<li>堆排序；</li>
</ol>
<p>下面开始正文：</p>
<h2 id="冒泡排序">冒泡排序</h2><p>冒泡排序可能是我们学习某种编程语言（大多数都是 C）之后，接触到的第一个排序算法。我在网上找了很多的博客之类的介绍冒泡排序的，但总是总是有点纰漏，比如 分析的和写的例子不一致（😂😂😂），很尴尬。下面我们详细来分析一下冒泡排序的过程：</p>
<p>待排序数组为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="number">6</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">9</span> &#125;</span><br></pre></td></tr></table></figure>
<p><strong>冒泡排序的原理是：<code>临近的``数字两两进行比较</code>,按照<code>从小到大</code>或者<code>从大到小</code>的顺序进行交换。</strong></p>
<p><strong>这里注意：是临近的两个数字两两进行比较，如果非，那就不是冒泡排序。</strong></p>
<p>起始数组如下：</p>
<p><img src="http://7xv4w8.com1.z0.glb.clouddn.com/%E5%86%92%E6%B3%A1-%E8%B5%B7%E5%A7%8B%E6%95%B0%E7%BB%84.png" alt="起始数组"></p>
<ol>
<li>第一趟排序</li>
</ol>
<p>第一次比较： <code>6 &gt; 2</code>  6 大于 2 进行交换，交换后：</p>
<p><img src="http://7xv4w8.com1.z0.glb.clouddn.com/%E5%86%92%E6%B3%A1-%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%AF%94%E8%BE%83.png" alt="00"></p>
<p>第二次比较： <code>6 &gt; 4</code>  6 大于 4 进行交换，交换后：</p>
<p><img src="http://7xv4w8.com1.z0.glb.clouddn.com/%E5%86%92%E6%B3%A1-%E7%AC%AC%E4%BA%8C%E6%AC%A1%E6%AF%94%E8%BE%83.png" alt=""></p>
<p>第三次比较： <code>6 &gt; 1</code>  6 大于 1 进行交换，交换后：</p>
<p><img src="http://7xv4w8.com1.z0.glb.clouddn.com/%E5%86%92%E6%B3%A1-%E7%AC%AC%E4%B8%89%E6%AC%A1%E6%AF%94%E8%BE%83.png" alt=""></p>
<p>第四次比较： <code>6 &gt; 5</code> 6 大于 5 进行交换，交换后：</p>
<p><img src="http://7xv4w8.com1.z0.glb.clouddn.com/%E5%86%92%E6%B3%A1-%E7%AC%AC%E5%9B%9B%E6%AC%A1%E6%AF%94%E8%BE%83.png" alt=""></p>
<p>第五次比较： <code>6 &lt; 9</code> 6 小于 9 不进行交换：</p>
<p><img src="http://7xv4w8.com1.z0.glb.clouddn.com/%E5%86%92%E6%B3%A1-%E7%AC%AC%E4%BA%94%E6%AC%A1%E6%AF%94%E8%BE%83.png" alt=""></p>
<p><strong>后面的第二、三、四、五、六的过程和上面的一样，最终如下面：</strong></p>
<p><img src="http://7xv4w8.com1.z0.glb.clouddn.com/%E5%86%92%E6%B3%A1-%E6%9C%80%E7%BB%88%E6%8E%92%E5%BA%8F.png" alt=""></p>
<p><strong>注意：第二次比较的时候，最后一位就不参与了，因为最大的已经冒了出来，第三次比较，倒数第二位不参与了，以此类推。</strong></p>
<p>至此，程序就很容易写出来了：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n ; i ++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n-i; j ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &lt; arr[j-<span class="number">1</span>]) &#123;</span><br><span class="line">                swap(&amp;arr[j], &amp;arr[j-<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="冒泡排序的优化">冒泡排序的优化</h2><p>我们看一下 每次排序的结果：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">第一次：<span class="number">2</span> <span class="number">4</span> <span class="number">1</span> <span class="number">5</span> <span class="number">6</span> <span class="number">9</span> </span><br><span class="line">第二次：<span class="number">2</span> <span class="number">1</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">9</span> </span><br><span class="line">第三次：<span class="number">1</span> <span class="number">2</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">9</span> </span><br><span class="line">第四次：<span class="number">1</span> <span class="number">2</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">9</span> </span><br><span class="line">第五次：<span class="number">1</span> <span class="number">2</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">9</span> </span><br><span class="line">第六次：<span class="number">1</span> <span class="number">2</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">9</span></span><br></pre></td></tr></table></figure>
<p>从中我们发现第三次的时候，已经排好序了，第四、五、六次没必要执行了，这就是我们要对冒泡排序进行优化的地方。</p>
<p>我们可以设置一个flag ，当没有发生交换的时候，记录一下，这时候数组已经有序了。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubbleSort2</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n &amp;&amp; flag ; i ++) &#123;</span><br><span class="line">        flag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n - i; j ++) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (arr[j] &lt; arr[j-<span class="number">1</span>]) &#123;</span><br><span class="line">                flag = <span class="number">1</span>;</span><br><span class="line">                swap(&amp;arr[j], &amp;arr[j-<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然，还有其他的优化方案，大家不妨搜下。</p>
<h2 id="选择排序">选择排序</h2><p>理解的前面的冒泡排序，选择排序是很容易理解的。选择排序顾名思义，每次循环要找出一个最小的值，然后再交换。</p>
<p>测试用例还是之前的：</p>
<p><img src="http://7xv4w8.com1.z0.glb.clouddn.com/%E5%86%92%E6%B3%A1-%E8%B5%B7%E5%A7%8B%E6%95%B0%E7%BB%84.png" alt="起始数组"></p>
<p>第一次大循环找到最小的值 <code>1</code> 然后和 <code>第0位</code>的交换，交换后：</p>
<p><img src="http://7xv4w8.com1.z0.glb.clouddn.com/%E9%80%89%E6%8B%A9-%E7%AC%AC%E4%B8%80%E6%AC%A1.png" alt=""></p>
<p>第二次大循环找到最小的值 <code>2</code> 然后和 <code>第1位</code>的交换，交换后：</p>
<p><img src="http://7xv4w8.com1.z0.glb.clouddn.com/%E9%80%89%E6%8B%A9-%E7%AC%AC%E4%B8%80%E6%AC%A1.png" alt=""></p>
<p>当然第三次大循环和第二次一样</p>
<p>第四次大循环找到最小的值 <code>5</code> 然后和 <code>第3位</code>的交换，交换后：</p>
<p><img src="http://7xv4w8.com1.z0.glb.clouddn.com/%E5%86%92%E6%B3%A1-%E6%9C%80%E7%BB%88%E6%8E%92%E5%BA%8F.png" alt=""><br>后面的就已经排序好了。</p>
<p><strong>从上面可以看出，选择排序是一个不断寻找最小值的排序方法。</strong></p>
<p>所以代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">selectSort</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> minIndex = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &lt; arr[minIndex]) &#123;</span><br><span class="line">                minIndex = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(&amp;arr[i], &amp;arr[minIndex]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>是不是很简单 😁😁😁！</p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2017/02/14/Multi-thread/" itemprop="url">
                iOS多线程
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2017-02-14T15:00:40+08:00" content="2017-02-14">
            2017-02-14
          </time>
        </span>

        

        
          
        
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><h2 id="iOS多线程">iOS多线程</h2><h3 id="前言">前言</h3><p>在这篇文章中我整理了iOS多线程开发需要的一些知识点、方法和事项。本文主要讲述三部分 NSThread、Operation 和 GCD。<br><br>本文不算是原创，是一些我觉得写的比较有质量文章的综合，文中摘抄了这些文章中的部分内容，在文中和文章末尾我已标注出处，之所以要摘抄是因为在需要之时，打开URL 是404 😂😂😂。我综合了这些文中给自己学习之用，也给大家方便查看之用，如有错误之处，见谅，不过欢迎指出。</p>
<h3 id="基本概念">基本概念</h3><p>我们先了解一线iOS多线程的一些基本概念(<a href="http://blog.leichunfeng.com/blog/2015/07/29/ios-concurrency-programming-operation-queues/#jtss-tsina" target="_blank" rel="external">这些基本概念参考了这里</a>)：</p>
<ul>
<li>进程（process）:指的是一个正在运行中的可执行文件。每一个进程都拥有独立的虚拟内存空间和系统资源，包括端口权限等，且至少包含一个主线程和任意数量的辅助线程（说白了就是：用于指代一个可执行程序，他可以包含多个线程）。另外，当一个进程的主线程退出时，这个进程就结束了；</li>
<li>线程（thread）:指的是一个独立的代码执行路径，也就是说线程是代码执行路径的最小分支。在 iOS 中，线程的底层实现是基于 <a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/Multithreading/Introduction/Introduction.html" target="_blank" rel="external">POSIX threads API</a> 的，也就是我们常说的 pthreads ；</li>
<li>任务（task），指的是我们需要执行的工作，是一个抽象的概念，用通俗的话说，就是一段代码。</li>
</ul>
<p><br></p>
<h4 id="串行_和_并发">串行 和 并发</h4><p>从本质上来说，串行和并发的主要区别在于允许同时执行的任务数量。</p>
<ul>
<li>串行：指的是一次只能执行一个任务，必须等一个任务执行完成后才能执行下一个任务；</li>
<li>并发：指的是允许多个任务在一段时间内同时执行。</li>
</ul>
<p><br></p>
<h4 id="同步_和_异步">同步 和 异步</h4><p>同步和异步操作的主要区别在于是否等待操作执行完成，亦即是否阻塞当前线程。</p>
<ul>
<li>同步操作：等待操作执行完成后再继续执行接下来的代码；</li>
<li>异步操作：它会在调用后立即返回，不会等待操作的执行结果。</li>
</ul>
<p><br></p>
<h4 id="队列_和_线程">队列 和 线程</h4><p>在 iOS 中，有两种不同类型的队列，分别是串行队列和并发队列。正如我们上面所说的，串行队列一次只能执行一个任务，而并发队列则可以允许多个任务同时执行。iOS 系统就是使用这些队列来进行任务调度的，它会根据调度任务的需要和系统当前的负载情况动态地创建和销毁线程，而不需要我们手动地管理</p>
<p><br></p>
<h4 id="iOS中的几种多线程类型">iOS中的几种多线程类型</h4><p>iOS 中其实目前有 4 种多线程，他们分别是：</p>
<ul>
<li>Pthreads：非常底层的东东；</li>
<li>NSThread：封装性最差，最偏向于底层，主要基于thread使用；</li>
<li>GCD：基于C的API，直接使用比较方便，主要基于task使用；</li>
<li>NSOperation &amp; NSOperationQueue：基于GCD封装的NSObject对象，对于复杂的多线程项目使用比较方便，主要基于队列使用。</li>
</ul>
<hr>
<p>下面开始介绍这几种类型<br><br></p>
<h3 id="Pthreads">Pthreads</h3><p>POSIX线程（POSIX threads），简称Pthreads，是线程的POSIX标准。该标准定义了创建和操纵线程的一整套API。在类Unix操作系统（Unix、Linux、Mac OS X等）中，都使用Pthreads作为操作系统的线程。<br><br>这个需要自己管理线程的生命周期，创建和销毁，写起来也是相当麻烦，若非是写一些非常底层的几乎是用不到的，这里暂时略过，如需要可自行去理解。<br><br></p>
<h3 id="NSThread">NSThread</h3><p>NSThread是苹果封装的，并且是面向对象的，这对我们来说就简便了许多，但是它的生命周期还是需要我们手动管理的；NSThread除Pthreads之外唯一一个基于线程封装的，每一个NSThread对象代表着一个线程。(<a href="http://www.jianshu.com/p/8ed06312d8bd" target="_blank" rel="external">这部分参考了这里</a>)<br><br></p>
<h4 id="线程的创建">线程的创建</h4><p>NSThread提供了2种创建线程的方法:</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="typename">void</span>)<span class="string">detachNewThreadSelector:</span>(SEL)selector <span class="string">toTarget:</span>(id)target <span class="string">withObject:</span>(nullable id)argument;</span><br><span class="line">- (instancetype)<span class="string">initWithTarget:</span>(id)target <span class="string">selector:</span>(SEL)selector <span class="string">object:</span>(nullable id)argument</span><br></pre></td></tr></table></figure>
<ul>
<li>detach方法直接创建并启动一个线程去Selector，由于没有返回值，如果需要获取新创建的Thread，需要在执行的Selector中调用-[NSThread currentThread]获取;</li>
<li>init方法初始化线程并返回，线程的入口函数由Selector传入。线程创建出来之后需要手动调用-start方法启动;<br><br><h4 id="线程操作">线程操作</h4>NSThread给线程提供的主要操作方法有启动，睡眠，取消，退出<br><br><h4 id="启动">启动</h4>使用init方法将线程创建出来之后，线程并不会立即运行，需要手动调用-start方法才会启动线程：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)<span class="function">start <span class="title">NS_AVAILABLE</span><span class="params">(<span class="number">10</span>_5, <span class="number">2</span>_0)</span></span>;</span><br></pre></td></tr></table></figure>
<p>在启动之前可以设置 线程的名称(当然启动后也可以在Selecter 中设置也可以)：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (nullable, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *name <span class="built_in">NS_AVAILABLE</span>(<span class="number">10</span>_5, <span class="number">2</span>_0);</span><br></pre></td></tr></table></figure>
<p>不过优先级 需要在 start 之前 设置，否则会无效：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@<span class="function">property NSQualityOfService qualityOfService <span class="title">NS_AVAILABLE</span><span class="params">(<span class="number">10</span>_10, <span class="number">8</span>_0)</span></span>;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h4 id="睡眠">睡眠</h4><p>NSThread提供了2个让线程睡眠的方法:</p>
<ul>
<li>根据NSDate传入睡眠时间；</li>
<li>直接传入NSTimeInterval</li>
</ul>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="tag">void</span>)<span class="rule"><span class="attribute">sleepUntilDate</span>:<span class="value">(NSDate *)date</span></span>;</span><br><span class="line">+ (<span class="tag">void</span>)<span class="rule"><span class="attribute">sleepForTimeInterval</span>:<span class="value">(NSTimeInterval)ti</span></span>;</span><br></pre></td></tr></table></figure>
<p>这里讲一下  sleepUntilDate:  和   runloop的runUntilDate: 上的一些区别：</p>
<ul>
<li>sleepUntilDate:相当于执行一个sleep的任务。在执行过程中，即使有其他任务传入runloop，runloop也不会立即响应，必须sleep任务完成之后，才会响应其他任务；</li>
<li>runUntilDate:虽然会阻塞线程，阻塞过程中并不妨碍新任务的执行。当有新任务的时候，会先执行接收到的新任务，新任务执行完之后，如果时间到了，再继续执行runUntilDate:之后的代码；</li>
</ul>
<p><br></p>
<h4 id="取消">取消</h4><p>NSThread提供了一个取消的方法和一个属性：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@property (readonly, getter=isCancelled) <span class="function">BOOL cancelled <span class="title">NS_AVAILABLE</span><span class="params">(<span class="number">10</span>_5, <span class="number">2</span>_0)</span></span>;</span><br><span class="line">- (<span class="keyword">void</span>)<span class="function">cancel <span class="title">NS_AVAILABLE</span><span class="params">(<span class="number">10</span>_5, <span class="number">2</span>_0)</span></span>;</span><br></pre></td></tr></table></figure>
<p>这里 cancel 方法要注意：调用-cancel方法并不会立刻取消线程，它仅仅是将cancelled属性设置为YES。cancelled也仅仅是一个用于记录状态的属性。线程取消的功能需要我们在main函数中自己实现；<br><br>要实现取消的功能，我们需要自己在线程的main函数中定期检查isCancelled状态来判断线程是否需要退出，当isCancelled为YES的时候，需要手动退出。<br></p>
<h4 id="退出">退出</h4><p>-exit函数可以让线程立即退出。<br><br>停止方法会立即终止除主线程以外所有线程（无论是否在执行任务）并退出，需要在掌控所有线程状态的情况下调用此方法，否则可能会导致内存问题。<br></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">void</span>)<span class="built_in">exit</span>;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h4 id="主线程和当前线程">主线程和当前线程</h4><p>NSThread提供了非常方便的获取和判断主线程的API：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@property (readonly) <span class="function">BOOL isMainThread <span class="title">NS_AVAILABLE</span><span class="params">(<span class="number">10</span>_5, <span class="number">2</span>_0)</span></span>;</span><br><span class="line">+ (BOOL)<span class="function">isMainThread <span class="title">NS_AVAILABLE</span><span class="params">(<span class="number">10</span>_5, <span class="number">2</span>_0)</span></span>; <span class="comment">// reports whether current thread is main</span></span><br><span class="line">+ (NSThread *)<span class="function">mainThread <span class="title">NS_AVAILABLE</span><span class="params">(<span class="number">10</span>_5, <span class="number">2</span>_0)</span></span>;</span><br></pre></td></tr></table></figure>
<p>获取当前线程：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">+ </span>(NSThread *)currentThread;</span><br></pre></td></tr></table></figure>
<p>是否为多线程：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ <span class="list">(<span class="keyword">BOOL</span>)</span>isMultiThreaded<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>关于isMultiThreaded 苹果在这里作了解释(相信你能看懂 😜😜😜)：</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Return</span> <span class="type">Value</span></span><br><span class="line"><span class="type">YES</span> <span class="keyword">if</span> the application <span class="keyword">is</span> multithreaded, <span class="type">NO</span> otherwise.</span><br><span class="line"></span><br><span class="line"><span class="type">Discussion</span></span><br><span class="line"><span class="type">An</span> application <span class="keyword">is</span> considered multithreaded <span class="keyword">if</span> a thread was ever detached <span class="keyword">from</span> the main thread <span class="keyword">using</span> either detachNewThreadSelector:toTarget:withObject: <span class="keyword">or</span> start. <span class="type">If</span> you detached a thread <span class="keyword">in</span> your application <span class="keyword">using</span> a non-<span class="type">Cocoa</span> <span class="type">API</span>, such <span class="keyword">as</span> the <span class="type">POSIX</span> <span class="keyword">or</span> <span class="type">Multiprocessing</span> <span class="type">Services</span> <span class="type">APIs</span>, this <span class="keyword">method</span> could still <span class="keyword">return</span> <span class="type">NO</span>. <span class="type">The</span> detached thread does <span class="keyword">not</span> have to be currently running <span class="keyword">for</span> the application to be considered multithreaded—this <span class="keyword">method</span> only indicates whether a single thread has been spawned.</span><br></pre></td></tr></table></figure>
<p><br></p>
<h4 id="线程优先级">线程优先级</h4><p>NSThread有4个优先级的API：</p>
<p>这两个用于设置和获取当前线程的优先级：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="tag">double</span>)<span class="tag">threadPriority</span>;</span><br><span class="line">+ (<span class="tag">BOOL</span>)<span class="rule"><span class="attribute">setThreadPriority</span>:<span class="value">(double)p</span></span>;</span><br></pre></td></tr></table></figure>
<p>后两个通过对象设置和获取优先级：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@<span class="function">property <span class="keyword">double</span> threadPriority <span class="title">NS_AVAILABLE</span><span class="params">(<span class="number">10</span>_6, <span class="number">4</span>_0)</span></span>; <span class="comment">// To be deprecated; use qualityOfService below</span></span><br><span class="line">@<span class="function">property NSQualityOfService qualityOfService <span class="title">NS_AVAILABLE</span><span class="params">(<span class="number">10</span>_10, <span class="number">8</span>_0)</span></span>; <span class="comment">// read-only after the thread is started</span></span><br></pre></td></tr></table></figure>
<p>在iOS 8 之前：</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">[NSThread setThreadPriority:1.0]</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>这个方法的优先级的数值设置让人困惑，因为你不知道你应该设置多大的值是比较合适的，因此在iOS8之后，threadPriority添加了一句注释：To be deprecated; use qualityOfService below <br><br>意为iOS 8以后推荐使用qualityOfService属性：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSInteger</span>, <span class="built_in">NSQualityOfService</span>) &#123;</span><br><span class="line">    <span class="built_in">NSQualityOfServiceUserInteractive</span> = <span class="number">0x21</span>, 最高优先级，用于用户交互事件</span><br><span class="line">    <span class="built_in">NSQualityOfServiceUserInitiated</span> = <span class="number">0x19</span>,   次高优先级，用于用户需要马上执行的事件</span><br><span class="line">    <span class="built_in">NSQualityOfServiceUtility</span> = <span class="number">0x11</span>,         普通优先级，用于普通任务       </span><br><span class="line">    <span class="built_in">NSQualityOfServiceBackground</span> = <span class="number">0x09</span>,      最低优先级，用于不重要的任务</span><br><span class="line">    <span class="built_in">NSQualityOfServiceDefault</span> = -<span class="number">1</span>            默认优先级，主线程和没有设置优先级的线程都默认为这个优先级</span><br><span class="line">&#125; <span class="built_in">NS_ENUM_AVAILABLE</span>(<span class="number">10</span>_10, <span class="number">8</span>_0);</span><br></pre></td></tr></table></figure>
<p>比如给线程设置次高优先级：</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">[newThread setQualityOfService:NSQualityOfServiceUserInitiated]</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p><br></p>
<h4 id="线程通讯">线程通讯</h4><p>创建线程之后，经常需要从主线程把耗时的任务丢给辅助线程，当任务完成之后辅助线程再把结果传回主线程传，这些线程通讯一般用的都是perform方法：</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)performSelectorOnMainThread:(<span class="type">SEL</span>)aSelector withObject:(nullable id)arg waitUntilDone:(<span class="type">BOOL</span>)wait modes:(nullable <span class="type">NSArray</span>&lt;<span class="type">NSString</span> *&gt; *)<span class="type">array</span>;</span><br><span class="line">- (<span class="type">void</span>)performSelectorOnMainThread:(<span class="type">SEL</span>)aSelector withObject:(nullable id)arg waitUntilDone:(<span class="type">BOOL</span>)wait;</span><br><span class="line">	// equivalent to the first <span class="keyword">method</span> <span class="keyword">with</span> kCFRunLoopCommonModes</span><br><span class="line">- (<span class="type">void</span>)performSelector:(<span class="type">SEL</span>)aSelector onThread:(<span class="type">NSThread</span> *)thr withObject:(nullable id)arg waitUntilDone:(<span class="type">BOOL</span>)wait modes:(nullable <span class="type">NSArray</span>&lt;<span class="type">NSString</span> *&gt; *)<span class="type">array</span> <span class="type">NS_AVAILABLE</span>(<span class="number">10_5</span>, <span class="number">2_0</span>);</span><br><span class="line">- (<span class="type">void</span>)performSelector:(<span class="type">SEL</span>)aSelector onThread:(<span class="type">NSThread</span> *)thr withObject:(nullable id)arg waitUntilDone:(<span class="type">BOOL</span>)wait <span class="type">NS_AVAILABLE</span>(<span class="number">10_5</span>, <span class="number">2_0</span>);</span><br><span class="line">	// equivalent to the first <span class="keyword">method</span> <span class="keyword">with</span> kCFRunLoopCommonModes</span><br></pre></td></tr></table></figure>
<p>①：将selector丢给主线程执行，可以指定runloop mode<br><br>②：将selector丢给主线程执行，runloop mode默认为common mode<br><br>③：将selector丢个指定线程执行，可以指定runloop mode<br><br>④：将selector丢个指定线程执行，runloop mode默认为default mode<br><br>一般用③④方法将任务丢给辅助线程，任务执行完成之后再使用①②方法将结果传回主线程<br><br>注意：perform方法只对拥有runloop的线程有效，如果创建的线程没有添加runloop，perform的selector将无法执行。<br><br><br></p>
<h4 id="线程通知">线程通知</h4><p>NSThread有三个线程相关的通知:</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FOUNDATION_EXPORT <span class="built_in">NSString</span> * <span class="keyword">const</span> <span class="built_in">NSWillBecomeMultiThreadedNotification</span>;</span><br><span class="line">FOUNDATION_EXPORT <span class="built_in">NSString</span> * <span class="keyword">const</span> <span class="built_in">NSDidBecomeSingleThreadedNotification</span>;</span><br><span class="line">FOUNDATION_EXPORT <span class="built_in">NSString</span> * <span class="keyword">const</span> <span class="built_in">NSThreadWillExitNotification</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>NSWillBecomeMultiThreadedNotification：由当前线程派生出第一个其他线程时发送；</li>
<li>NSDidBecomeSingleThreadedNotification：暂时不知道；</li>
<li>NSThreadWillExitNotification：线程退出时发送；</li>
</ul>
<p><br></p>
<h4 id="NSThread的简单使用">NSThread的简单使用</h4><p>NSThread 创建还是很简单的：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSThread</span> *thread = [[<span class="built_in">NSThread</span> alloc] initWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(threadAction) object:<span class="literal">nil</span>];</span><br><span class="line">thread<span class="variable">.name</span> = <span class="string">@"com.myCreate.www"</span>;</span><br><span class="line">[thread start];</span><br></pre></td></tr></table></figure>
<p>在线程启动之后会首先执行-threadAction，正常情况下threadAction方法执行结束之后，线程就会退出。为了线程可以长期复用接收消息，我们需要给线程加上runLoop</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)threadAction</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"当前线程：%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    <span class="built_in">NSRunLoop</span> *runLoop = [<span class="built_in">NSRunLoop</span> currentRunLoop];</span><br><span class="line">    [runLoop addPort:[<span class="built_in">NSMachPort</span> port] forMode:<span class="built_in">NSDefaultRunLoopMode</span>];</span><br><span class="line">    <span class="keyword">while</span> (![[<span class="built_in">NSThread</span> currentThread] isCancelled]) &#123;</span><br><span class="line">        [runLoop runMode:<span class="built_in">NSDefaultRunLoopMode</span> beforeDate:[<span class="built_in">NSDate</span> dateWithTimeIntervalSinceNow:<span class="number">10</span>]];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>自定义的线程默认是没有runloop的，调用-currentRunLoop，方法内部会为线程创建runloop；</li>
<li>如果没有数据源，runloop会在启动之后会立刻退出。所以需要给runloop添加一个数据源，这里添加的是NSPort数据源；</li>
<li>定期检查isCancelled，当外部调用-cancel方法将isCancelled置为YES的时候，线程可以退出；</li>
</ul>
<p><br></p>
<h4 id="结束线程">结束线程</h4><p>当我们想要结束线程的时候，我们可以使用CFRunLoopStop()配合-cancel来结束线程：</p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">[<span class="list">[<span class="keyword">NSThread</span> currentThread] cancel]<span class="comment">;</span></span><br><span class="line">CFRunLoopStop<span class="list">(<span class="keyword">CFRunLoopGetCurrent</span><span class="list">()</span>)</span><span class="comment">;</span></span></span></span><br></pre></td></tr></table></figure>
<p><br></p>
<h4 id="NSThread的一个小例子">NSThread的一个小例子</h4><p>这个例子很好的说明了NSThread使用时要注意些什么。<br><br>这个例子是：模拟售票<a href="http://www.jianshu.com/p/334bde6790be#" target="_blank" rel="external">这个例子来自这</a><br><br>情景：某演唱会门票发售，在广州和北京均开设窗口进行销售<br><br>下面是主要代码：新建两个线程<br></p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"***************售票开始****************"</span>);</span><br><span class="line"><span class="built_in">NSThread</span> *saleTicketsWindow_1 = [[<span class="built_in">NSThread</span> alloc] initWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(saleTicketsWindow_Action) object:<span class="literal">nil</span>];</span><br><span class="line">saleTicketsWindow_1<span class="variable">.name</span> = <span class="string">@"北京售票中心"</span>;</span><br><span class="line">[saleTicketsWindow_1 start];</span><br><span class="line">   </span><br><span class="line"><span class="built_in">NSThread</span> *saleTicketsWindow_2 = [[<span class="built_in">NSThread</span> alloc] initWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(saleTicketsWindow_Action) object:<span class="literal">nil</span>];</span><br><span class="line">saleTicketsWindow_2<span class="variable">.name</span> = <span class="string">@"广州售票中心"</span>;</span><br><span class="line">[saleTicketsWindow_2 start];</span><br></pre></td></tr></table></figure>
<p>开始执行售票<br></p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)saleTicketsWindow_Action</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (_ticketCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            _ticketCount --;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"剩余票数：%ld 窗口：%@"</span>, _ticketCount, [<span class="built_in">NSThread</span> currentThread]<span class="variable">.name</span>]);</span><br><span class="line">            [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">0.2</span>];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"***************售票完成****************"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">10</span> <span class="number">17</span>:<span class="number">54</span>:<span class="number">22.636</span> NSThreadTest[<span class="number">2323</span>:<span class="number">1382484</span>] 剩余票数：<span class="number">9</span> 窗口：广州售票中心</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">10</span> <span class="number">17</span>:<span class="number">54</span>:<span class="number">22.636</span> NSThreadTest[<span class="number">2323</span>:<span class="number">1382483</span>] 剩余票数：<span class="number">10</span> 窗口：北京售票中心</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">10</span> <span class="number">17</span>:<span class="number">54</span>:<span class="number">22.841</span> NSThreadTest[<span class="number">2323</span>:<span class="number">1382483</span>] 剩余票数：<span class="number">7</span> 窗口：北京售票中心</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">10</span> <span class="number">17</span>:<span class="number">54</span>:<span class="number">22.841</span> NSThreadTest[<span class="number">2323</span>:<span class="number">1382484</span>] 剩余票数：<span class="number">8</span> 窗口：广州售票中心</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">10</span> <span class="number">17</span>:<span class="number">54</span>:<span class="number">23.043</span> NSThreadTest[<span class="number">2323</span>:<span class="number">1382484</span>] 剩余票数：<span class="number">5</span> 窗口：广州售票中心</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">10</span> <span class="number">17</span>:<span class="number">54</span>:<span class="number">23.043</span> NSThreadTest[<span class="number">2323</span>:<span class="number">1382483</span>] 剩余票数：<span class="number">6</span> 窗口：北京售票中心</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">10</span> <span class="number">17</span>:<span class="number">54</span>:<span class="number">23.244</span> NSThreadTest[<span class="number">2323</span>:<span class="number">1382484</span>] 剩余票数：<span class="number">4</span> 窗口：广州售票中心</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">10</span> <span class="number">17</span>:<span class="number">54</span>:<span class="number">23.244</span> NSThreadTest[<span class="number">2323</span>:<span class="number">1382483</span>] 剩余票数：<span class="number">3</span> 窗口：北京售票中心</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">10</span> <span class="number">17</span>:<span class="number">54</span>:<span class="number">23.449</span> NSThreadTest[<span class="number">2323</span>:<span class="number">1382483</span>] 剩余票数：<span class="number">1</span> 窗口：北京售票中心</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">10</span> <span class="number">17</span>:<span class="number">54</span>:<span class="number">23.449</span> NSThreadTest[<span class="number">2323</span>:<span class="number">1382484</span>] 剩余票数：<span class="number">2</span> 窗口：广州售票中心</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">10</span> <span class="number">17</span>:<span class="number">54</span>:<span class="number">23.655</span> NSThreadTest[<span class="number">2323</span>:<span class="number">1382483</span>] 剩余票数：<span class="number">0</span> 窗口：北京售票中心</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">10</span> <span class="number">17</span>:<span class="number">54</span>:<span class="number">23.655</span> NSThreadTest[<span class="number">2323</span>:<span class="number">1382484</span>] ***************售票完成****************</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">10</span> <span class="number">17</span>:<span class="number">54</span>:<span class="number">23.656</span> NSThreadTest[<span class="number">2323</span>:<span class="number">1382484</span>] 线程退出了：广州售票中心</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">10</span> <span class="number">17</span>:<span class="number">54</span>:<span class="number">23.861</span> NSThreadTest[<span class="number">2323</span>:<span class="number">1382483</span>] ***************售票完成****************</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">10</span> <span class="number">17</span>:<span class="number">54</span>:<span class="number">23.861</span> NSThreadTest[<span class="number">2323</span>:<span class="number">1382483</span>] 线程退出了：北京售票中心</span><br></pre></td></tr></table></figure>
<p>可以看到，票的销售过程中出现了剩余数量错乱的情况，这就是线程同步问题。<br><br>售票是一个典型的需要线程同步的场景，由于售票渠道有很多，而票的资源是有限的，当多个渠道在短时间内卖出大量的票的时候，如果没有同步机制来管理票的数量，将会导致票的总数和售出票数对应不上的错误。<br></p>
<p>iOS实现线程加锁有几种方式，现在使用NSLock或@synchronized两种方式都可行<br></p>
<p>使用NSLock:<br></p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    [_lock lock];</span><br><span class="line">    <span class="keyword">if</span> (_ticketCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        _ticketCount --;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"剩余票数：%ld 窗口：%@"</span>, _ticketCount, [<span class="built_in">NSThread</span> currentThread]<span class="variable">.name</span>]);</span><br><span class="line">        [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">0.2</span>];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"***************售票完成****************"</span>);</span><br><span class="line">        [_lock unlock];</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    [_lock unlock];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用@synchronized:<br></p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">@synchronized</span>(<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (_ticketCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            _ticketCount --;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"剩余票数：%ld 窗口：%@"</span>, _ticketCount, [<span class="built_in">NSThread</span> currentThread]<span class="variable">.name</span>]);</span><br><span class="line">            [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">0.2</span>];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"***************售票完成****************"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="NSOperation">NSOperation</h3><p>NSOperation 只是一个抽象类，所以不能封装任务，因此，如果我们想要使用它来执行具体任务的话，就必须创建自己的子类或使用它的 2 个子类。分别是：NSInvocationOperation 和 NSBlockOperation 。创建一个 Operation 后，需要调用 start 方法来启动任务，它会 默认在当前队列同步执行。当然你也可以在中途取消一个任务，只需要调用其 cancel 方法即可。</p>
<h4 id="NSInvocationOperation">NSInvocationOperation</h4><p>下面是NSInvocationOperation的简单使用，可以看到 NSInvocationOperation 开始任务之后是在主线程执行任务的。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.创建对象</span></span><br><span class="line"><span class="built_in">NSInvocationOperation</span> *operation = [[<span class="built_in">NSInvocationOperation</span> alloc] initWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(invocationAction) object:<span class="literal">nil</span>];</span><br><span class="line"><span class="comment">//2.开始执行</span></span><br><span class="line">[operation start];</span><br><span class="line"><span class="comment">//3.结果</span></span><br><span class="line"><span class="comment">/*</span><br><span class="line"> 2016-05-06 05:53:43.219 NSOperationTest[5885:2491863] NSInvocationOperation --- &lt;NSThread: 0x7fa269c06dc0&gt;&#123;number = 1, name = main&#125;</span><br><span class="line"> 是在主线程</span><br><span class="line"> */</span></span><br></pre></td></tr></table></figure>
<h4 id="NSBlockOperation">NSBlockOperation</h4><p>NSBlockOperation 默认会在当前线程执行任务。但是 NSBlockOperation 还有一个方法：addExecutionBlock: ，通过这个方法可以给 Operation 添加多个执行 Block。这样 Operation 中的任务 会并发执行，它会 在主线程和其它的多个线程执行这些任务.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">NSBlockOperation *blockOperation = [NSBlockOperation blockOperationWithBlock:^&#123;</span><br><span class="line">    NSLog(@<span class="string">"NSBlockOperation --- %@"</span>, [NSThread currentThread]);</span><br><span class="line">&#125;];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    [blockOperation addExecutionBlock:^&#123;</span><br><span class="line">        NSLog(@<span class="string">"NSBlockOperation 第%d次：%@"</span>, i, [NSThread currentThread]);</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br><span class="line">[blockOperation start];</span><br><span class="line"></span><br><span class="line"> <span class="number">2016</span>-<span class="number">05</span>-<span class="number">06</span> <span class="number">05</span>:<span class="number">57</span>:<span class="number">46.227</span> NSBlockOperationTest[<span class="number">5921</span>:<span class="number">2510961</span>] NSBlockOperation --- &lt;NSThread: <span class="number">0x7fc4c0401af0</span>&gt;&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line"> </span><br><span class="line"> <span class="number">2016</span>-<span class="number">05</span>-<span class="number">06</span> <span class="number">06</span>:<span class="number">01</span>:<span class="number">25.939</span> NSBlockOperationTest[<span class="number">5939</span>:<span class="number">2525676</span>] NSBlockOperation 第<span class="number">2</span>次：&lt;NSThread: <span class="number">0x7fb6cbe04590</span>&gt;&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line"> <span class="number">2016</span>-<span class="number">05</span>-<span class="number">06</span> <span class="number">06</span>:<span class="number">01</span>:<span class="number">25.940</span> NSBlockOperationTest[<span class="number">5939</span>:<span class="number">2525676</span>] NSBlockOperation 第<span class="number">3</span>次：&lt;NSThread: <span class="number">0x7fb6cbe04590</span>&gt;&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line"> <span class="number">2016</span>-<span class="number">05</span>-<span class="number">06</span> <span class="number">06</span>:<span class="number">01</span>:<span class="number">25.940</span> NSBlockOperationTest[<span class="number">5939</span>:<span class="number">2525676</span>] NSBlockOperation 第<span class="number">4</span>次：&lt;NSThread: <span class="number">0x7fb6cbe04590</span>&gt;&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line"> <span class="number">2016</span>-<span class="number">05</span>-<span class="number">06</span> <span class="number">06</span>:<span class="number">01</span>:<span class="number">25.940</span> NSBlockOperationTest[<span class="number">5939</span>:<span class="number">2525717</span>] NSBlockOperation 第<span class="number">0</span>次：&lt;NSThread: <span class="number">0x7fb6cbf03040</span>&gt;&#123;number = <span class="number">2</span>, name = (null)&#125;</span><br><span class="line"> <span class="number">2016</span>-<span class="number">05</span>-<span class="number">06</span> <span class="number">06</span>:<span class="number">01</span>:<span class="number">25.940</span> NSBlockOperationTest[<span class="number">5939</span>:<span class="number">2525710</span>] NSBlockOperation 第<span class="number">1</span>次：&lt;NSThread: <span class="number">0x7fb6cbc3f6e0</span>&gt;&#123;number = <span class="number">3</span>, name = (null)&#125;</span><br></pre></td></tr></table></figure>
<p>注意：addExecutionBlock 方法必须在 start() 方法之前执行，否则就会报错：</p>
<figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Terminating app due <span class="keyword">to</span> uncaught exception <span class="attribute">'NSInvalidArgumentException</span>', reason: '*** -[NSBlockOperation addExecutionBlock:]: blocks cannot be added <span class="keyword">after</span> the operation has started executing <span class="keyword">or</span> finished'</span><br></pre></td></tr></table></figure>
<h4 id="NSOperationQueue">NSOperationQueue</h4><p>在 NSOperationQueue 中，任务不会在当前线程执行。当任务添加到队列，会自动调用任务的 start() 方法，所有任务是并行执行的。maxConcurrentOperationCount 可以设置最大任务并行数量，当设置为 1 时，在某种意义上就是串行了。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">    <span class="built_in">NSOperationQueue</span> *queue = [[<span class="built_in">NSOperationQueue</span> alloc] init];</span><br><span class="line">    <span class="built_in">NSBlockOperation</span> *blockOperation = [<span class="built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"NSBlockOperation --- %@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    &#125;];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        [blockOperation addExecutionBlock:^&#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"NSBlockOperation 第%d次：%@"</span>, i, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;</span><br><span class="line">    [queue addOperation:blockOperation];</span><br><span class="line">或者是：</span><br><span class="line">       [queue addOperationWithBlock:^&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"addOperationWithBlock 第%d次：%@"</span>, i, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">        &#125;</span><br><span class="line">        [[<span class="built_in">NSOperationQueue</span> mainQueue] addOperationWithBlock:^&#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"addOperationWithBlock %@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;];</span><br></pre></td></tr></table></figure>
<p>eg:NSOperation 有一个非常实用的功能，那就是添加依赖。比如有 3 个任务：A: 从服务器上下载一张图片，B：给这张图片加个水印，C：把图片返回给服务器。这时就可以用到依赖了:</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSBlockOperation</span> *operation1 = [<span class="built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class="line">       <span class="built_in">NSLog</span>(<span class="string">@"下载图片 --- %@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">   &#125;];</span><br><span class="line">   <span class="built_in">NSBlockOperation</span> *operation2 = [<span class="built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class="line">       <span class="built_in">NSLog</span>(<span class="string">@"打水印 --- %@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">   &#125;];</span><br><span class="line">   <span class="built_in">NSBlockOperation</span> *operation3 = [<span class="built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class="line">       <span class="built_in">NSLog</span>(<span class="string">@"上传图片 --- %@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">   &#125;];</span><br><span class="line">   [operation2 addDependency:operation1];</span><br><span class="line">   [operation3 addDependency:operation2];</span><br><span class="line">   <span class="built_in">NSOperationQueue</span> *operationQueue = [[<span class="built_in">NSOperationQueue</span> alloc] init];</span><br><span class="line">   [operationQueue addOperations:@[operation1,operation2,operation3] waitUntilFinished:<span class="literal">NO</span>];</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2016</span>-<span class="number">05</span>-<span class="number">06</span> <span class="number">06</span>:<span class="number">26</span>:<span class="number">12.732</span> NSOperationQueueTest[<span class="number">6061</span>:<span class="number">2650250</span>] 下载图片 --- &lt;NSThread: <span class="number">0x7fc589e1d740</span>&gt;&#123;number = <span class="number">3</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">05</span>-<span class="number">06</span> <span class="number">06</span>:<span class="number">26</span>:<span class="number">12.733</span> NSOperationQueueTest[<span class="number">6061</span>:<span class="number">2650257</span>] 打水印 --- &lt;NSThread: <span class="number">0x7fc589f01320</span>&gt;&#123;number = <span class="number">4</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">05</span>-<span class="number">06</span> <span class="number">06</span>:<span class="number">26</span>:<span class="number">12.734</span> NSOperationQueueTest[<span class="number">6061</span>:<span class="number">2650257</span>] 上传图片 --- &lt;NSThread: <span class="number">0x7fc589f01320</span>&gt;&#123;number = <span class="number">4</span>, name = (null)&#125;</span><br></pre></td></tr></table></figure>
<p>注意：不能添加相互依赖，会死锁，比如 A依赖B，B依赖A。<br><br>     可以使用 removeDependency 来解除依赖关系。<br><br>     可以在不同的队列之间依赖，反正就是这个依赖是添加到任务身上的，和队列没关系。<br></p>
<p>另外还有以下方法：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSOperation</span></span><br><span class="line"><span class="built_in">BOOL</span> executing; <span class="comment">//判断任务是否正在执行</span></span><br><span class="line"><span class="built_in">BOOL</span> finished; <span class="comment">//判断任务是否完成</span></span><br><span class="line"><span class="keyword">void</span> (^completionBlock)(<span class="keyword">void</span>); <span class="comment">//用来设置完成后需要执行的操作</span></span><br><span class="line">- (<span class="keyword">void</span>)cancel; <span class="comment">//取消任务</span></span><br><span class="line">- (<span class="keyword">void</span>)waitUntilFinished; <span class="comment">//阻塞当前线程直到此任务执行完毕</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">NSOperationQueue</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">NSUInteger</span> operationCount; <span class="comment">//获取队列的任务数</span></span><br><span class="line">- (<span class="keyword">void</span>)cancelAllOperations; <span class="comment">//取消队列中所有的任务</span></span><br><span class="line">- (<span class="keyword">void</span>)waitUntilAllOperationsAreFinished; <span class="comment">//阻塞当前线程直到此队列中的所有任务执行完毕</span></span><br><span class="line">[queue setSuspended:<span class="literal">YES</span>]; <span class="comment">// 暂停queue</span></span><br><span class="line">[queue setSuspended:<span class="literal">NO</span>]; <span class="comment">// 继续queue</span></span><br></pre></td></tr></table></figure>
<p>关于NSOperationQueue中 ：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@property (nullable, assign <span class="comment">/* actually retain */</span>) <span class="keyword">dispatch_queue_t</span> <span class="function">underlyingQueue <span class="title">NS_AVAILABLE</span><span class="params">(<span class="number">10</span>_10, <span class="number">8</span>_0)</span></span>;</span><br></pre></td></tr></table></figure>
<p><a href="http://stackoverflow.com/questions/16563410/get-underlying-dispatch-queue-t-from-nsoperationqueue" target="_blank" rel="external">在这里有介绍其用法</a><br><br><a href="http://stackoverflow.com/questions/31062196/can-nsoperation-have-a-lower-qualityofservice-than-nsoperationqueue/31076475#31076475" target="_blank" rel="external">这里也有解释</a><br><br>这里是苹果的解释：</p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Discussion</span><br><span class="line">The default <span class="built_in">value</span> <span class="operator">of</span> this property is nil. You can <span class="built_in">set</span> <span class="operator">the</span> <span class="built_in">value</span> <span class="operator">of</span> this property <span class="built_in">to</span> <span class="operator">an</span> existing <span class="built_in">dispatch</span> queue <span class="built_in">to</span> have enqueued operations interspersed <span class="operator">with</span> blocks submitted <span class="built_in">to</span> that <span class="built_in">dispatch</span> queue.</span><br><span class="line"></span><br><span class="line">The <span class="built_in">value</span> <span class="operator">of</span> this property should only be <span class="built_in">set</span> <span class="keyword">if</span> there are no operations <span class="operator">in</span> <span class="operator">the</span> queue; setting <span class="operator">the</span> <span class="built_in">value</span> <span class="operator">of</span> this property when operationCount is <span class="operator">not</span> equal <span class="built_in">to</span> <span class="number">0</span> raises <span class="operator">an</span> invalidArgumentException. The <span class="built_in">value</span> <span class="operator">of</span> this property must <span class="operator">not</span> be <span class="operator">the</span> <span class="built_in">value</span> returned <span class="keyword">by</span> dispatch_get_main_queue(). The quality-<span class="operator">of</span>-service level <span class="built_in">set</span> <span class="keyword">for</span> <span class="operator">the</span> underlying <span class="built_in">dispatch</span> queue overrides <span class="keyword">any</span> <span class="built_in">value</span> <span class="built_in">set</span> <span class="keyword">for</span> <span class="operator">the</span> operation queue<span class="string">'s qualityOfService property.</span></span><br></pre></td></tr></table></figure>
<h4 id="自定义Operation">自定义Operation</h4><p>后面会有专门有一节介绍</p>
<hr>
<h3 id="GCD">GCD</h3><p>Grand Central Dispatch 是苹果为多核的并行运算提出的解决方案，所以会自动合理地利用更多的CPU内核（比如双核、四核），最重要的是它会自动管理线程的生命周期（创建线程、调度任务、销毁线程），完全不需要我们管理，我们只需要告诉干什么就行。</p>
<p>在 GCD 中，加入了两个非常重要的概念： 任务 和 队列。 任务即你要执行的，同步、异步和队列 前面已经讲解过。<br></p>
<pre><code>放到串行队列的任务，<span class="keyword">GCD</span> 会 FIFO（先进先出） 地取出来一个，执行一个，然后取下一个，这样一个一个的执行。&lt;br/&gt;

放到并行队列的任务，<span class="keyword">GCD</span> 也会 FIFO的取出来，但不同的是，它取出来一个就会放到别的线程，然后再取出来一个又放到另一个的线程。这样由于取的动作很快，忽略不计，看起来，所有的任务都是一起执行的。不过需要注意，<span class="keyword">GCD</span> 会根据系统资源控制并行的数量，所以如果任务很多，它并不会让所有任务同时执行。&lt;br/&gt;
</code></pre><h4 id="创建队列">创建队列</h4><p>先讲概念：</p>
<p>GCD中的FIFO队列称为dispatch queue，用来保证先进来的任务先得到执行。</p>
<p> dispatch queue分三种</p>
<ul>
<li>Serial：又叫private dispatch queues，同时只执行一个任务。Serial queue常用于同步访问特定的资源或数据。当你创建多个Serial queue时，虽然各自是同步，但serial queue之间是并发执行。(DISPATCH_QUEUE_SERIAL)</li>
<li>Concurrent：又叫global dispatch queue，可以并发的执行多个任务，但执行完成顺序是随机的。(DISPATCH_QUEUE_CONCURRENT)</li>
<li>Main dispatch queue：全局可用的serial queue，在应用程序主线程上执行任务。</li>
</ul>
<p>公开的5个不同队列：<br> 运行在主线程中的main queue，<br> 3个不同优先级的后台队列（High Priority Queue，Default Priority Queue，Low Priority Queue），<br> 以及一个优先级更低的后台队列Background Priority Queue（用于I/O）</p>
<p> 5种队列，主队列（main queue）,四种通用调度队列，自己定制的队列。四种通用调度队列为</p>
<ul>
<li>QOS_CLASS_USER_INTERACTIVE：user interactive等级表示任务需要被立即执行提供好的体验，用来更新UI，响应事件等。这个等级最好保持小规模。</li>
<li>QOS_CLASS_USER_INITIATED：  user initiated等级表示任务由UI发起异步执行。适用场景是需要及时结果同时又可以继续交互的时候。</li>
<li>QOS_CLASS_UTILITY：         utility等级表示需要长时间运行的任务，伴有用户可见进度指示器。经常会用来做计算，I/O，网络，持续的数据填充等任务。这个任务节能。</li>
<li>QOS_CLASS_BACKGROUND：      background等级表示用户不会察觉的任务，使用它来处理预加载，或者不需要用户交互和对时间不敏感的任务。</li>
</ul>
<h5 id="主队列">主队列</h5><p>这是一个特殊的 串行队列,它用于刷新 UI，任何需要刷新 UI 的工作都要在主队列执行.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dispatch_queue_t</span> <span class="built_in">queue</span> = dispatch_get_main_queue();</span><br></pre></td></tr></table></figure>
<h5 id="自定义的队列">自定义的队列</h5><p>其中第一个参数是标识符，用于 DEBUG 的时候标识唯一的队列，可以为空.</p>
<p>第二个参数用来表示创建的队列是串行的还是并行的，传入 DISPATCH_QUEUE_SERIAL 或 NULL 表示创建串行队列。传入 DISPATCH_QUEUE_CONCURRENT 表示创建并行队列。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dispatch_queue_t</span></span><br><span class="line">dispatch_queue_create(<span class="keyword">const</span> <span class="keyword">char</span> *_Nullable label,</span><br><span class="line">		<span class="keyword">dispatch_queue_attr_t</span> _Nullable attr);</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 串行队列</span></span><br><span class="line"><span class="keyword">dispatch_queue_t</span> createQueue = dispatch_queue_create(<span class="string">"com.testQueue"</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">dispatch_queue_t</span> createQueue = dispatch_queue_create(<span class="string">"com.testQueue"</span>, DISPATCH_QUEUE_SERIAL);</span><br><span class="line"><span class="comment">// 并行队列</span></span><br><span class="line"><span class="keyword">dispatch_queue_t</span> createQueue = dispatch_queue_create(<span class="string">"com.testQueue"</span>, DISPATCH_QUEUE_CONCURRENT);</span><br></pre></td></tr></table></figure>
<p>系统还提供了 全局并行队列</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dispatch_queue_t</span> createQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p>全局队列有这几种优先级：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hexcolor">#def</span>ine DISPATCH_QUEUE_PRIORITY_HIGH <span class="number">2</span></span><br><span class="line"><span class="hexcolor">#def</span>ine DISPATCH_QUEUE_PRIORITY_DEFAULT <span class="number">0</span></span><br><span class="line"><span class="hexcolor">#def</span>ine DISPATCH_QUEUE_PRIORITY_LOW (-<span class="number">2</span>)</span><br><span class="line"><span class="hexcolor">#def</span>ine DISPATCH_QUEUE_PRIORITY_BACKGROUND INT16_MIN</span><br></pre></td></tr></table></figure>
<h5 id="创建任务">创建任务</h5><p>同步任务：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_sync</span>(queue, ^&#123;</span><br><span class="line">    </span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">"com.testQueue"</span>, DISPATCH_QUEUE_SERIAL);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"async之前 - %@"</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line"><span class="built_in">dispatch_sync</span>(queue, ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"async1 - %@"</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">dispatch_sync</span>(queue, ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"async2 - %@"</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">dispatch_sync</span>(queue, ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"async3 - %@"</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"async之后 - %@"</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br></pre></td></tr></table></figure>
<p>log:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2016</span>-<span class="number">05</span>-<span class="number">05</span> <span class="number">07</span>:<span class="number">03</span>:<span class="number">01.137</span> syncTest[<span class="number">5181</span>:<span class="number">1954382</span>] async之前 - &lt;NSThread: <span class="number">0x7fd7e9400ec0</span>&gt;&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">05</span>-<span class="number">05</span> <span class="number">07</span>:<span class="number">03</span>:<span class="number">01.138</span> syncTest[<span class="number">5181</span>:<span class="number">1954382</span>] async1 - &lt;NSThread: <span class="number">0x7fd7e9400ec0</span>&gt;&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">05</span>-<span class="number">05</span> <span class="number">07</span>:<span class="number">03</span>:<span class="number">01.138</span> syncTest[<span class="number">5181</span>:<span class="number">1954382</span>] async2 - &lt;NSThread: <span class="number">0x7fd7e9400ec0</span>&gt;&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">05</span>-<span class="number">05</span> <span class="number">07</span>:<span class="number">03</span>:<span class="number">01.138</span> syncTest[<span class="number">5181</span>:<span class="number">1954382</span>] async3 - &lt;NSThread: <span class="number">0x7fd7e9400ec0</span>&gt;&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">05</span>-<span class="number">05</span> <span class="number">07</span>:<span class="number">03</span>:<span class="number">01.138</span> syncTest[<span class="number">5181</span>:<span class="number">1954382</span>] async之后 - &lt;NSThread: <span class="number">0x7fd7e9400ec0</span>&gt;&#123;number = <span class="number">1</span>, name = main&#125;</span><br></pre></td></tr></table></figure>
<p>注意：</p>
<p>1.同步队列无论设置是DISPATCH_QUEUE_SERIAL还是DISPATCH_QUEUE_CONCURRENT，任务都是在主线程执行,会阻塞主线程</p>
<p>2.dispatch_sync 中 queue 不能是 dispatch_get_main_queue() 即为主线程队列，否则会creash</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NSLog</span>(<span class="at_rule">@<span class="string">"dispatch_sync  enter"</span>);</span></span><br><span class="line"><span class="function">dispatch_sync</span>(<span class="function">dispatch_get_main_queue</span>(), ^&#123;</span><br><span class="line">    <span class="function">NSLog</span>(<span class="at_rule">@<span class="string">"dispatch_sync action"</span>);</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="function">NSLog</span>(<span class="at_rule">@<span class="string">"dispatch_sync leave"</span>);</span></span><br></pre></td></tr></table></figure>
<p>异步任务：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_async</span>(createQueue, ^&#123;</span><br><span class="line">    </span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//并行队列 DISPATCH_QUEUE_CONCURRENT</span></span><br><span class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">"com.testQueue"</span>, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"async之前 - %@"</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line"><span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"async1 - %@"</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"async2 - %@"</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"async3 - %@"</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"async之后 - %@"</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br></pre></td></tr></table></figure>
<p>log:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">21</span> <span class="number">07</span>:<span class="number">19</span>:<span class="number">53.817</span> asyncTest[<span class="number">13930</span>:<span class="number">8566716</span>] async之前 - &lt;NSThread: <span class="number">0x600000066a40</span>&gt;&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">21</span> <span class="number">07</span>:<span class="number">19</span>:<span class="number">53.818</span> asyncTest[<span class="number">13930</span>:<span class="number">8566716</span>] async之后 - &lt;NSThread: <span class="number">0x600000066a40</span>&gt;&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">21</span> <span class="number">07</span>:<span class="number">20</span>:<span class="number">59.683</span> asyncTest[<span class="number">13930</span>:<span class="number">8566864</span>] async2 - &lt;NSThread: <span class="number">0x60800007d700</span>&gt;&#123;number = <span class="number">4</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">21</span> <span class="number">07</span>:<span class="number">20</span>:<span class="number">59.683</span> asyncTest[<span class="number">13930</span>:<span class="number">8566862</span>] async3 - &lt;NSThread: <span class="number">0x60000007a9c0</span>&gt;&#123;number = <span class="number">3</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">21</span> <span class="number">07</span>:<span class="number">20</span>:<span class="number">59.683</span> asyncTest[<span class="number">13930</span>:<span class="number">8566867</span>] async1 - &lt;NSThread: <span class="number">0x60000007ad00</span>&gt;&#123;number = <span class="number">5</span>, name = (null)&#125;</span><br></pre></td></tr></table></figure>
<h4 id="队列组">队列组</h4><h5 id="创建队列-1">创建队列</h5><p>group 可以分为 串行和并行的，区别在于DISPATCH_QUEUE_SERIAL和DISPATCH_QUEUE_CONCURRENT设置不同</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dispatch_group_t</span> group = dispatch_group_create();</span><br><span class="line"><span class="keyword">dispatch_queue_t</span> <span class="built_in">queue</span> = dispatch_queue_create(<span class="string">"com.testQueue"</span>, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">dispatch_group_async(group, <span class="built_in">queue</span>, ^&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        NSLog(@<span class="string">"group-01 - %@"</span>, [NSThread currentThread]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);    </span><br><span class="line">dispatch_group_async(group, <span class="built_in">queue</span>, ^&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        NSLog(@<span class="string">"group-03 - %@"</span>, [NSThread currentThread]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>log: 串行,但是异步的，不会阻塞当前线程</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">21</span> <span class="number">08</span>:<span class="number">05</span>:<span class="number">14.110</span> GCDTest[<span class="number">14034</span>:<span class="number">8745909</span>] group-<span class="number">01</span> - &lt;NSThread: <span class="number">0x60000027d100</span>&gt;&#123;number = <span class="number">4</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">21</span> <span class="number">08</span>:<span class="number">05</span>:<span class="number">14.111</span> GCDTest[<span class="number">14034</span>:<span class="number">8745909</span>] group-<span class="number">01</span> - &lt;NSThread: <span class="number">0x60000027d100</span>&gt;&#123;number = <span class="number">4</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">21</span> <span class="number">08</span>:<span class="number">05</span>:<span class="number">14.112</span> GCDTest[<span class="number">14034</span>:<span class="number">8745909</span>] group-<span class="number">01</span> - &lt;NSThread: <span class="number">0x60000027d100</span>&gt;&#123;number = <span class="number">4</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">21</span> <span class="number">08</span>:<span class="number">05</span>:<span class="number">14.112</span> GCDTest[<span class="number">14034</span>:<span class="number">8745909</span>] group-<span class="number">01</span> - &lt;NSThread: <span class="number">0x60000027d100</span>&gt;&#123;number = <span class="number">4</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">21</span> <span class="number">08</span>:<span class="number">05</span>:<span class="number">14.112</span> GCDTest[<span class="number">14034</span>:<span class="number">8745909</span>] group-<span class="number">01</span> - &lt;NSThread: <span class="number">0x60000027d100</span>&gt;&#123;number = <span class="number">4</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">21</span> <span class="number">08</span>:<span class="number">05</span>:<span class="number">19.589</span> GCDTest[<span class="number">14034</span>:<span class="number">8745909</span>] group-<span class="number">03</span> - &lt;NSThread: <span class="number">0x60000027d100</span>&gt;&#123;number = <span class="number">4</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">21</span> <span class="number">08</span>:<span class="number">05</span>:<span class="number">19.590</span> GCDTest[<span class="number">14034</span>:<span class="number">8745909</span>] group-<span class="number">03</span> - &lt;NSThread: <span class="number">0x60000027d100</span>&gt;&#123;number = <span class="number">4</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">21</span> <span class="number">08</span>:<span class="number">05</span>:<span class="number">19.590</span> GCDTest[<span class="number">14034</span>:<span class="number">8745909</span>] group-<span class="number">03</span> - &lt;NSThread: <span class="number">0x60000027d100</span>&gt;&#123;number = <span class="number">4</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">21</span> <span class="number">08</span>:<span class="number">05</span>:<span class="number">19.591</span> GCDTest[<span class="number">14034</span>:<span class="number">8745909</span>] group-<span class="number">03</span> - &lt;NSThread: <span class="number">0x60000027d100</span>&gt;&#123;number = <span class="number">4</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">21</span> <span class="number">08</span>:<span class="number">05</span>:<span class="number">19.591</span> GCDTest[<span class="number">14034</span>:<span class="number">8745909</span>] group-<span class="number">03</span> - &lt;NSThread: <span class="number">0x60000027d100</span>&gt;&#123;number = <span class="number">4</span>, name = (null)&#125;</span><br></pre></td></tr></table></figure>
<p>并行:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">21</span> <span class="number">08</span>:<span class="number">09</span>:<span class="number">46.984</span> GCDTest[<span class="number">14058</span>:<span class="number">8768392</span>] group-<span class="number">03</span> - &lt;NSThread: <span class="number">0x608000273900</span>&gt;&#123;number = <span class="number">4</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">21</span> <span class="number">08</span>:<span class="number">09</span>:<span class="number">46.984</span> GCDTest[<span class="number">14058</span>:<span class="number">8768371</span>] group-<span class="number">01</span> - &lt;NSThread: <span class="number">0x608000273200</span>&gt;&#123;number = <span class="number">3</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">21</span> <span class="number">08</span>:<span class="number">09</span>:<span class="number">46.984</span> GCDTest[<span class="number">14058</span>:<span class="number">8768392</span>] group-<span class="number">03</span> - &lt;NSThread: <span class="number">0x608000273900</span>&gt;&#123;number = <span class="number">4</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">21</span> <span class="number">08</span>:<span class="number">09</span>:<span class="number">46.984</span> GCDTest[<span class="number">14058</span>:<span class="number">8768371</span>] group-<span class="number">01</span> - &lt;NSThread: <span class="number">0x608000273200</span>&gt;&#123;number = <span class="number">3</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">21</span> <span class="number">08</span>:<span class="number">09</span>:<span class="number">46.985</span> GCDTest[<span class="number">14058</span>:<span class="number">8768392</span>] group-<span class="number">03</span> - &lt;NSThread: <span class="number">0x608000273900</span>&gt;&#123;number = <span class="number">4</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">21</span> <span class="number">08</span>:<span class="number">09</span>:<span class="number">46.985</span> GCDTest[<span class="number">14058</span>:<span class="number">8768371</span>] group-<span class="number">01</span> - &lt;NSThread: <span class="number">0x608000273200</span>&gt;&#123;number = <span class="number">3</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">21</span> <span class="number">08</span>:<span class="number">09</span>:<span class="number">46.985</span> GCDTest[<span class="number">14058</span>:<span class="number">8768392</span>] group-<span class="number">03</span> - &lt;NSThread: <span class="number">0x608000273900</span>&gt;&#123;number = <span class="number">4</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">21</span> <span class="number">08</span>:<span class="number">09</span>:<span class="number">46.985</span> GCDTest[<span class="number">14058</span>:<span class="number">8768371</span>] group-<span class="number">01</span> - &lt;NSThread: <span class="number">0x608000273200</span>&gt;&#123;number = <span class="number">3</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">21</span> <span class="number">08</span>:<span class="number">09</span>:<span class="number">46.985</span> GCDTest[<span class="number">14058</span>:<span class="number">8768392</span>] group-<span class="number">03</span> - &lt;NSThread: <span class="number">0x608000273900</span>&gt;&#123;number = <span class="number">4</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">21</span> <span class="number">08</span>:<span class="number">09</span>:<span class="number">46.986</span> GCDTest[<span class="number">14058</span>:<span class="number">8768371</span>] group-<span class="number">01</span> - &lt;NSThread: <span class="number">0x608000273200</span>&gt;&#123;number = <span class="number">3</span>, name = (null)&#125;</span><br></pre></td></tr></table></figure>
<h5 id="监听任务组事件的执行完毕">监听任务组事件的执行完毕</h5><p>1.dispatch_group_notify </p>
<p>用来监听任务组事件的执行完毕, 异步执行闭包，不会阻塞</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span></span><br><span class="line"><span class="title">dispatch_group_notify</span><span class="params">(dispatch_group_t group,</span><br><span class="line">	dispatch_queue_t <span class="built_in">queue</span>,</span><br><span class="line">	dispatch_block_t block)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">dispatch_group_t group = dispatch_group_create<span class="list">()</span><span class="comment">;</span></span><br><span class="line">dispatch_queue_t queue = dispatch_queue_create<span class="list">(<span class="string">"com.testQueue"</span>, DISPATCH_QUEUE_CONCURRENT)</span><span class="comment">;</span></span><br><span class="line">dispatch_group_async<span class="list">(<span class="keyword">group</span>, queue, ^&#123;</span><br><span class="line">    [[NSThread currentThread] setName:@<span class="string">"group-01-thread"</span>]<span class="comment">;</span></span><br><span class="line">    for <span class="list">(<span class="keyword">int</span> i = <span class="number">0</span><span class="comment">; i &lt; 3; i++) &#123;</span></span><br><span class="line">        NSLog<span class="list">(@<span class="string">"group-01 - %@"</span>, [NSThread currentThread])</span><span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><span class="comment">;</span></span><br><span class="line">dispatch_group_async<span class="list">(<span class="keyword">group</span>, queue, ^&#123;</span><br><span class="line">    [[NSThread currentThread] setName:@<span class="string">"group-03-thread"</span>]<span class="comment">;</span></span><br><span class="line">    for <span class="list">(<span class="keyword">int</span> i = <span class="number">0</span><span class="comment">; i &lt; 3; i++) &#123;</span></span><br><span class="line">        NSLog<span class="list">(@<span class="string">"group-03 - %@"</span>, [NSThread currentThread])</span><span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><span class="comment">;</span></span><br><span class="line">NSLog<span class="list">(@<span class="string">"notify leave"</span>)</span><span class="comment">;</span></span><br><span class="line">dispatch_group_notify<span class="list">(<span class="keyword">group</span>, dispatch_get_main_queue<span class="list">()</span>, ^&#123;</span><br><span class="line">    NSLog<span class="list">(@<span class="string">"notify 完成 - %@"</span>, [NSThread currentThread])</span><span class="comment">;</span></span><br><span class="line">&#125;)</span><span class="comment">;</span></span><br><span class="line">NSLog<span class="list">(@<span class="string">"notify leave"</span>)</span><span class="comment">;</span></span></span></span><br></pre></td></tr></table></figure>
<p>log:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">22</span> <span class="number">07</span>:<span class="number">03</span>:<span class="number">18.150</span> GCDTest[<span class="number">19000</span>:<span class="number">9806166</span>] notify leave</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">22</span> <span class="number">07</span>:<span class="number">03</span>:<span class="number">18.150</span> GCDTest[<span class="number">19000</span>:<span class="number">9813919</span>] group-<span class="number">01</span> - &lt;NSThread: <span class="number">0x60000026b700</span>&gt;&#123;number = <span class="number">5</span>, name = group-<span class="number">01</span>-thread&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">22</span> <span class="number">07</span>:<span class="number">03</span>:<span class="number">18.150</span> GCDTest[<span class="number">19000</span>:<span class="number">9814304</span>] group-<span class="number">03</span> - &lt;NSThread: <span class="number">0x608000277800</span>&gt;&#123;number = <span class="number">6</span>, name = group-<span class="number">03</span>-thread&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">22</span> <span class="number">07</span>:<span class="number">03</span>:<span class="number">18.151</span> GCDTest[<span class="number">19000</span>:<span class="number">9806166</span>] notify leave</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">22</span> <span class="number">07</span>:<span class="number">03</span>:<span class="number">18.151</span> GCDTest[<span class="number">19000</span>:<span class="number">9813919</span>] group-<span class="number">01</span> - &lt;NSThread: <span class="number">0x60000026b700</span>&gt;&#123;number = <span class="number">5</span>, name = group-<span class="number">01</span>-thread&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">22</span> <span class="number">07</span>:<span class="number">03</span>:<span class="number">18.151</span> GCDTest[<span class="number">19000</span>:<span class="number">9814304</span>] group-<span class="number">03</span> - &lt;NSThread: <span class="number">0x608000277800</span>&gt;&#123;number = <span class="number">6</span>, name = group-<span class="number">03</span>-thread&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">22</span> <span class="number">07</span>:<span class="number">03</span>:<span class="number">18.152</span> GCDTest[<span class="number">19000</span>:<span class="number">9813919</span>] group-<span class="number">01</span> - &lt;NSThread: <span class="number">0x60000026b700</span>&gt;&#123;number = <span class="number">5</span>, name = group-<span class="number">01</span>-thread&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">22</span> <span class="number">07</span>:<span class="number">03</span>:<span class="number">18.152</span> GCDTest[<span class="number">19000</span>:<span class="number">9814304</span>] group-<span class="number">03</span> - &lt;NSThread: <span class="number">0x608000277800</span>&gt;&#123;number = <span class="number">6</span>, name = group-<span class="number">03</span>-thread&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">22</span> <span class="number">07</span>:<span class="number">03</span>:<span class="number">18.157</span> GCDTest[<span class="number">19000</span>:<span class="number">9806166</span>] notify 完成 - &lt;NSThread: <span class="number">0x60800007b6c0</span>&gt;&#123;number = <span class="number">1</span>, name = main&#125;</span><br></pre></td></tr></table></figure>
<p>2.dispatch_group_wait   </p>
<p>会阻塞当前进程，等所有任务都完成或等待超时。设置等待时间，在等待时间结束后，如果还没有执行完任务组，则返回。返回0代表执行成功，非0则执行失败</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">dispatch_group_wait</span>(<span class="params">dispatch_group_t <span class="keyword">group</span>, dispatch_time_t timeout</span>)</span>;</span><br></pre></td></tr></table></figure>
<p>超时时间 可以根据需要设置，系统提供了两个宏：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hexcolor">#def</span>ine DISPATCH_TIME_NOW (<span class="number">0</span>ull)</span><br><span class="line"><span class="hexcolor">#def</span>ine DISPATCH_TIME_FOREVER (~<span class="number">0</span>ull)</span><br></pre></td></tr></table></figure>
<p>在此之前介绍一下时间：</p>
<p>iOS系统 GCD 中提供了一下几种时间</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hexcolor">#def</span>ine NSEC_PER_SEC  <span class="number">1000000000</span>ull</span><br><span class="line"><span class="hexcolor">#def</span>ine NSEC_PER_MSEC <span class="number">1000000</span>ull</span><br><span class="line"><span class="hexcolor">#def</span>ine USEC_PER_SEC  <span class="number">1000000</span>ull</span><br><span class="line"><span class="hexcolor">#def</span>ine NSEC_PER_USEC <span class="number">1000</span>ull</span><br></pre></td></tr></table></figure>
<p>关键词解释：    </p>
<ul>
<li>NSEC：纳秒</li>
<li>USEC：微秒</li>
<li>MSEC：毫秒</li>
<li>SEC：秒</li>
<li>PER：每</li>
</ul>
<p>故：</p>
<table>
<thead>
<tr>
<th>宏</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>NSEC_PER_SEC</td>
<td style="text-align:center">每秒有多少纳秒</td>
</tr>
<tr>
<td>NSEC_PER_MSEC</td>
<td style="text-align:center">每毫秒有多少纳秒</td>
</tr>
<tr>
<td>USEC_PER_SEC</td>
<td style="text-align:center">每秒有多少微秒</td>
</tr>
<tr>
<td>NSEC_PER_USEC</td>
<td style="text-align:center">每微秒有多少纳秒</td>
</tr>
</tbody>
</table>
<p>所以，延时1秒可以写成如下几种：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dispatch_time<span class="list">(<span class="keyword">DISPATCH_TIME_NOW</span>, <span class="number">1</span> <span class="variable">* NSEC_PER_SEC);</span><br><span class="line">dispatch_time(DISPATCH_TIME_NOW, 1000 *</span> USEC_PER_SEC)</span><span class="comment">;</span></span><br><span class="line">dispatch_time<span class="list">(<span class="keyword">DISPATCH_TIME_NOW</span>, USEC_PER_SEC <span class="variable">* NSEC_PER_USEC);</span><br><span class="line">dispatch_time(DISPATCH_TIME_NOW, NSEC_PER_MSEC *</span> NSEC_PER_USEC)</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>绝对时间，dispatch_group_wait 想等到2016年09月22日23:20:53 的时候超时，那么要使用 dispatch_walltime函数将NSdate 转化为dispatch_time，下面是方法：</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- (dispatch_time_t)switchDateToDispatch_time_tWithDate:(NSDate *)<span class="type">date</span></span><br><span class="line">&#123;</span><br><span class="line">    NSTimeInterval interval;</span><br><span class="line">    double <span class="keyword">second</span>,subsecond;</span><br><span class="line">    struct timespec <span class="property">time</span>;</span><br><span class="line">    dispatch_time_t milestone;</span><br><span class="line">    interval=[<span class="type">date</span> timeIntervalSince1970];</span><br><span class="line">    </span><br><span class="line">    subsecond = modf(interval, &amp;<span class="keyword">second</span>);</span><br><span class="line">    <span class="property">time</span>.tv_sec = <span class="keyword">second</span>;</span><br><span class="line">    <span class="property">time</span>.tv_nsec= subsecond*NSEC_PER_SEC;</span><br><span class="line">    </span><br><span class="line">    milestone = dispatch_walltime(&amp;<span class="property">time</span>, <span class="number">0</span>);</span><br><span class="line"><span class="command">    return</span> milestone;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>好了时间说完了，该说示例了：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dispatch_group_t</span> group = dispatch_group_create();</span><br><span class="line"><span class="keyword">dispatch_queue_t</span> <span class="built_in">queue</span> = dispatch_queue_create(<span class="string">"com.testQueue"</span>, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">dispatch_group_async(group, <span class="built_in">queue</span>, ^&#123;</span><br><span class="line">    [[NSThread currentThread] setName:@<span class="string">"group-01-thread"</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        NSLog(@<span class="string">"group-01 - %@"</span>, [NSThread currentThread]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_group_async(group, <span class="built_in">queue</span>, ^&#123;</span><br><span class="line">    [[NSThread currentThread] setName:@<span class="string">"group-03-thread"</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        NSLog(@<span class="string">"group-03 - %@"</span>, [NSThread currentThread]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">NSLog(@<span class="string">"dispatch_group_wait 之前"</span>);</span><br><span class="line"><span class="keyword">long</span> value = dispatch_group_wait(group, DISPATCH_TIME_FOREVER);</span><br><span class="line">NSLog(@<span class="string">"dispatch_group_wait 之后 value = %ld"</span>,value);</span><br></pre></td></tr></table></figure>
<p>log:</p>
<p>① DISPATCH_TIME_FOREVER 可以看到会阻塞当前线程直到任务全部完成</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">22</span> <span class="number">07</span>:<span class="number">15</span>:<span class="number">14.211</span> GCDTest[<span class="number">19022</span>:<span class="number">9870397</span>] dispatch_group_wait 之前</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">22</span> <span class="number">07</span>:<span class="number">15</span>:<span class="number">14.211</span> GCDTest[<span class="number">19022</span>:<span class="number">9874488</span>] group-<span class="number">01</span> - &lt;NSThread: <span class="number">0x608000268f40</span>&gt;&#123;number = <span class="number">5</span>, name = group-<span class="number">01</span>-thread&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">22</span> <span class="number">07</span>:<span class="number">15</span>:<span class="number">14.211</span> GCDTest[<span class="number">19022</span>:<span class="number">9874995</span>] group-<span class="number">03</span> - &lt;NSThread: <span class="number">0x608000268500</span>&gt;&#123;number = <span class="number">6</span>, name = group-<span class="number">03</span>-thread&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">22</span> <span class="number">07</span>:<span class="number">15</span>:<span class="number">14.211</span> GCDTest[<span class="number">19022</span>:<span class="number">9874488</span>] group-<span class="number">01</span> - &lt;NSThread: <span class="number">0x608000268f40</span>&gt;&#123;number = <span class="number">5</span>, name = group-<span class="number">01</span>-thread&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">22</span> <span class="number">07</span>:<span class="number">15</span>:<span class="number">14.211</span> GCDTest[<span class="number">19022</span>:<span class="number">9874995</span>] group-<span class="number">03</span> - &lt;NSThread: <span class="number">0x608000268500</span>&gt;&#123;number = <span class="number">6</span>, name = group-<span class="number">03</span>-thread&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">22</span> <span class="number">07</span>:<span class="number">15</span>:<span class="number">14.211</span> GCDTest[<span class="number">19022</span>:<span class="number">9874488</span>] group-<span class="number">01</span> - &lt;NSThread: <span class="number">0x608000268f40</span>&gt;&#123;number = <span class="number">5</span>, name = group-<span class="number">01</span>-thread&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">22</span> <span class="number">07</span>:<span class="number">15</span>:<span class="number">14.212</span> GCDTest[<span class="number">19022</span>:<span class="number">9874995</span>] group-<span class="number">03</span> - &lt;NSThread: <span class="number">0x608000268500</span>&gt;&#123;number = <span class="number">6</span>, name = group-<span class="number">03</span>-thread&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">22</span> <span class="number">07</span>:<span class="number">15</span>:<span class="number">14.212</span> GCDTest[<span class="number">19022</span>:<span class="number">9870397</span>] dispatch_group_wait 之后 value = <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>② DISPATCH_TIME_NOW dispatch_group_wait 并未阻塞当前线程 但是 返回非零值，表明任务执行失败或者超时，这明显是超时</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">22</span> <span class="number">07</span>:<span class="number">18</span>:<span class="number">21.506</span> GCDTest[<span class="number">19041</span>:<span class="number">9887622</span>] dispatch_group_wait 之前</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">22</span> <span class="number">07</span>:<span class="number">18</span>:<span class="number">21.506</span> GCDTest[<span class="number">19041</span>:<span class="number">9891849</span>] group-<span class="number">01</span> - &lt;NSThread: <span class="number">0x608000274700</span>&gt;&#123;number = <span class="number">3</span>, name = group-<span class="number">01</span>-thread&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">22</span> <span class="number">07</span>:<span class="number">18</span>:<span class="number">21.506</span> GCDTest[<span class="number">19041</span>:<span class="number">9891894</span>] group-<span class="number">03</span> - &lt;NSThread: <span class="number">0x608000274680</span>&gt;&#123;number = <span class="number">4</span>, name = group-<span class="number">03</span>-thread&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">22</span> <span class="number">07</span>:<span class="number">18</span>:<span class="number">21.506</span> GCDTest[<span class="number">19041</span>:<span class="number">9887622</span>] dispatch_group_wait 之后 value = <span class="number">49</span></span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">22</span> <span class="number">07</span>:<span class="number">18</span>:<span class="number">21.506</span> GCDTest[<span class="number">19041</span>:<span class="number">9891849</span>] group-<span class="number">01</span> - &lt;NSThread: <span class="number">0x608000274700</span>&gt;&#123;number = <span class="number">3</span>, name = group-<span class="number">01</span>-thread&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">22</span> <span class="number">07</span>:<span class="number">18</span>:<span class="number">21.507</span> GCDTest[<span class="number">19041</span>:<span class="number">9891894</span>] group-<span class="number">03</span> - &lt;NSThread: <span class="number">0x608000274680</span>&gt;&#123;number = <span class="number">4</span>, name = group-<span class="number">03</span>-thread&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">22</span> <span class="number">07</span>:<span class="number">18</span>:<span class="number">21.507</span> GCDTest[<span class="number">19041</span>:<span class="number">9891849</span>] group-<span class="number">01</span> - &lt;NSThread: <span class="number">0x608000274700</span>&gt;&#123;number = <span class="number">3</span>, name = group-<span class="number">01</span>-thread&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">22</span> <span class="number">07</span>:<span class="number">18</span>:<span class="number">21.508</span> GCDTest[<span class="number">19041</span>:<span class="number">9891894</span>] group-<span class="number">03</span> - &lt;NSThread: <span class="number">0x608000274680</span>&gt;&#123;number = <span class="number">4</span>, name = group-<span class="number">03</span>-thread&#125;</span><br></pre></td></tr></table></figure>
<p>③ 自定义时间 会阻塞当前的线程</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这里让线程 睡眠2s</span></span><br><span class="line">    dispatch_group_async(group, <span class="built_in">queue</span>, ^&#123;</span><br><span class="line">        [[NSThread currentThread] setName:@<span class="string">"group-03-thread"</span>];</span><br><span class="line">        [NSThread sleepForTimeInterval:<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            NSLog(@<span class="string">"group-03 - %@"</span>, [NSThread currentThread]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"><span class="keyword">long</span> value = dispatch_group_wait(group, dispatch_time(DISPATCH_TIME_NOW, (<span class="keyword">int64_t</span>)(<span class="number">5</span>*NSEC_PER_SEC)));</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">22</span> <span class="number">07</span>:<span class="number">37</span>:<span class="number">32.478</span> GCDTest[<span class="number">19217</span>:<span class="number">10005760</span>] dispatch_group_wait 之前</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">22</span> <span class="number">07</span>:<span class="number">37</span>:<span class="number">32.478</span> GCDTest[<span class="number">19217</span>:<span class="number">10006060</span>] group-<span class="number">01</span> - &lt;NSThread: <span class="number">0x608000274140</span>&gt;&#123;number = <span class="number">3</span>, name = group-<span class="number">01</span>-thread&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">22</span> <span class="number">07</span>:<span class="number">37</span>:<span class="number">32.479</span> GCDTest[<span class="number">19217</span>:<span class="number">10006060</span>] group-<span class="number">01</span> - &lt;NSThread: <span class="number">0x608000274140</span>&gt;&#123;number = <span class="number">3</span>, name = group-<span class="number">01</span>-thread&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">22</span> <span class="number">07</span>:<span class="number">37</span>:<span class="number">32.479</span> GCDTest[<span class="number">19217</span>:<span class="number">10006060</span>] group-<span class="number">01</span> - &lt;NSThread: <span class="number">0x608000274140</span>&gt;&#123;number = <span class="number">3</span>, name = group-<span class="number">01</span>-thread&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">22</span> <span class="number">07</span>:<span class="number">37</span>:<span class="number">34.482</span> GCDTest[<span class="number">19217</span>:<span class="number">10006057</span>] group-<span class="number">03</span> - &lt;NSThread: <span class="number">0x608000273f80</span>&gt;&#123;number = <span class="number">4</span>, name = group-<span class="number">03</span>-thread&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">22</span> <span class="number">07</span>:<span class="number">37</span>:<span class="number">34.483</span> GCDTest[<span class="number">19217</span>:<span class="number">10006057</span>] group-<span class="number">03</span> - &lt;NSThread: <span class="number">0x608000273f80</span>&gt;&#123;number = <span class="number">4</span>, name = group-<span class="number">03</span>-thread&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">22</span> <span class="number">07</span>:<span class="number">37</span>:<span class="number">34.483</span> GCDTest[<span class="number">19217</span>:<span class="number">10006057</span>] group-<span class="number">03</span> - &lt;NSThread: <span class="number">0x608000273f80</span>&gt;&#123;number = <span class="number">4</span>, name = group-<span class="number">03</span>-thread&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">22</span> <span class="number">07</span>:<span class="number">37</span>:<span class="number">34.484</span> GCDTest[<span class="number">19217</span>:<span class="number">10005760</span>] dispatch_group_wait 之后 value = <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>3.dispatch_group_enter  dispatch_group_leave<br>这里 dispatch_group_enter 和 dispatch_group_leave 需要成对出现,否则dispatch_group_notify不会回调用（这里可能会崩溃，不过在我测试中没有发现）</p>
<p>①这是 dispatch_queue_t 的例子：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">dispatch_group_t group = dispatch_group_create<span class="list">()</span><span class="comment">;</span></span><br><span class="line">dispatch_queue_t queue = dispatch_queue_create<span class="list">(<span class="string">"com.testQueue"</span>, DISPATCH_QUEUE_CONCURRENT)</span><span class="comment">;</span></span><br><span class="line">dispatch_group_enter<span class="list">(<span class="keyword">group</span>)</span><span class="comment">;</span></span><br><span class="line">dispatch_group_async<span class="list">(<span class="keyword">group</span>, queue, ^&#123;</span><br><span class="line">    [[NSThread currentThread] setName:@<span class="string">"group-01-thread"</span>]<span class="comment">;</span></span><br><span class="line">    for <span class="list">(<span class="keyword">int</span> i = <span class="number">0</span><span class="comment">; i &lt; 3; i++) &#123;</span></span><br><span class="line">        NSLog<span class="list">(@<span class="string">"group-01 - %@"</span>, [NSThread currentThread])</span><span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line">    dispatch_group_leave<span class="list">(<span class="keyword">group</span>)</span><span class="comment">;</span></span><br><span class="line">&#125;)</span><span class="comment">;</span></span><br><span class="line">dispatch_group_enter<span class="list">(<span class="keyword">group</span>)</span><span class="comment">;</span></span><br><span class="line">dispatch_group_async<span class="list">(<span class="keyword">group</span>, queue, ^&#123;</span><br><span class="line">    [[NSThread currentThread] setName:@<span class="string">"group-03-thread"</span>]<span class="comment">;</span></span><br><span class="line">    [NSThread sleepForTimeInterval:<span class="number">2</span>]<span class="comment">;</span></span><br><span class="line">    for <span class="list">(<span class="keyword">int</span> i = <span class="number">0</span><span class="comment">; i &lt; 3; i++) &#123;</span></span><br><span class="line">        NSLog<span class="list">(@<span class="string">"group-03 - %@"</span>, [NSThread currentThread])</span><span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line">    dispatch_group_leave<span class="list">(<span class="keyword">group</span>)</span><span class="comment">;</span></span><br><span class="line">&#125;)</span><span class="comment">;</span></span><br><span class="line">dispatch_group_notify<span class="list">(<span class="keyword">group</span>, dispatch_get_main_queue<span class="list">()</span>, ^&#123;</span><br><span class="line">    NSLog<span class="list">(@<span class="string">"notify 完成 - %@"</span>, [NSThread currentThread])</span><span class="comment">;</span></span><br><span class="line">&#125;)</span><span class="comment">;</span></span></span></span><br></pre></td></tr></table></figure>
<p>②这是NSOperationQueue的例子：</p>
<figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">dispatch_group_t <span class="keyword">group</span> = dispatch_group_create();</span><br><span class="line">NSOperationQueue *queue = [[NSOperationQueue alloc] init];</span><br><span class="line">dispatch_group_enter(<span class="keyword">group</span>);</span><br><span class="line">NSBlockOperation *<span class="built_in">block</span>Operation_1 = [NSBlockOperation <span class="built_in">block</span>OperationWithBlock:^&#123;</span><br><span class="line">    NSLog(@<span class="string">"NSBlockOperation 1 --- %@"</span>, [NSThread currentThread]);</span><br><span class="line">    [NSThread sleepForTimeInterval:<span class="number">2</span>];</span><br><span class="line">    dispatch_group_leave(<span class="keyword">group</span>);</span><br><span class="line">&#125;];</span><br><span class="line">dispatch_group_enter(<span class="keyword">group</span>);</span><br><span class="line">NSBlockOperation *<span class="built_in">block</span>Operation_2 = [NSBlockOperation <span class="built_in">block</span>OperationWithBlock:^&#123;</span><br><span class="line">    NSLog(@<span class="string">"NSBlockOperation 2 --- %@"</span>, [NSThread currentThread]);</span><br><span class="line">    dispatch_group_leave(<span class="keyword">group</span>);</span><br><span class="line">&#125;];</span><br><span class="line">[<span class="built_in">block</span>Operation_1 <span class="built_in">set</span>Name:@<span class="string">"blockOperation_1"</span>];</span><br><span class="line">[<span class="built_in">block</span>Operation_1 <span class="built_in">set</span>Name:@<span class="string">"blockOperation_2"</span>];</span><br><span class="line">[queue addOperation:<span class="built_in">block</span>Operation_1];</span><br><span class="line">[queue addOperation:<span class="built_in">block</span>Operation_2];</span><br><span class="line">dispatch_group_notify(<span class="keyword">group</span>, dispatch_get_main_queue(), ^&#123;</span><br><span class="line">    NSLog(@<span class="string">"notify 完成 - %@"</span>, [NSThread currentThread]);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h5 id="dispatch_once">dispatch_once</h5><p>dispatch_once 大家都不会陌生，但我认为还是有必要强调一次，dispatch_once_t 必须为静态变量</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line"><span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">    <span class="comment">// to do something</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h5 id="dispatch_after">dispatch_after</h5><p>dispatch_after 能让我们添加进队列的任务延时（这里说延时不严谨，后面会说到）执行</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">NSLog(@<span class="string">"begin"</span>);</span><br><span class="line"><span class="keyword">double</span> delayInSeconds = <span class="number">1.0</span>;</span><br><span class="line"><span class="keyword">dispatch_time_t</span> popTime = dispatch_time(DISPATCH_TIME_NOW, (<span class="keyword">int64_t</span>)(delayInSeconds * NSEC_PER_SEC));</span><br><span class="line">dispatch_after(popTime, dispatch_get_main_queue(), ^&#123;</span><br><span class="line">    NSLog(@<span class="string">"end"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>虽然可以提供NStimer 的功能，但它不是，看下面官方文档：</p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Enqueue <span class="operator">a</span> block <span class="keyword">for</span> execution <span class="keyword">at</span> <span class="operator">the</span> specified <span class="built_in">time</span>.</span><br></pre></td></tr></table></figure>
<p>Enqueue，就是入队，指的就是将一个Block在特定的延时以后，加入到指定的队列中，不是在特定的时间后立即运行！。这里有个例子:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dispatch_queue_t</span> <span class="built_in">queue</span> = dispatch_queue_create(<span class="string">"com.testQueue"</span>, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">NSLog(@<span class="string">"begin"</span>);</span><br><span class="line">dispatch_async(<span class="built_in">queue</span>, ^&#123;</span><br><span class="line">    [[NSThread currentThread] setName:@<span class="string">"group-01-thread"</span>];</span><br><span class="line">    [NSThread sleepForTimeInterval:<span class="number">10</span>];</span><br><span class="line">    NSLog(@<span class="string">"dispatch_group_async"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//1.使用 dispatch_after 延后工作</span></span><br><span class="line"><span class="keyword">double</span> delayInSeconds = <span class="number">5.0</span>;</span><br><span class="line"><span class="keyword">dispatch_time_t</span> popTime = dispatch_time(DISPATCH_TIME_NOW, (<span class="keyword">int64_t</span>)(delayInSeconds * NSEC_PER_SEC));</span><br><span class="line">dispatch_after(popTime, <span class="built_in">queue</span>, ^&#123;</span><br><span class="line">    NSLog(@<span class="string">"dispatch_time"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>log:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">23</span> <span class="number">22</span>:<span class="number">56</span>:<span class="number">05.258</span> GCDTest[<span class="number">20684</span>:<span class="number">11209748</span>] begin</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">23</span> <span class="number">22</span>:<span class="number">56</span>:<span class="number">15.263</span> GCDTest[<span class="number">20684</span>:<span class="number">11209796</span>] dispatch_group_async</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">23</span> <span class="number">22</span>:<span class="number">56</span>:<span class="number">15.263</span> GCDTest[<span class="number">20684</span>:<span class="number">11209796</span>] dispatch_time</span><br></pre></td></tr></table></figure>
<p>从结果也验证了，dispatch_after只是延时提交block，并不是延时后立即执行。所以想用dispatch_after精确控制运行状态的朋友可要注意了~</p>
<h5 id="dispatch_apply">dispatch_apply</h5><p>dispatch_apply的作用是在一个队列（串行或并行）上“运行”多次block，不过会阻塞当前线程，按执行最长任务时间阻塞(异步，同步是所有任务时间总和)，用时间要小心：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dispatch_queue_t</span> <span class="built_in">queue</span> = dispatch_queue_create(<span class="string">"com.testQueue"</span>, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">NSLog(@<span class="string">"apply 之前"</span>);</span><br><span class="line">dispatch_apply(<span class="number">3</span>, <span class="built_in">queue</span>, ^(<span class="keyword">size_t</span> y) &#123;</span><br><span class="line">    <span class="keyword">switch</span> (y) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:[NSThread sleepForTimeInterval:<span class="number">1</span>];<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:[NSThread sleepForTimeInterval:<span class="number">2</span>];<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:[NSThread sleepForTimeInterval:<span class="number">3</span>];<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:<span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    NSLog(@<span class="string">"%ld"</span>,y);</span><br><span class="line">&#125;);</span><br><span class="line">NSLog(@<span class="string">"apply 之后"</span>);</span><br></pre></td></tr></table></figure>
<p>log:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">23</span> <span class="number">23</span>:<span class="number">30</span>:<span class="number">24.984</span> GCDTest[<span class="number">20779</span>:<span class="number">11373252</span>] apply 之前</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">23</span> <span class="number">23</span>:<span class="number">30</span>:<span class="number">25.985</span> GCDTest[<span class="number">20779</span>:<span class="number">11373252</span>] <span class="number">0</span></span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">23</span> <span class="number">23</span>:<span class="number">30</span>:<span class="number">26.987</span> GCDTest[<span class="number">20779</span>:<span class="number">11373585</span>] <span class="number">1</span></span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">23</span> <span class="number">23</span>:<span class="number">30</span>:<span class="number">27.988</span> GCDTest[<span class="number">20779</span>:<span class="number">11373584</span>] <span class="number">2</span></span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">23</span> <span class="number">23</span>:<span class="number">30</span>:<span class="number">27.988</span> GCDTest[<span class="number">20779</span>:<span class="number">11373252</span>] apply 之后</span><br></pre></td></tr></table></figure>
<p>将其放在异步线程去执行，这样就不阻塞主线程了：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">NSLog(@<span class="string">"dispatch_async 之前"</span>);</span><br><span class="line">dispatch_async(dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>), ^&#123;</span><br><span class="line">    <span class="keyword">dispatch_queue_t</span> <span class="built_in">queue</span> = dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">//使用dispatch_apply可以运行的更快</span></span><br><span class="line">    NSLog(@<span class="string">"apply 之前"</span>);</span><br><span class="line">    dispatch_apply(<span class="number">3</span>, <span class="built_in">queue</span>, ^(<span class="keyword">size_t</span> y) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (y) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:[NSThread sleepForTimeInterval:<span class="number">1</span>];<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:[NSThread sleepForTimeInterval:<span class="number">2</span>];<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:[NSThread sleepForTimeInterval:<span class="number">3</span>];<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        NSLog(@<span class="string">"%ld"</span>,y);</span><br><span class="line">    &#125;);</span><br><span class="line">    NSLog(@<span class="string">"apply 之后"</span>);</span><br><span class="line">&#125;);</span><br><span class="line">NSLog(@<span class="string">"dispatch_async 之后"</span>);</span><br></pre></td></tr></table></figure>
<p>log:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">23</span> <span class="number">23</span>:<span class="number">38</span>:<span class="number">21.221</span> GCDTest[<span class="number">20817</span>:<span class="number">11403936</span>] dispatch_async 之前</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">23</span> <span class="number">23</span>:<span class="number">38</span>:<span class="number">21.222</span> GCDTest[<span class="number">20817</span>:<span class="number">11403936</span>] dispatch_async 之后</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">23</span> <span class="number">23</span>:<span class="number">38</span>:<span class="number">21.222</span> GCDTest[<span class="number">20817</span>:<span class="number">11404070</span>] apply 之前</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">23</span> <span class="number">23</span>:<span class="number">38</span>:<span class="number">22.223</span> GCDTest[<span class="number">20817</span>:<span class="number">11404070</span>] <span class="number">0</span></span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">23</span> <span class="number">23</span>:<span class="number">38</span>:<span class="number">23.226</span> GCDTest[<span class="number">20817</span>:<span class="number">11404072</span>] <span class="number">1</span></span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">23</span> <span class="number">23</span>:<span class="number">38</span>:<span class="number">24.225</span> GCDTest[<span class="number">20817</span>:<span class="number">11404069</span>] <span class="number">2</span></span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">23</span> <span class="number">23</span>:<span class="number">38</span>:<span class="number">24.226</span> GCDTest[<span class="number">20817</span>:<span class="number">11404070</span>] apply 之后</span><br></pre></td></tr></table></figure>
<h5 id="dispatch_barrier_async">dispatch_barrier_async</h5><p>dispatch_barrier_async的作用就是向某个队列插入一个block，当目前正在执行的block运行完成后，阻塞这个block后面添加的block，只运行这个block直到完成，然后再继续后续的任务。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">dispatch_group_t group = dispatch_group_create<span class="list">()</span><span class="comment">;</span></span><br><span class="line">//    dispatch_queue_t queue = dispatch_get_global_queue<span class="list">(<span class="keyword">DISPATCH_QUEUE_PRIORITY_DEFAULT</span>, <span class="number">0</span>)</span><span class="comment">;</span></span><br><span class="line">dispatch_queue_t queue = dispatch_queue_create<span class="list">(<span class="string">"com.testQueue"</span>, DISPATCH_QUEUE_CONCURRENT)</span><span class="comment">;</span></span><br><span class="line">dispatch_group_async<span class="list">(<span class="keyword">group</span>, queue, ^&#123;</span><br><span class="line">    NSLog<span class="list">(@<span class="string">"group-01 - %@"</span>, [NSThread currentThread])</span><span class="comment">;</span></span><br><span class="line">&#125;)</span><span class="comment">;</span></span><br><span class="line"></span><br><span class="line">dispatch_barrier_async<span class="list">(<span class="keyword">queue</span>, ^&#123;</span><br><span class="line">    NSLog<span class="list">(@<span class="string">"barrier - %@"</span>, [NSThread currentThread])</span><span class="comment">;</span></span><br><span class="line">&#125;)</span><span class="comment">;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">dispatch_group_async<span class="list">(<span class="keyword">group</span>, queue, ^&#123;</span><br><span class="line">    for <span class="list">(<span class="keyword">int</span> i = <span class="number">0</span><span class="comment">; i &lt; 3; i++) &#123;</span></span><br><span class="line">        NSLog<span class="list">(@<span class="string">"group-02 - %@"</span>, [NSThread currentThread])</span><span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><span class="comment">;</span></span><br><span class="line"></span><br><span class="line">dispatch_group_async<span class="list">(<span class="keyword">group</span>, queue, ^&#123;</span><br><span class="line">    for <span class="list">(<span class="keyword">int</span> i = <span class="number">0</span><span class="comment">; i &lt; 3; i++) &#123;</span></span><br><span class="line">        NSLog<span class="list">(@<span class="string">"group-03 - %@"</span>, [NSThread currentThread])</span><span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><span class="comment">;</span></span></span></span><br></pre></td></tr></table></figure>
<p>log:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">23</span> <span class="number">23</span>:<span class="number">54</span>:<span class="number">08.478</span> GCDTest[<span class="number">20928</span>:<span class="number">11478999</span>] group-<span class="number">01</span> - &lt;NSThread: <span class="number">0x608000265700</span>&gt;&#123;number = <span class="number">3</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">23</span> <span class="number">23</span>:<span class="number">54</span>:<span class="number">08.478</span> GCDTest[<span class="number">20928</span>:<span class="number">11478999</span>] barrier - &lt;NSThread: <span class="number">0x608000265700</span>&gt;&#123;number = <span class="number">3</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">23</span> <span class="number">23</span>:<span class="number">54</span>:<span class="number">08.480</span> GCDTest[<span class="number">20928</span>:<span class="number">11478999</span>] group-<span class="number">02</span> - &lt;NSThread: <span class="number">0x608000265700</span>&gt;&#123;number = <span class="number">3</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">23</span> <span class="number">23</span>:<span class="number">54</span>:<span class="number">08.480</span> GCDTest[<span class="number">20928</span>:<span class="number">11478997</span>] group-<span class="number">03</span> - &lt;NSThread: <span class="number">0x60000026c680</span>&gt;&#123;number = <span class="number">4</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">23</span> <span class="number">23</span>:<span class="number">54</span>:<span class="number">08.481</span> GCDTest[<span class="number">20928</span>:<span class="number">11478999</span>] group-<span class="number">02</span> - &lt;NSThread: <span class="number">0x608000265700</span>&gt;&#123;number = <span class="number">3</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">23</span> <span class="number">23</span>:<span class="number">54</span>:<span class="number">08.481</span> GCDTest[<span class="number">20928</span>:<span class="number">11478997</span>] group-<span class="number">03</span> - &lt;NSThread: <span class="number">0x60000026c680</span>&gt;&#123;number = <span class="number">4</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">23</span> <span class="number">23</span>:<span class="number">54</span>:<span class="number">08.482</span> GCDTest[<span class="number">20928</span>:<span class="number">11478999</span>] group-<span class="number">02</span> - &lt;NSThread: <span class="number">0x608000265700</span>&gt;&#123;number = <span class="number">3</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">23</span> <span class="number">23</span>:<span class="number">54</span>:<span class="number">08.482</span> GCDTest[<span class="number">20928</span>:<span class="number">11478997</span>] group-<span class="number">03</span> - &lt;NSThread: <span class="number">0x60000026c680</span>&gt;&#123;number = <span class="number">4</span>, name = (null)&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>dispatch<em>barrier\</em>(a)sync 只在自己创建的并发队列上有效，在全局(Global)并发队列、串行队列上，效果跟dispatch_(a)sync效果一样。</li>
<li>既然在串行队列上跟dispatch_(a)sync效果一样，那就要小心别死锁！</li>
</ul>
<p>在dispatch_get_global_queue：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">23</span> <span class="number">23</span>:<span class="number">56</span>:<span class="number">14.201</span> GCDTest[<span class="number">20946</span>:<span class="number">11496633</span>] group-<span class="number">01</span> - &lt;NSThread: <span class="number">0x608000263780</span>&gt;&#123;number = <span class="number">3</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">23</span> <span class="number">23</span>:<span class="number">56</span>:<span class="number">14.201</span> GCDTest[<span class="number">20946</span>:<span class="number">11497029</span>] group-<span class="number">02</span> - &lt;NSThread: <span class="number">0x600000277200</span>&gt;&#123;number = <span class="number">5</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">23</span> <span class="number">23</span>:<span class="number">56</span>:<span class="number">14.201</span> GCDTest[<span class="number">20946</span>:<span class="number">11497030</span>] group-<span class="number">03</span> - &lt;NSThread: <span class="number">0x608000265840</span>&gt;&#123;number = <span class="number">6</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">23</span> <span class="number">23</span>:<span class="number">56</span>:<span class="number">14.201</span> GCDTest[<span class="number">20946</span>:<span class="number">11497028</span>] barrier - &lt;NSThread: <span class="number">0x608000265680</span>&gt;&#123;number = <span class="number">4</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">23</span> <span class="number">23</span>:<span class="number">56</span>:<span class="number">14.201</span> GCDTest[<span class="number">20946</span>:<span class="number">11497029</span>] group-<span class="number">02</span> - &lt;NSThread: <span class="number">0x600000277200</span>&gt;&#123;number = <span class="number">5</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">23</span> <span class="number">23</span>:<span class="number">56</span>:<span class="number">14.201</span> GCDTest[<span class="number">20946</span>:<span class="number">11497030</span>] group-<span class="number">03</span> - &lt;NSThread: <span class="number">0x608000265840</span>&gt;&#123;number = <span class="number">6</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">23</span> <span class="number">23</span>:<span class="number">56</span>:<span class="number">14.202</span> GCDTest[<span class="number">20946</span>:<span class="number">11497029</span>] group-<span class="number">02</span> - &lt;NSThread: <span class="number">0x600000277200</span>&gt;&#123;number = <span class="number">5</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">23</span> <span class="number">23</span>:<span class="number">56</span>:<span class="number">14.202</span> GCDTest[<span class="number">20946</span>:<span class="number">11497030</span>] group-<span class="number">03</span> - &lt;NSThread: <span class="number">0x608000265840</span>&gt;&#123;number = <span class="number">6</span>, name = (null)&#125;</span><br></pre></td></tr></table></figure>
<h5 id="暂停与恢复">暂停与恢复</h5><ul>
<li>dispatch_suspend(queue); 暂停队列</li>
<li>dispatch_resume(queue); 恢复队列</li>
</ul>
<p>dispatch_suspend函数对已经执行的处理没有影响。挂起后，追加到 Dispatch Queue 中但尚未执行的处理在此之后停止执行。而dispatch_resume则使得这些处理能够继续执行。</p>
<p>这里有个例子（<a href="https://github.com/ChenYilong/ParseSourceCodeStudy/blob/master/01_Parse的多线程处理思路/Parse的底层多线程处理思路.md#parse-ios-sdk介绍" target="_blank" rel="external">参考来自这里</a>）</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t queue1 = dispatch_queue_create<span class="list">(<span class="string">"com.queue1"</span>, <span class="number">0</span>)</span><span class="comment">;</span></span><br><span class="line">dispatch_queue_t queue2 = dispatch_queue_create<span class="list">(<span class="string">"com.queue2"</span>, <span class="number">0</span>)</span><span class="comment">;</span></span><br><span class="line">dispatch_group_t group  = dispatch_group_create<span class="list">()</span><span class="comment">;</span></span><br><span class="line">dispatch_async<span class="list">(<span class="keyword">queue1</span>, ^&#123;</span><br><span class="line">    NSLog<span class="list">(@<span class="string">"任务 1 ： queue 1..."</span>)</span><span class="comment">;</span></span><br><span class="line">    sleep<span class="list">(<span class="number">1</span>)</span><span class="comment">;</span></span><br><span class="line">    NSLog<span class="list">(@<span class="string">"✅完成任务 1"</span>)</span><span class="comment">;</span></span><br><span class="line">&#125;)</span><span class="comment">;</span></span><br><span class="line"></span><br><span class="line">dispatch_async<span class="list">(<span class="keyword">queue2</span>, ^&#123;</span><br><span class="line">    NSLog<span class="list">(@<span class="string">"任务 1 ： queue 2..."</span>)</span><span class="comment">;</span></span><br><span class="line">    sleep<span class="list">(<span class="number">1</span>)</span><span class="comment">;</span></span><br><span class="line">    NSLog<span class="list">(@<span class="string">"✅完成任务 2"</span>)</span><span class="comment">;</span></span><br><span class="line">&#125;)</span><span class="comment">;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">dispatch_group_async<span class="list">(<span class="keyword">group</span>, queue1, ^&#123;</span><br><span class="line">    NSLog<span class="list">(@<span class="string">"🚫正在暂停 1"</span>)</span><span class="comment">;</span></span><br><span class="line">    dispatch_suspend<span class="list">(<span class="keyword">queue1</span>)</span><span class="comment">;</span></span><br><span class="line">&#125;)</span><span class="comment">;</span></span><br><span class="line">dispatch_group_async<span class="list">(<span class="keyword">group</span>, queue2, ^&#123;</span><br><span class="line">    NSLog<span class="list">(@<span class="string">"🚫正在暂停 2"</span>)</span><span class="comment">;</span></span><br><span class="line">    dispatch_suspend<span class="list">(<span class="keyword">queue2</span>)</span><span class="comment">;</span></span><br><span class="line">&#125;)</span><span class="comment">;</span></span><br><span class="line">dispatch_group_wait<span class="list">(<span class="keyword">group</span>, DISPATCH_TIME_FOREVER)</span><span class="comment">;</span></span><br><span class="line">NSLog<span class="list">(@<span class="string">"＝＝＝＝＝＝＝等待两个queue完成, 再往下进行..."</span>)</span><span class="comment">;</span></span><br><span class="line">dispatch_async<span class="list">(<span class="keyword">queue1</span>, ^&#123;</span><br><span class="line">    NSLog<span class="list">(@<span class="string">"任务 2 ： queue 1"</span>)</span><span class="comment">;</span></span><br><span class="line">&#125;)</span><span class="comment">;</span></span><br><span class="line">dispatch_async<span class="list">(<span class="keyword">queue2</span>, ^&#123;</span><br><span class="line">    NSLog<span class="list">(@<span class="string">"任务 2 ： queue 2"</span>)</span><span class="comment">;</span></span><br><span class="line">&#125;)</span><span class="comment">;</span></span><br><span class="line">NSLog<span class="list">(@<span class="string">"🔴为什么这个NSLog会在上面两个NSLog之前打印❓❓答：dispatch_suspend的作用‼️"</span>)</span><span class="comment">;</span></span><br><span class="line"></span><br><span class="line">dispatch_resume<span class="list">(<span class="keyword">queue1</span>)</span><span class="comment">;</span></span><br><span class="line">dispatch_resume<span class="list">(<span class="keyword">queue2</span>)</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>log:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">24</span> <span class="number">22</span>:<span class="number">12</span>:<span class="number">58.646</span> GCDTest[<span class="number">22178</span>:<span class="number">12407680</span>] 任务 <span class="number">1</span> ： <span class="built_in">queue</span> <span class="number">1.</span>..</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">24</span> <span class="number">22</span>:<span class="number">12</span>:<span class="number">58.646</span> GCDTest[<span class="number">22178</span>:<span class="number">12408707</span>] 任务 <span class="number">1</span> ： <span class="built_in">queue</span> <span class="number">2.</span>..</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">24</span> <span class="number">22</span>:<span class="number">12</span>:<span class="number">59.650</span> GCDTest[<span class="number">22178</span>:<span class="number">12407680</span>] ✅完成任务 <span class="number">1</span></span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">24</span> <span class="number">22</span>:<span class="number">12</span>:<span class="number">59.650</span> GCDTest[<span class="number">22178</span>:<span class="number">12408707</span>] ✅完成任务 <span class="number">2</span></span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">24</span> <span class="number">22</span>:<span class="number">12</span>:<span class="number">59.650</span> GCDTest[<span class="number">22178</span>:<span class="number">12407680</span>] 🚫正在暂停 <span class="number">1</span></span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">24</span> <span class="number">22</span>:<span class="number">12</span>:<span class="number">59.650</span> GCDTest[<span class="number">22178</span>:<span class="number">12408707</span>] 🚫正在暂停 <span class="number">2</span></span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">24</span> <span class="number">22</span>:<span class="number">12</span>:<span class="number">59.650</span> GCDTest[<span class="number">22178</span>:<span class="number">12407286</span>] ＝＝＝＝＝＝＝等待两个<span class="built_in">queue</span>完成, 再往下进行...</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">24</span> <span class="number">22</span>:<span class="number">12</span>:<span class="number">59.651</span> GCDTest[<span class="number">22178</span>:<span class="number">12407286</span>] 🔴为什么这个NSLog会在上面两个NSLog之前打印❓❓答：dispatch_suspend的作用‼️</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">24</span> <span class="number">22</span>:<span class="number">12</span>:<span class="number">59.651</span> GCDTest[<span class="number">22178</span>:<span class="number">12408707</span>] 任务 <span class="number">2</span> ： <span class="built_in">queue</span> <span class="number">1</span></span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">24</span> <span class="number">22</span>:<span class="number">12</span>:<span class="number">59.651</span> GCDTest[<span class="number">22178</span>:<span class="number">12407680</span>] 任务 <span class="number">2</span> ： <span class="built_in">queue</span> <span class="number">2</span></span><br></pre></td></tr></table></figure>
<h4 id="Dispatch_Source_（信号源)">Dispatch Source （信号源)</h4><p>GCD中除了主要的 Dispatch Queue 外，还有不太引人注目的 Dispatch Source .它是BSD系内核惯有功能kqueue的包装。kqueue 是在 XNU 内核中发生各种事件时，在应用程序编程方执行处理的技术。其 CPU 负荷非常小，尽量不占用资源。kqueue 可以说是应用程序处理 XNU 内核中发生的各种事件的方法中最优秀的一种。</p>
<p>Dispatch Source是GCD中的一个基本类型，从字面意思可称为调度源，它的作用是当有一些特定的较底层的系统事件发生时，调度源会捕捉到这些事件，然后可以做其他的逻辑处理，调度源有多种类型，分别监听对应类型的系统事件。</p>
<p>Dispatch Source 可处理的所有事件。如下表所示：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th style="text-align:center">内容</th>
</tr>
</thead>
<tbody>
<tr>
<td>DISPATCH_SOURCE_TYPE_DATA_ADD</td>
<td style="text-align:center">变量增加</td>
</tr>
<tr>
<td>DISPATCH_SOURCE_TYPE_DATA_OR</td>
<td style="text-align:center">变量OR</td>
</tr>
<tr>
<td>DISPATCH_SOURCE_TYPE_MACH_SEND</td>
<td style="text-align:center">MACH端口发送</td>
</tr>
<tr>
<td>DISPATCH_SOURCE_TYPE_MACH_RECV</td>
<td style="text-align:center">MACH端口接收</td>
</tr>
<tr>
<td>DISPATCH_SOURCE_TYPE_PROC</td>
<td style="text-align:center">监测到与进程相关的事件</td>
</tr>
<tr>
<td>DISPATCH_SOURCE_TYPE_READ</td>
<td style="text-align:center">可读取文件映像</td>
</tr>
<tr>
<td>DISPATCH_SOURCE_TYPE_SIGNAL</td>
<td style="text-align:center">接收信号</td>
</tr>
<tr>
<td>DISPATCH_SOURCE_TYPE_TIMER</td>
<td style="text-align:center">定时器</td>
</tr>
<tr>
<td>DISPATCH_SOURCE_TYPE_VNODE</td>
<td style="text-align:center">文件系统有变更</td>
</tr>
<tr>
<td>DISPATCH_SOURCE_TYPE_WRITE</td>
<td style="text-align:center">可写入文件映像</td>
</tr>
</tbody>
</table>
<p> 其中DISPATCH_SOURCE_TYPE_DATA_ADD和DISPATCH_SOURCE_TYPE_DATA_OR是常用的两个，其它用于Mac开发的比较多。</p>
<p> 在任一线程上调用它的的一个函数 dispatch_source_merge_data 后，会执行 Dispatch Source 事先定义好的句柄（可以把句柄简单理解为一个 block ）。</p>
<p>这个过程叫 Custom event ,用户事件。是 dispatch source 支持处理的一种事件。</p>
<p>例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">dispatch_source_t</span> queueSource = dispatch_source_create(DISPATCH_SOURCE_TYPE_DATA_ADD, <span class="number">0</span>, <span class="number">0</span>, dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line"> __block NSUInteger totalComplete = <span class="number">0</span>;</span><br><span class="line">dispatch_source_set_event_handler(queueSource, ^&#123;</span><br><span class="line">    <span class="comment">//当处理事件被最终执行时，计算后的数据可以通过dispatch_source_get_data来获取。</span></span><br><span class="line">    <span class="comment">//这个数据的值在每次响应事件执行后会被重置，所以totalComplete的值是最终累积的值。</span></span><br><span class="line">    NSUInteger value = dispatch_source_get_data(queueSource);</span><br><span class="line">    totalComplete += value;</span><br><span class="line">    NSLog(@<span class="string">"进度：%@"</span>, @((CGFloat)totalComplete/<span class="number">100</span>));</span><br><span class="line">&#125;);</span><br><span class="line">  <span class="comment">/*</span><br><span class="line">  分派源创建时默认处于暂停状态，在分派源分派处理程序之前必须先恢复。</span><br><span class="line">  因为忘记恢复分派源的状态而产生bug是常见的事儿。</span><br><span class="line">  恢复的方法是调用 dispatch_resume :</span><br><span class="line">  */</span></span><br><span class="line"> dispatch_resume(queueSource);</span><br><span class="line"> </span><br><span class="line"> <span class="comment">/*</span><br><span class="line">  在每次循环中执行加1操作。也可以传递已处理记录的数目或已写入的字节数。</span><br><span class="line">  在任何线程中都可以调用 dispatch_source_merge_data 。</span><br><span class="line">  需要注意的是，不可以传递0值(事件不会被触发)，同样也不可以传递负数(会无穷大)。</span><br><span class="line">  */</span></span><br><span class="line"> <span class="keyword">dispatch_queue_t</span> <span class="built_in">queue</span> = dispatch_queue_create(<span class="string">"com.sourcequeue"</span>, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line"> <span class="keyword">for</span> (NSUInteger index = <span class="number">0</span>; index &lt; <span class="number">10</span>; index++) &#123;</span><br><span class="line">     dispatch_async(<span class="built_in">queue</span>, ^&#123;</span><br><span class="line">         dispatch_source_merge_data(queueSource, <span class="number">1</span>);</span><br><span class="line">         [NSThread sleepForTimeInterval:<span class="number">1</span>];</span><br><span class="line">     &#125;);</span><br><span class="line"> &#125;</span><br><span class="line"> NSLog(@<span class="string">"queue for 循环 完成"</span>);</span><br></pre></td></tr></table></figure>
<p>log:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">25</span> <span class="number">09</span>:<span class="number">35</span>:<span class="number">20.128</span> GCDTest[<span class="number">22525</span>:<span class="number">12717227</span>] <span class="built_in">queue</span> <span class="keyword">for</span> 循环 完成</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">25</span> <span class="number">09</span>:<span class="number">35</span>:<span class="number">20.129</span> GCDTest[<span class="number">22525</span>:<span class="number">12718440</span>] 进度：<span class="number">0.3</span></span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">25</span> <span class="number">09</span>:<span class="number">35</span>:<span class="number">20.129</span> GCDTest[<span class="number">22525</span>:<span class="number">12718440</span>] 进度：<span class="number">0.4</span></span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">25</span> <span class="number">09</span>:<span class="number">35</span>:<span class="number">20.129</span> GCDTest[<span class="number">22525</span>:<span class="number">12718440</span>] 进度：<span class="number">0.6</span></span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">25</span> <span class="number">09</span>:<span class="number">35</span>:<span class="number">20.130</span> GCDTest[<span class="number">22525</span>:<span class="number">12718440</span>] 进度：<span class="number">0.9</span></span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">25</span> <span class="number">09</span>:<span class="number">35</span>:<span class="number">20.130</span> GCDTest[<span class="number">22525</span>:<span class="number">12718440</span>] 进度：<span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>可以看到 0.1~1 并没有全部打印，而是跳过：</p>
<p>这是 DispatchSource 能通过合并事件的方式确保在高负载下正常工作 的能力</p>
<p>在同一时间，只有一个处理 block 的实例被分配，如果这个处理方法还没有执行完毕，另一个事件就发生了，事件会以指定方式（ADD或 OR）进行累积。DispatchSource能通过合并事件（block）的方式确保在高负载下正常工作。当处理事件被最终执行时，计算后的数据可以通过 dispatch_source_get_data 来获取。这个数据的值在每次响应时间执行后会被重置，所以上面的例子中进度条 totalComplete 的值是最终积累的值，而 block 不是每次都执行的。但能确保进度条能从0.0到1.0的正常执行。</p>
<h4 id="Dispatch_Semaphore_信号量">Dispatch Semaphore 信号量</h4><p>为了展示作用，举个反例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dispatch_queue_t</span> <span class="built_in">queue</span> = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</span><br><span class="line"> NSMutableArray *<span class="built_in">array</span> = [[NSMutableArray alloc] init];</span><br><span class="line"> <span class="keyword">dispatch_group_t</span> group = dispatch_group_create();</span><br><span class="line"> <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; <span class="number">100000</span>; ++i) &#123;</span><br><span class="line">     dispatch_group_async(group, <span class="built_in">queue</span>, ^&#123;</span><br><span class="line">         [<span class="built_in">array</span> addObject:[NSNumber numberWithInt:i]];</span><br><span class="line">     &#125;);</span><br><span class="line"> &#125;</span><br><span class="line"> dispatch_group_wait(group, DISPATCH_TIME_FOREVER);</span><br><span class="line"> NSLog(@<span class="string">"%@"</span>,  @([<span class="built_in">array</span> count]));</span><br></pre></td></tr></table></figure>
<p>然后就发生了崩溃：</p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">malloc: *** error <span class="keyword">for</span> object <span class="number">0x7f88ed03ca00</span>: pointer being freed was <span class="operator">not</span> allocated</span><br><span class="line">*** <span class="built_in">set</span> <span class="operator">a</span> <span class="built_in">breakpoint</span> <span class="operator">in</span> malloc_error_break <span class="built_in">to</span> debug</span><br></pre></td></tr></table></figure>
<p>这种资源抢夺的情况，一般的做法是使用串行队列，或者像下面一样的同步队列，得以解决：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dispatch_queue_t</span> <span class="built_in">queue</span> = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</span><br><span class="line">NSMutableArray *<span class="built_in">array</span> = [[NSMutableArray alloc] init];</span><br><span class="line"><span class="keyword">dispatch_group_t</span> group = dispatch_group_create();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; <span class="number">1000</span>; ++i) &#123;</span><br><span class="line">    dispatch_sync(<span class="built_in">queue</span>, ^&#123;</span><br><span class="line">        [<span class="built_in">array</span> addObject:[NSNumber numberWithInt:i]];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">dispatch_group_wait(group, DISPATCH_TIME_FOREVER);</span><br><span class="line">NSLog(@<span class="string">"%@"</span>,  @([<span class="built_in">array</span> count]));</span><br></pre></td></tr></table></figure>
<p>dispatch_semaphore_t 的作用之一就是解决这种资源抢夺的情况,下面展示下展示使用 dispatch_semaphore_t 的解决方案：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dispatch_queue_t</span> <span class="built_in">queue</span> = dispatch_queue_create(<span class="string">"com.semaphore"</span>, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line"><span class="keyword">dispatch_semaphore_t</span> semaphore = dispatch_semaphore_create(<span class="number">1</span>);</span><br><span class="line">NSMutableArray *<span class="built_in">array</span> = [[NSMutableArray alloc] init];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">    dispatch_async(<span class="built_in">queue</span>, ^&#123;</span><br><span class="line">        dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</span><br><span class="line">        NSLog(@<span class="string">"🔴%@  index = %d"</span>,[NSThread currentThread],i);</span><br><span class="line">        [<span class="built_in">array</span> addObject:@(i)];</span><br><span class="line">        dispatch_semaphore_signal(semaphore);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">dispatch_barrier_async(<span class="built_in">queue</span>, ^&#123;</span><br><span class="line">    NSLog(@<span class="string">"🔴类名与方法名：%s（在第%d行），描述：%@"</span>, __PRETTY_FUNCTION__, __LINE__, @([<span class="built_in">array</span> count]));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>测试,设置：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dispatch_semaphore_t</span> semaphore = dispatch_semaphore_create(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p>可以发现 程序会永远停留在：</p>
<figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">等待<span class="keyword">Dispatch</span> Semaphore</span><br><span class="line">一直等待，直到<span class="keyword">Dispatch</span> Semaphore的计数值达到大于等于<span class="number">1</span></span><br><span class="line">dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</span><br></pre></td></tr></table></figure>
<p><a href="http://www.cnblogs.com/snailHL/p/3906112.html" target="_blank" rel="external">关于信号量这里有非常详细的解释</a></p>
<p>dispatch_semaphore是GCD用来同步的一种方式，与他相关的共有三个函数，分别是</p>
<p>dispatch_semaphore_create，dispatch_semaphore_signal，dispatch_semaphore_wait。</p>
<p>下面我们逐一介绍三个函数：</p>
<p>①dispatch_semaphore_create的声明为：</p>
<pre><code><span class="keyword">dispatch_semaphore_t</span>  dispatch_semaphore_create(<span class="keyword">long</span> value);

传入的参数为<span class="keyword">long</span>，输出一个<span class="keyword">dispatch_semaphore_t</span>类型且值为value的信号量。

值得注意的是，这里的传入的参数value必须大于或等于<span class="number">0</span>，否则dispatch_semaphore_create会返回<span class="literal">NULL</span>。

（关于信号量，我就不在这里累述了，网上很多介绍这个的。我们这里主要讲一下dispatch_semaphore这三个函数的用法）。
</code></pre><p>②dispatch_semaphore_signal的声明为：</p>
<pre><code><span class="keyword">long</span> dispatch_semaphore_signal(dispatch_semaphore_t dsema)

这个函数会使传入的信号量dsema的值加<span class="number">1</span>；（至于返回值，待会儿再讲）
dispatch_semaphore_signal的返回值为<span class="keyword">long</span>类型，当返回值为<span class="number">0</span>时表示当前并没有线程等待其处理的信号量，其处理

的信号量的值加<span class="number">1</span>即可。当返回值不为<span class="number">0</span>时，表示其当前有（一个或多个）线程等待其处理的信号量，并且该函数唤醒了一

个等待的线程（当线程有优先级时，唤醒优先级最高的线程；否则随机唤醒）。

dispatch_semaphore_wait的返回值也为<span class="keyword">long</span>型。当其返回<span class="number">0</span>时表示在timeout之前，该函数所处的线程被成功唤醒。

当其返回不为<span class="number">0</span>时，表示timeout发生。
</code></pre><p>③dispatch_semaphore_wait的声明为：</p>
<pre><code>long dispatch_semaphore_wait(dispatch_semaphore_t dsema, dispatch_time_t <span class="keyword">timeout</span>)；

这个函数会使传入的信号量dsema的值减<span class="number">1</span>；

这个函数的作用是这样的，如果dsema信号量的值大于<span class="number">0</span>，该函数所处线程就继续执行下面的语句，并且将信号量的值减<span class="number">1</span>；

如果desema的值为<span class="number">0</span>，那么这个函数就阻塞当前线程等待<span class="keyword">timeout</span>（注意<span class="keyword">timeout</span>的类型为dispatch_time_t，

不能直接传入整形或float型数），如果等待的期间desema的值被dispatch_semaphore_signal函数加<span class="number">1</span>了，

且该函数（即dispatch_semaphore_wait）所处线程获得了信号量，那么就继续向下执行并将信号量减<span class="number">1</span>。

如果等待期间没有获取到信号量或者信号量的值一直为<span class="number">0</span>，那么等到<span class="keyword">timeout</span>时，其所处线程自动执行其后语句。
</code></pre><p>关于信号量，这里有一个很形象的解释：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">停车场剩余<span class="number">4</span>个车位，那么即使同时来了四辆车也能停的下。如果此时来了五辆车，那么就有一辆需要等待。</span><br><span class="line">信号量的值就相当于剩余车位的数目，dispatch_semaphore_<span class="built_in">wait</span>函数就相当于来了一辆车，dispatch_semaphore_signal</span><br><span class="line">就相当于走了一辆车。停车位的剩余数目在初始化的时候就已经指明了（dispatch_semaphore_create（long value）），</span><br><span class="line">调用一次dispatch_semaphore_signal，剩余的车位就增加一个；调用一次dispatch_semaphore_<span class="built_in">wait</span>剩余车位就减少一个；</span><br><span class="line">当剩余车位为<span class="number">0</span>时，再来车（即调用dispatch_semaphore_<span class="built_in">wait</span>）就只能等待。有可能同时有几辆车等待一个停车位。有些车主</span><br><span class="line">没有耐心，给自己设定了一段等待时间，这段时间内等不到停车位就走了，如果等到了就开进去停车。而有些车主就像把车停在这，</span><br><span class="line">所以就一直等下去。</span><br></pre></td></tr></table></figure>
<p>本文到此就结束了</p>
<hr>
<p>参考：</p>
<p><a href="https://github.com/ChenYilong/ParseSourceCodeStudy/blob/master/01_Parse的多线程处理思路/Parse的底层多线程处理思路.md" target="_blank" rel="external">Parse源码浅析系列（一）—Parse的底层多线程处理思路：GCD高级用法</a></p>
<p><a href="http://www.cnblogs.com/snailHL/p/3906112.html" target="_blank" rel="external">关于dispatch_semaphore的使用</a></p>
<p><a href="http://tutuge.me/2015/04/03/something-about-gcd/#避免死锁！" target="_blank" rel="external">GCD使用经验与技巧浅谈</a></p>
<p><a href="http://blog.leichunfeng.com/blog/2015/07/29/ios-concurrency-programming-operation-queues/#jtss-tsina" target="_blank" rel="external">iOS 并发编程之 Operation Queues</a></p>
<p><a href="http://www.jianshu.com/p/0b0d9b1f1f19" target="_blank" rel="external">关于iOS多线程，你看我就够了</a></p>
<p><a href="http://www.jianshu.com/p/8ed06312d8bd" target="_blank" rel="external">小笨狼漫谈多线程：NSThread</a></p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2016/08/16/RegularExpression/" itemprop="url">
                iOS 正则表达式
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2016-08-16T21:59:49+08:00" content="2016-08-16">
            2016-08-16
          </time>
        </span>

        

        
          
        
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><h3 id="正则表达式">正则表达式</h3><h5 id="界定符">界定符</h5><p>表示一个正则表达式的开始和结束</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/[<span class="number">0</span>-<span class="number">9</span>]/</span><br></pre></td></tr></table></figure>
<p>在iOS中不加界定符</p>
<h5 id="原子">原子</h5><p>①可见原子<br><br>Unicode 编码表中用键盘输出后可见的字符</p>
<figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-<span class="ruby"> 标点；“<span class="number">_</span>?. 等等</span><br><span class="line"></span>-<span class="ruby"> 英文数字a-z,<span class="constant">A</span>-<span class="constant">Z</span>,<span class="number">0</span>-<span class="number">9</span></span><br><span class="line"></span>-<span class="ruby"> 数理化公式符号</span><br><span class="line"></span>-<span class="ruby"> 其他可见字符</span></span><br></pre></td></tr></table></figure>
<p>②不可见原子<br><br>Unicode 编码表中用键盘输出后不可见的字符</p>
<figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-<span class="ruby"> 换行符\n</span><br><span class="line"></span>-<span class="ruby"> 回车 \r</span><br><span class="line"></span>-<span class="ruby"> 制表符 \t</span><br><span class="line"></span>-<span class="ruby"> 空格</span><br><span class="line"></span>-<span class="ruby"> 其他不可见符号</span></span><br></pre></td></tr></table></figure>
<h5 id="元字符">元字符</h5><p>①原子的筛选方式</p>
<figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-<span class="ruby"> |   匹配两个或者多个分支选择</span><br><span class="line"></span>-<span class="ruby"> []  匹配方括号中的任意一个原子</span><br><span class="line"></span>-<span class="ruby"> [^] 匹配除方括号中的原子之外的任意字符</span></span><br></pre></td></tr></table></figure>
<p>②原子的集合</p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- .  匹配除换行符之外的任意字符</span><br><span class="line">- <span class="command">\d</span> 匹配任意一个十进制数字，即<span class="special">[</span>0-9<span class="special">]</span></span><br><span class="line">- <span class="command">\D</span> 匹配任意一个非十进制数字，即<span class="special">[</span>^0-9<span class="special">]</span></span><br><span class="line">- <span class="command">\s</span> 匹配一个不可见原子，即<span class="special">[</span><span class="command">\f</span><span class="command">\n</span><span class="command">\r</span><span class="command">\t</span><span class="command">\v</span><span class="special">]</span></span><br><span class="line">- <span class="command">\S</span> 匹配一个可见原子，即<span class="special">[</span>^<span class="command">\f</span><span class="command">\n</span><span class="command">\r</span><span class="command">\t</span><span class="command">\v</span><span class="special">]</span></span><br><span class="line">- <span class="command">\w</span> 匹配任意一个数字、字母或下划线，即<span class="special">[</span>0-9a-zA-Z_<span class="special">]</span></span><br><span class="line">- <span class="command">\W</span> 匹配任意一个非数字、字母或下划线，即<span class="special">[</span>^0-9a-zA-Z_<span class="special">]</span></span><br></pre></td></tr></table></figure>
<h5 id="量词">量词</h5><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-<span class="ruby"> &#123;n&#125;   表示其前面的原子恰好出现 n 次</span><br><span class="line"></span>-<span class="ruby"> &#123;n,&#125;  表示其前面的原子至少出现 n 次</span><br><span class="line"></span>-<span class="ruby"> &#123;n,m&#125; 表示其前面的原子恰好出现 n 次，最多出现m次</span><br><span class="line"></span>-<span class="ruby"> *     匹配<span class="number">0</span>次、<span class="number">1</span>次或者多次其之前的原子，即&#123;<span class="number">0</span>,&#125; </span><br><span class="line"></span>-<span class="ruby"> +     匹配一次或者多次其之前的原子，即&#123;<span class="number">1</span>,&#125;</span><br><span class="line"></span>-<span class="ruby"> ?     匹配<span class="number">0</span>次或者<span class="number">1</span>次其之前的原子，即&#123;<span class="number">0</span>,<span class="number">1</span>&#125;</span></span><br></pre></td></tr></table></figure>
<h5 id="边界控制与模式单元">边界控制与模式单元</h5><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-<span class="ruby"> ^  匹配字符串开始的位置</span><br><span class="line"></span>-<span class="ruby"> <span class="variable">$ </span> 匹配字符串结尾的位置</span><br><span class="line"></span>-<span class="ruby"> () 匹配其中的整体为一个原子</span></span><br></pre></td></tr></table></figure>
<h5 id="修正模式">修正模式</h5><p>常见的修正模式</p>
<figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-<span class="ruby"> <span class="constant">U</span> 懒惰匹配</span><br><span class="line"></span>-<span class="ruby"> i 忽略英文字母大小写</span><br><span class="line"></span>-<span class="ruby"> x 忽略空白</span><br><span class="line"></span>-<span class="ruby"> s 让元字符 <span class="string">` . `</span> 匹配包括换行符在内所有字符</span><br><span class="line"></span>-<span class="ruby"> e iOS 暂未知</span></span><br></pre></td></tr></table></figure>
<hr>
<p>好以上是正则的简单介绍，详细请看这个：<a href="http://www.jb51.net/tools/zhengze.html" target="_blank" rel="external">正则表达式30分钟入门教程</a></p>
<h3 id="iOS_正则表达式">iOS 正则表达式</h3><p>服务器每次返回的时间格式是这个样子的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2016</span>-<span class="number">08</span>-<span class="number">13</span>T13:<span class="number">06</span>:<span class="number">48</span>Z</span><br></pre></td></tr></table></figure>
<p>显示的时候只要年月日 或者是时分秒：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2016</span>-<span class="number">08</span>-<span class="number">13</span></span><br><span class="line"><span class="number">13</span>:<span class="number">06</span>:<span class="number">48</span></span><br></pre></td></tr></table></figure>
<p>这里常用的有两种方法<br></p>
<ol>
<li>使用 NSDateFormatter 格式化，来解析这时间格式的字符串，转换成 NSDate 格式，然后在格式化一次转换成相应的格式（这种方法感觉很蛋疼，折腾了两次）；<br></li>
<li>使用 NSString 分割方法:</li>
</ol>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">-</span> (<span class="tag">NSArray</span>&lt;<span class="tag">NSString</span> *&gt; *)<span class="rule"><span class="attribute">componentsSeparatedByString</span>:<span class="value">(NSString *)separator</span></span>;</span><br></pre></td></tr></table></figure>
<p>以 “T” 进行分割，最终得出自己想要的字符串；</p>
<hr>
<p>这两种方法是常用的方法，但是用起来总感觉不爽，后来想想还可以用 正则表达式，那就试试</p>
<h3 id="使用正则表达式来解析这个时间格式">使用正则表达式来解析这个时间格式</h3><p>在iOS中通常使用 “NSRegularExpression” 进行字符串匹配，一般是这个样子：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">     <span class="built_in">NSString</span> *string = <span class="string">@"字符串xxxx"</span>;</span><br><span class="line">     <span class="built_in">NSString</span> *regexString = <span class="string">@"正则表达式"</span>;</span><br><span class="line">     <span class="built_in">NSRegularExpression</span> *regex = [<span class="built_in">NSRegularExpression</span> regularExpressionWithPattern:regexString options:<span class="built_in">NSRegularExpressionCaseInsensitive</span> error:<span class="literal">nil</span>];</span><br><span class="line">     <span class="built_in">NSArray</span> *matches = [regex matchesInString:string options:<span class="built_in">NSMatchingReportProgress</span> range:<span class="built_in">NSMakeRange</span>(<span class="number">0</span>, string<span class="variable">.length</span>)];</span><br><span class="line">     <span class="keyword">for</span> (<span class="built_in">NSTextCheckingResult</span> *match <span class="keyword">in</span> matches) &#123;</span><br><span class="line"><span class="comment">// do something...</span></span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>下面我们来写这个正则来匹配出  年月日 和 时分秒。具体的正则写法请自行Google，不过我在这里介绍一个好网站<a href="https://regexper.com" target="_blank" rel="external">regexper</a>可以分析你写的正则表达式；匹配时间的正则我已经写好了：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^(\\d&#123;<span class="number">4</span>&#125;-\\d&#123;<span class="number">1</span>,<span class="number">2</span>&#125;-\\d&#123;<span class="number">1</span>,<span class="number">2</span>&#125;)T(\\d&#123;<span class="number">1</span>,<span class="number">2</span>&#125;:\\d&#123;<span class="number">1</span>,<span class="number">2</span>&#125;:\\d&#123;<span class="number">1</span>,<span class="number">2</span>&#125;)Z$</span><br></pre></td></tr></table></figure>
<p>在正则表达式中 有group之分，看上面的正则：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">group<span class="preprocessor">#<span class="number">1</span>:</span></span><br><span class="line">(\\d&#123;<span class="number">4</span>&#125;-\\d&#123;<span class="number">1</span>,<span class="number">2</span>&#125;-\\d&#123;<span class="number">1</span>,<span class="number">2</span>&#125;)</span><br><span class="line">group<span class="preprocessor">#<span class="number">2</span>:</span></span><br><span class="line">(\\d&#123;<span class="number">1</span>,<span class="number">2</span>&#125;:\\d&#123;<span class="number">1</span>,<span class="number">2</span>&#125;:\\d&#123;<span class="number">1</span>,<span class="number">2</span>&#125;)</span><br></pre></td></tr></table></figure>
<p>group#1 匹配的是年月日，group#2匹配的是时分秒，正则匹配之后，我们是可以分别取出这两个group匹配出来的值的；在iOS中“NSRegularExpression”类，也是有的；下面是匹配：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *string = <span class="string">@"2016-08-13T13:06:48Z"</span>;</span><br><span class="line"><span class="built_in">NSString</span> *regexString = <span class="string">@"^(\\d&#123;4&#125;-\\d&#123;1,2&#125;-\\d&#123;1,2&#125;)T(\\d&#123;1,2&#125;:\\d&#123;1,2&#125;:\\d&#123;1,2&#125;)Z$"</span>;</span><br><span class="line"><span class="built_in">NSRegularExpression</span> *regex = [<span class="built_in">NSRegularExpression</span> regularExpressionWithPattern:regexString options:<span class="built_in">NSRegularExpressionCaseInsensitive</span> error:<span class="literal">nil</span>];</span><br><span class="line"><span class="built_in">NSArray</span> *matches = [regex matchesInString:string options:<span class="built_in">NSMatchingReportProgress</span> range:<span class="built_in">NSMakeRange</span>(<span class="number">0</span>, string<span class="variable">.length</span>)];</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">NSTextCheckingResult</span> *match <span class="keyword">in</span> matches) &#123;</span><br><span class="line">    <span class="built_in">NSString</span>* group0 = [string substringWithRange:[match rangeAtIndex:<span class="number">0</span>]];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"group0 :%@"</span>, group0);</span><br><span class="line">    <span class="built_in">NSString</span>* group1 = [string substringWithRange:[match rangeAtIndex:<span class="number">1</span>]];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"group1 :%@"</span>, group1);</span><br><span class="line">    <span class="built_in">NSString</span>* group2 = [string substringWithRange:[match rangeAtIndex:<span class="number">2</span>]];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"group2 :%@"</span>, group2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用正则匹配出来之后，NSTextCheckingResult 中 使用 “[match rangeAtIndex:xxx]” 可以取出来。在这里NSTextCheckingResult 中 ：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">NSTextCheckingResult 类属性numberOfRanges 为<span class="number">3</span></span><br><span class="line">[match rangeAtIndex:<span class="number">0</span>] 匹配的是全量即：<span class="number">2016</span>-<span class="number">08</span>-<span class="number">13</span>T13:<span class="number">06</span>:<span class="number">48</span>Z</span><br><span class="line">[match rangeAtIndex:<span class="number">1</span>] 匹配的是：<span class="number">2016</span>-<span class="number">08</span>-<span class="number">13</span></span><br><span class="line">[match rangeAtIndex:<span class="number">2</span>] 匹配的是：<span class="number">13</span>:<span class="number">06</span>:<span class="number">48</span></span><br></pre></td></tr></table></figure>
<p>这下处理不就简单了许多。</p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2016/06/30/CATransition/" itemprop="url">
                CATransition 转场动画
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2016-06-30T07:39:42+08:00" content="2016-06-30">
            2016-06-30
          </time>
        </span>

        

        
          
        
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><h3 id="CATransition_转场动画">CATransition 转场动画</h3><p>转场动画就是从一个场景以动画的形式过渡到另一个场景，navigation的push就是一种转场方式（后面会介绍如何自定义）。<br>转场动画一般分为这几个步骤：<br>(1)初始化转场动画<br>(2)设置转场类型属性等<br>(3)设置转场后的新视图并添加动画到图层<br>下表列出了常用的转场类型(注意私有API是苹果官方没有公开的动画类型，但是目前通过仍然可以使用)：</p>
<h5 id="公开API">公开API</h5><table>
<thead>
<tr>
<th style="text-align:left">动画类型</th>
<th style="text-align:right">说明</th>
<th style="text-align:center">对应常量</th>
<th>是否支持方向设置</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">fade</td>
<td style="text-align:right">淡出效果</td>
<td style="text-align:center">kCATransitionFade</td>
<td>是</td>
</tr>
<tr>
<td style="text-align:left">movein</td>
<td style="text-align:right">新视图移动到旧视图上</td>
<td style="text-align:center">kCATransitionMoveIn</td>
<td>是</td>
</tr>
<tr>
<td style="text-align:left">push</td>
<td style="text-align:right">新视图推出旧视图</td>
<td style="text-align:center">kCATransitionPush</td>
<td>是</td>
</tr>
<tr>
<td style="text-align:left">reveal</td>
<td style="text-align:right">移开旧视图显示新视图</td>
<td style="text-align:center">kCATransitionReveal</td>
<td>是</td>
</tr>
</tbody>
</table>
<h5 id="私有API———-私有API只能通过字符串访问">私有API———-私有API只能通过字符串访问</h5><table>
<thead>
<tr>
<th style="text-align:left">动画类型</th>
<th style="text-align:right">说明</th>
<th style="text-align:center">对应常量</th>
<th>是否支持方向设置</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">cube</td>
<td style="text-align:right">立方体翻转效果</td>
<td style="text-align:center">无</td>
<td>是</td>
</tr>
<tr>
<td style="text-align:left">oglFlip</td>
<td style="text-align:right">翻转效果</td>
<td style="text-align:center">无</td>
<td>是</td>
</tr>
<tr>
<td style="text-align:left">suckEffect</td>
<td style="text-align:right">收缩效果</td>
<td style="text-align:center">无</td>
<td>否</td>
</tr>
<tr>
<td style="text-align:left">rippleEffect</td>
<td style="text-align:right">水滴波纹效果</td>
<td style="text-align:center">无</td>
<td>否</td>
</tr>
<tr>
<td style="text-align:left">pageCurl</td>
<td style="text-align:right">向上翻页效果</td>
<td style="text-align:center">无</td>
<td>是</td>
</tr>
<tr>
<td style="text-align:left">pageUnCurl</td>
<td style="text-align:right">向下翻页效果</td>
<td style="text-align:center">无</td>
<td>是</td>
</tr>
<tr>
<td style="text-align:left">cameralIrisHollowOpen</td>
<td style="text-align:right">摄像头打开效果</td>
<td style="text-align:center">无</td>
<td>否</td>
</tr>
<tr>
<td style="text-align:left">cameraIrisHollowClose</td>
<td style="text-align:right">摄像头关闭效果</td>
<td style="text-align:center">无</td>
<td>否</td>
</tr>
</tbody>
</table>
<h5 id="另外对于支持方向设置的动画类型还包含子类型">另外对于支持方向设置的动画类型还包含子类型</h5><table>
<thead>
<tr>
<th style="text-align:left">动画子类型</th>
<th style="text-align:right">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">kCATransitionFromRight</td>
<td style="text-align:right">从右侧转场</td>
</tr>
<tr>
<td style="text-align:left">kCATransitionFromLeft</td>
<td style="text-align:right">从左侧转场</td>
</tr>
<tr>
<td style="text-align:left">kCATransitionFromTop</td>
<td style="text-align:right">从顶部转场</td>
</tr>
<tr>
<td style="text-align:left">kCATransitionFromBottom</td>
<td style="text-align:right">从底部转场</td>
</tr>
</tbody>
</table>
<p>下面是一个小例子：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CATransition</span> *transition = [<span class="built_in">CATransition</span> animation];</span><br><span class="line">transition<span class="variable">.duration</span> = <span class="number">1.0</span>f;</span><br><span class="line">transition<span class="variable">.type</span> = <span class="string">@"cube"</span>;</span><br><span class="line"></span><br><span class="line">transition<span class="variable">.subtype</span> = k<span class="built_in">CATransitionFromRight</span>;</span><br><span class="line"><span class="built_in">UIView</span> *cubeView = [[<span class="built_in">UIView</span> alloc] initWithFrame:<span class="built_in">CGRectMake</span>(<span class="number">100</span>, <span class="number">100</span>, <span class="number">200</span>, <span class="number">300</span>)];</span><br><span class="line">cubeView<span class="variable">.backgroundColor</span> = [<span class="built_in">UIColor</span> cyanColor];</span><br><span class="line">[<span class="keyword">self</span><span class="variable">.view</span><span class="variable">.layer</span> addAnimation:transition forKey:<span class="string">@"cubeView"</span>];</span><br><span class="line">[<span class="keyword">self</span><span class="variable">.view</span> addSubview:cubeView];</span><br></pre></td></tr></table></figure>
<h4 id="感谢一下博客">感谢一下博客</h4><p><a href="http://www.cnblogs.com/kenshincui/p/3972100.html#autoid-3-3-0" target="_blank" rel="external">http://www.cnblogs.com/kenshincui/p/3972100.html#autoid-3-3-0</a></p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2016/06/30/CAKeyframeAnimation/" itemprop="url">
                CAKeyframeAnimation 关键帧动画
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2016-06-30T07:34:33+08:00" content="2016-06-30">
            2016-06-30
          </time>
        </span>

        

        
          
        
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><p>CAKeyframeAnimation（关键帧动画）<br><br>      关键帧动画就是在动画控制过程中开发者指定主要的动画状态，至于各个状态间动画如何进行则由系统自动运算补充（每两个关键帧之间系统形成的动画称为“补间动画”），这种动画的好处就是开发者不用逐个控制每个动画帧，而只要关心几个关键帧的状态即可。<br>      关键帧动画开发分为两种形式：一种是通过设置不同的属性值进行关键帧控制，另一种是通过绘制路径进行关键帧控制。后者优先级高于前者，如果设置了路径则属性值就不再起作用。</p>
<p>看下面的代码，简单的用法：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CAKeyframeAnimation</span> *keyAnimation = [<span class="built_in">CAKeyframeAnimation</span> animationWithKeyPath:@“position”];</span><br><span class="line"><span class="comment">//设置关键点</span></span><br><span class="line"><span class="built_in">NSValue</span> *key1 = [<span class="built_in">NSValue</span> valueWith<span class="built_in">CGPoint</span>:_layer<span class="variable">.position</span>];</span><br><span class="line"><span class="built_in">NSValue</span> *key2 = [<span class="built_in">NSValue</span> valueWith<span class="built_in">CGPoint</span>:<span class="built_in">CGPointMake</span>(<span class="number">300</span>, <span class="number">220</span>)];</span><br><span class="line"><span class="built_in">NSValue</span> *key3 = [<span class="built_in">NSValue</span> valueWith<span class="built_in">CGPoint</span>:<span class="built_in">CGPointMake</span>(<span class="number">100</span>, <span class="number">300</span>)];</span><br><span class="line"><span class="built_in">NSValue</span> *key4 = [<span class="built_in">NSValue</span> valueWith<span class="built_in">CGPoint</span>:<span class="built_in">CGPointMake</span>(<span class="number">300</span>, <span class="number">400</span>)];</span><br><span class="line">keyAnimation<span class="variable">.duration</span> = <span class="number">5.0</span>f;</span><br><span class="line">[<span class="keyword">self</span><span class="variable">.layer</span> addAnimation:keyAnimation forKey:<span class="string">@"key"</span>];</span><br></pre></td></tr></table></figure>
<p>当然页可以换成路径：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//2.设置路径</span></span><br><span class="line"><span class="comment">//绘制贝塞尔曲线</span></span><br><span class="line">CGMutablePathRef path = CGPathCreateMutable();</span><br><span class="line"><span class="comment">//移动到起始点</span></span><br><span class="line">CGPathMoveToPoint(path, <span class="literal">NULL</span>, _layer.position.x, _layer.position.y);</span><br><span class="line"><span class="comment">//绘制二次贝塞尔曲线</span></span><br><span class="line">CGPathAddCurveToPoint(path, <span class="literal">NULL</span>, <span class="number">160</span>, <span class="number">280</span>, -<span class="number">30</span>, <span class="number">300</span>, <span class="number">55</span>, <span class="number">400</span>);</span><br><span class="line"><span class="comment">//设置path属性</span></span><br><span class="line">keyAnimation.path=path;</span><br><span class="line"><span class="comment">//释放路径对象</span></span><br><span class="line">CGPathRelease(path);</span><br></pre></td></tr></table></figure>
<p>(1) values属性<br>        values属性指明整个动画过程中的关键帧点，例如上例中的key1-key2就是通过values指定的。需要注意的是，起点必须作为values的第一个值。</p>
<p>(2)path属性<br>        作用与values属性一样，同样是用于指定整个动画所经过的路径的。需要注意的是，values与path是互斥的，当values与path同时指定时，path会覆盖values，即values属性将被忽略。</p>
<p>(3)keyTimes<br>     keyTimes：各个关键帧的时间控制，如果你没有显式地对keyTimes进行设置，则系统会默认每条子路径的时间为：ti=duration/(5-1)，即每条子路径的duration相等，都为duration的1\4。当然，我们也可以传个数组让物体快慢结合。前面使用values设置了四个关键帧，默认情况下每两帧之间的间隔为:8/(4-1)秒。如果想要控制动画从第一帧到第二针占用时间4秒，从第二帧到第三帧时间为2秒，而从第三帧到第四帧时间2秒的话，就可以通过keyTimes进行设置。keyTimes中存储的是时间占用比例点，此时可以设置keyTimes的值为0.0，0.5，0.75，1.0（当然必须转换为NSNumber，其中首尾必须分别是0和1），也就是说1到2帧运行到总时间的50%，2到3帧运行到总时间的75%，3到4帧运行到8秒结束。</p>
<figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">keyAnimation.keyTimes = <span class="variable">@[</span><span class="variable">@(</span><span class="number">0</span>),<span class="variable">@(</span><span class="number">0.3</span>),<span class="variable">@(</span><span class="number">0.8</span>),<span class="variable">@(</span><span class="number">1</span>)];</span><br></pre></td></tr></table></figure>
<p>(3) calculationMode属性</p>
<table>
<thead>
<tr>
<th>calculationMode keys</th>
<th>说明                                                                                                                                       </th>
</tr>
</thead>
<tbody>
<tr>
<td>kCAAnimationLinear</td>
<td>calculationMode的默认值,表示当关键帧为座标点的时候,关键帧之间直接直线相连进行插值计算;                                                                                                                                   </td>
</tr>
<tr>
<td>kCAAnimationDiscrete</td>
<td>离散的,就是不进行插值计算,所有关键帧直接逐个进行显示;                                                                                                                                    </td>
</tr>
<tr>
<td>kCAAnimationPaced</td>
<td>使得动画均匀进行,而不是按keyTimes设置的或者按关键帧平分时间,此时keyTimes和timingFunctions无效;   </td>
</tr>
<tr>
<td>kCAAnimationCubic</td>
<td>对关键帧为座标点的关键帧进行圆滑曲线相连后插值计算,对于曲线的形状还可以通过tensionValues,continuityValues,biasValues来进行调整自定义,这里的数学原理是Kochanek–Bartels spline,这里的主要目的是使得运行的轨迹变得圆滑;</td>
</tr>
<tr>
<td>kCAAnimationCubicPaced</td>
<td>看这个名字就知道和kCAAnimationCubic有一定联系,其实就是在kCAAnimationCubic的基础上使得动画运行变得均匀,就是系统时间内运动的距离相同,此时keyTimes以及timingFunctions也是无效的.      </td>
</tr>
</tbody>
</table>
<h5 id="感谢一下博客：">感谢一下博客：</h5><p><a href="http://www.cnblogs.com/kenshincui/p/3972100.html#autoid-3-1-0" target="_blank" rel="external">http://www.cnblogs.com/kenshincui/p/3972100.html#autoid-3-1-0</a><br><br><a href="http://www.cnblogs.com/wengzilin/p/4256468.html" target="_blank" rel="external">http://www.cnblogs.com/wengzilin/p/4256468.html</a><br><br><a href="http://blog.jobbole.com/69111/" target="_blank" rel="external">http://blog.jobbole.com/69111/</a></p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2016/06/30/Core-Animation/" itemprop="url">
                Core Animation 基础知识
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2016-06-30T07:18:00+08:00" content="2016-06-30">
            2016-06-30
          </time>
        </span>

        

        
          
        
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><h5 id="一、简介">一、简介</h5><p>CAAnimation的一些基础的知识，复习备用</p>
<h5 id="二、使用步骤">二、使用步骤</h5><p>1.使用它需要先添加QuartzCore.framework框架和引入主头文件 QuartzCore/QuartzCore.h (Xcode 6 不需要);</p>
<p>2.初始化一个CAAnimation对象，设置相应的属性;</p>
<p>3.通过调用CALayer的addAnimation:forKey:方法增加CAAnimation对象到CALayer中，这样就能开始执行动画了;</p>
<p>4.通过调用CALayer的removeAnimationForKey:方法可以停止CALayer中的动画.</p>
<hr>
<h5 id="三、CAAnimation_继承关系与核心类">三、CAAnimation 继承关系与核心类</h5><p>一般情况下，我们使用的是CAAnimation的子类(CABasicAnimation、CAKeyframeAnimation、CAAnimationGroup、CATransition)</p>
<p><img src="http://img.blog.csdn.net/20150706193857613" alt="CAAnimation classes"></p>
<p>CAAnimation：核心动画的基础类，不能直接使用，负责动画运行时间、速度的控制，本身实现了CAMediaTiming协议;</p>
<p>CAPropertyAnimation：属性动画的基类（通过属性进行动画设置，注意是可动画属性），不能直接使用;</p>
<p>CAAnimationGroup：动画组，动画组是一种组合模式设计，可以通过动画组来进行所有动画行为的统一控制，组中所有动画效果可以并发执行;<br>CATransition：转场动画，主要通过滤镜进行动画效果设置;<br>CABasicAnimation：基础动画，通过属性修改进行动画参数控制，只有初始状态和结束状态;<br>CAKeyframeAnimation：关键帧动画，同样是通过属性进行动画参数控制，但是同基础动画不同的是它可以有多个状态控制;</p>
<p>基础动画、关键帧动画都属于属性动画，就是通过修改属性值产生动画效果，开发人员只需要设置初始值和结束值，中间的过程动画（又叫“补间动画”）由系统自动计算产生。和基础动画不同的是关键帧动画可以设置多个属性值，每两个属性中间的补间动画由系统自动完成，因此从这个角度而言基础动画又可以看成是有两个关键帧的关键帧动画。</p>
<hr>
<h5 id="四、常用属性">四、常用属性</h5><p>1.duration:它设定开始值到结束值花费的时间。期间会被速度的属性所影响;<br><br>2.speed:默认的值为 1.0.这意味着动画播放按照默认的速度。如果你改变这个值为 2.0,动画会用 2 倍的速度播放。这样的影响就是使持续时间减半。如果你指定的持续时间为6秒,速度为2.0,动画就会播放 3 秒钟,一半的 持续时间;<br><br>3.removedOnCompletion:这个属性默认为 YES,那意味着,在指定的时间段完成后,动画就自动的从层上移除了。这个一般不用。假如你想要再次用这个动画时,你需要设定这个属性为 NO。这样的话,下次你在通过-set 方法设定动画的属性时,它将再次使用你的动画,而非默认的动画;<br><br>4.fillMode:fillMode的作用就是决定当前对象过了非active时间段的行为. 比如动画开始之前,动画结束之后。如果是一个动画CAAnimation,则需要将其removedOnCompletion设置为NO,要不然fillMode不起作用. 下面来讲各个fillMode的意义:<br></p>
<ul>
<li>kCAFillModeRemoved 这个是默认值,也就是说当动画开始前和动画结束后,动画对layer都没有影响,动画结束后,layer会恢复到之前的状态;<br></li>
<li>kCAFillModeForwards 当动画结束后,layer会一直保持着动画最后的状态;<br></li>
<li>kCAFillModeBackwards 这个和kCAFillModeForwards是相对的,就是在动画开始前,你只要将动画加入了一个layer,layer便立即进入动画的初始状态并等待动画开始.你可以这样设定测试代码,将一个动画加入一个layer的时候延迟5秒执行.然后就会发现在动画没有开始的时候,只要动画被加入了layer,layer便处于动画初始状态;<br></li>
<li>kCAFillModeBoth 理解了上面两个,这个就很好理解了,这个其实就是上面两个的合成.动画加入后开始之前,layer便处于动画初始状态,动画结束后layer保持动画最后的状态;<br><br>5.timingFunction可选的值有：<ul>
<li>kCAMediaTimingFunctionLinear（线性）：匀速，给你一个相对静态的感觉</li>
<li>kCAMediaTimingFunctionEaseIn（渐进）：动画缓慢进入，然后加速离开</li>
<li>kCAMediaTimingFunctionEaseOut（渐出）：动画全速进入，然后减速的到达目的地</li>
<li>kCAMediaTimingFunctionEaseInEaseOut（渐进渐出）：动画缓慢的进入，中间加速，然后减速的到达目的地。这个是默认的动画行为.</li>
</ul>
</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">baseAnimation<span class="variable">.timingFunction</span> = [<span class="built_in">CAMediaTimingFunction</span> functionWithName:k<span class="built_in">CAMediaTimingFunctionEaseOut</span>];</span><br></pre></td></tr></table></figure>
<p>6.autoreverses:当你设定这个属性为 YES 时,在它到达目的地之后,再原路返回开始值。<br><br>7.timeOffset:动画从偏移的地方开始动画，但结束的地方是偏移的地方<br><br>8.repeatCount:默认的是 0,意味着动画只会播放一次。如果指定一个无限大的重复次数,使用 1e100f。这个不能和repeatDration属性一块使用。<br></p>
<p>9.repeatDuration:这个属性指定了动画应该被重复多久。动画会一直重复,直到设定的时间流逝完。它不能和repeatCount一起使用。<br><br>10.additive:这个属性根据当前的渲染层的值加上value生成新的渲染的值，也就是动画时present layer的值。</p>
<p><a href="http://blog.csdn.net/growinggiant/article/details/45535587" target="_blank" rel="external">下边的代码的动画效果是一样的，对比下values会有个明确的认识：</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)change</span><br><span class="line">&#123;</span><br><span class="line">    CAKeyframeAnimation* animation = [CAKeyframeAnimation animationWithKeyPath:@<span class="string">"position.x"</span>];</span><br><span class="line">    animation.values = @[@<span class="number">0</span>,@<span class="number">100</span>,@(-<span class="number">100</span>),@<span class="number">100</span>,@<span class="number">0</span>];</span><br><span class="line">    animation.keyTimes = @[@<span class="number">0</span>,@(<span class="number">1</span>/<span class="number">6.</span>),@(<span class="number">3</span>/<span class="number">6.</span>),@(<span class="number">5</span>/<span class="number">6.</span>),@<span class="number">1</span>];</span><br><span class="line">    animation.duration = <span class="number">2.f</span>;</span><br><span class="line">    animation.additive = YES; <span class="comment">//YES把更改的值追加到当前的present层中 keypath+=value ，NO是把更改的值设置成当前present层的值keypath = value</span></span><br><span class="line">    [self.ly.layer addAnimation:animation forKey:@<span class="string">"shaking"</span>];</span><br><span class="line">    ---------</span><br><span class="line">	CAKeyframeAnimation* animation1 = [CAKeyframeAnimation animationWithKeyPath:@<span class="string">"position.x"</span>];</span><br><span class="line">    animation1.values = @[@(self.ly1.center.x),@(self.ly1.center.x + <span class="number">100</span>),@(self.ly1.center.x - <span class="number">100</span>),@(self.ly1.center.x + <span class="number">100</span>),@(self.ly1.center.x)];</span><br><span class="line">    animation1.keyTimes = @[@<span class="number">0</span>,@(<span class="number">1</span>/<span class="number">6.</span>),@(<span class="number">3</span>/<span class="number">6.</span>),@(<span class="number">5</span>/<span class="number">6.</span>),@<span class="number">1</span>];</span><br><span class="line">    animation1.duration = <span class="number">2.f</span>;</span><br><span class="line">    animation1.additive = NO; <span class="comment">//YES把更改的值追加到当前的model层中 keypath+=value ，NO是把更改的值设置成当前present层的值keypath = value</span></span><br><span class="line">    [self.ly1.layer addAnimation:animation1 forKey:@<span class="string">"shaking"</span>];</span><br><span class="line">    [button animateWithType:arc4random()%<span class="number">3</span>];</span><br><span class="line">    [self performSelector:@selector(change) withObject:nil afterDelay:<span class="number">3.f</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>11.<a href="http://geeklu.com/2012/09/animation-in-ios/" target="_blank" rel="external">beginTime</a><br>无论是图层还是动画,都有一个时间线Timeline的概念,他们的beginTime是相对于父级对象的开始时间. 虽然苹果的文档中没有指明,但是通过代码测试可以发现,默认情况下所有的CALayer图层的时间线都是一致的,他们的beginTime都是0,绝对时间转换到当前Layer中的时间大小就是绝对时间的大小.所以对于图层而言,虽然创建有先后,但是他们的时间线都是一致的(只要不主动去修改某个图层的beginTime),所以我们可以想象成所有的图层默认都是从系统重启后开始了他们的时间线的计时.</p>
<p>但是动画的时间线的情况就不同了,当一个动画创建好,被加入到某个Layer的时候,会先被拷贝一份出来用于加入当前的图层,在CA事务被提交的时候,如果图层中的动画的beginTime为0,则beginTime会被设定为当前图层的当前时间,使得动画立即开始.如果你想某个直接加入图层的动画稍后执行,可以通过手动设置这个动画的beginTime,但需要注意的是这个beginTime需要为 CACurrentMediaTime()+延迟的秒数,因为beginTime是指其父级对象的时间线上的某个时间,这个时候动画的父级对象为加入的这个图层,图层当前的时间其实为[layer convertTime:CACurrentMediaTime() fromLayer:nil],其实就等于CACurrentMediaTime(),那么再在这个layer的时间线上往后延迟一定的秒数便得到上面的那个结果.</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">baseAnimation.beginTime </span>= CACurrentMediaTime() + <span class="number">1</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>12.delegate：动画代理，用来监听动画的执行过程</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSObject</span> (<span class="title">CAAnimationDelegate</span>)</span></span><br><span class="line"><span class="comment">// 动画开始执行的时候触发这个方法</span></span><br><span class="line">- (<span class="keyword">void</span>)animationDidStart:(<span class="built_in">CAAnimation</span> *)anim;</span><br><span class="line"><span class="comment">// 动画执行完毕的时候触发这个方法</span></span><br><span class="line">- (<span class="keyword">void</span>)animationDidStop:(<span class="built_in">CAAnimation</span> *)anim finished:(<span class="built_in">BOOL</span>)flag;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>以上是做动画时常用的属性（当然也包括不常用的）；</p>
<h5 id="五、动画类">五、动画类</h5><p>1.CABasicAnimation<br>下面是一些简单的使用方法（看一眼就OK了）：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CABasicAnimation</span> *baseAnimation = [<span class="built_in">CABasicAnimation</span> animationWithKeyPath:<span class="string">@"position"</span>];</span><br><span class="line">baseAnimation<span class="variable">.delegate</span> = <span class="keyword">self</span>;</span><br><span class="line">baseAnimation<span class="variable">.toValue</span> = [<span class="built_in">NSValue</span> valueWith<span class="built_in">CGPoint</span>:<span class="built_in">CGPointMake</span>(<span class="number">150</span>, <span class="number">450</span>)];</span><br><span class="line">baseAnimation<span class="variable">.duration</span> = <span class="number">5.0</span>f;</span><br><span class="line">baseAnimation<span class="variable">.removedOnCompletion</span> = <span class="literal">NO</span>;</span><br><span class="line">baseAnimation<span class="variable">.speed</span> = <span class="number">2.0</span>f;</span><br><span class="line">baseAnimation<span class="variable">.fillMode</span> = k<span class="built_in">CAFillModeForwards</span>;</span><br><span class="line">baseAnimation<span class="variable">.timingFunction</span> = [<span class="built_in">CAMediaTimingFunction</span> functionWithName:k<span class="built_in">CAMediaTimingFunctionEaseOut</span>];</span><br><span class="line">[<span class="keyword">self</span><span class="variable">.layer</span> addAnimation:baseAnimation forKey:<span class="string">@"haha"</span>];</span><br></pre></td></tr></table></figure>
<p>CABasicAnimation 中使用比较多的是KeyPath，下面列出了一些（当然可以通过Xcode 帮助文档搜索“animatable properties“）<br><img src="http://img.blog.csdn.net/20150707111318433" alt="keyPath"></p>
<p>2.CAAnimationGroup<br>GroupAnimation可以实现多种动画的组合，在GroupAnimation中的各个动画类型是同时进行的。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//缩放动画</span></span><br><span class="line"><span class="built_in">CABasicAnimation</span> *scale = [<span class="built_in">CABasicAnimation</span> animationWithKeyPath:<span class="string">@"transform"</span>];</span><br><span class="line">scale<span class="variable">.fromValue</span> = [<span class="built_in">NSValue</span> valueWith<span class="built_in">CATransform3D</span>:<span class="built_in">CATransform3DIdentity</span>];</span><br><span class="line">scale<span class="variable">.toValue</span>   = [<span class="built_in">NSValue</span> valueWith<span class="built_in">CATransform3D</span>:<span class="built_in">CATransform3DMakeScale</span>(<span class="number">0.1</span>, <span class="number">0.1</span>, <span class="number">1</span>)];</span><br><span class="line"></span><br><span class="line"><span class="comment">//平移</span></span><br><span class="line"><span class="built_in">CABasicAnimation</span> *position = [<span class="built_in">CABasicAnimation</span> animationWithKeyPath:<span class="string">@"position"</span>];</span><br><span class="line">position<span class="variable">.toValue</span> = [<span class="built_in">NSValue</span> valueWith<span class="built_in">CGPoint</span>:<span class="built_in">CGPointMake</span>(<span class="number">150</span>, <span class="number">450</span>)];</span><br><span class="line"></span><br><span class="line"><span class="comment">//旋转</span></span><br><span class="line"><span class="built_in">CABasicAnimation</span> *rotation = [<span class="built_in">CABasicAnimation</span> animationWithKeyPath:<span class="string">@"transform.rotation.z"</span>];</span><br><span class="line">rotation<span class="variable">.toValue</span> = [<span class="built_in">NSNumber</span> numberWithFloat:M_PI_2];</span><br><span class="line"></span><br><span class="line"><span class="built_in">CAAnimationGroup</span> *group = [<span class="built_in">CAAnimationGroup</span> animation];</span><br><span class="line">group<span class="variable">.duration</span> = <span class="number">5</span>;</span><br><span class="line">group<span class="variable">.speed</span>    = <span class="number">1</span>;</span><br><span class="line">group<span class="variable">.animations</span> = @[scale,rotation,position];</span><br><span class="line">group<span class="variable">.removedOnCompletion</span> = <span class="literal">NO</span>;</span><br><span class="line">group<span class="variable">.fillMode</span> = k<span class="built_in">CAFillModeForwards</span>;</span><br><span class="line">[<span class="keyword">self</span><span class="variable">.layer</span> addAnimation:group forKey:<span class="string">@"group"</span>];</span><br></pre></td></tr></table></figure>
<h5 id="六、最后感谢一下引用的博客">六、最后感谢一下引用的博客</h5><p><a href="http://geeklu.com/2012/09/animation-in-ios/" target="_blank" rel="external">http://geeklu.com/2012/09/animation-in-ios/</a><br><br><a href="http://www.cnblogs.com/wengzilin/p/4256468.html" target="_blank" rel="external">http://www.cnblogs.com/wengzilin/p/4256468.html</a><br><br><a href="http://www.cnblogs.com/mjios/archive/2013/04/15/3021039.html" target="_blank" rel="external">http://www.cnblogs.com/mjios/archive/2013/04/15/3021039.html</a></p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2016/05/21/ios-date/" itemprop="url">
                iOS 日期处理
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2016-05-21T17:04:42+08:00" content="2016-05-21">
            2016-05-21
          </time>
        </span>

        

        
          
        
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><p>前几天在开发的时候遇到了日期方面的处理，花费了不少时间，踩了点坑，今天就把遇到的写一下.</p>
<h3 id="本文内容">本文内容</h3><ol>
<li>时间格式</li>
<li>时间差（两个日期之间的天数、月数、年数差）计算</li>
</ol>
<h3 id="时间格式">时间格式</h3><p>在iOS中 <font color="#B22222" size="3">NSDateFormatter</font> 处理时间格式的东东，上次有个需求，就是获取网络请求中cookie的时间<br><br>cookie中的时间是这个酱子的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Date:Sat, <span class="number">21</span> May <span class="number">2016</span> <span class="number">07</span>:<span class="number">57</span>:<span class="number">20</span> GMT</span><br></pre></td></tr></table></figure>
<p>NSDateFormatter 中有一下格式：</p>
<table>
<thead>
<tr>
<th>格式</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>G</td>
<td style="text-align:center">公元时代，例如AD公元</td>
</tr>
<tr>
<td>yy</td>
<td style="text-align:center">年的后2位 如：2016 中的 16</td>
</tr>
<tr>
<td>yyyy</td>
<td style="text-align:center">完整年 如：2016</td>
</tr>
<tr>
<td>MM</td>
<td style="text-align:center">月，显示为1-12</td>
</tr>
<tr>
<td>MMM</td>
<td style="text-align:center">月，显示为英文月份简写,如 Jan</td>
</tr>
<tr>
<td>MMMM</td>
<td style="text-align:center">月，显示为英文月份全称，如 Janualy</td>
</tr>
<tr>
<td>dd</td>
<td style="text-align:center">日，2位数表示，如02</td>
</tr>
<tr>
<td>d</td>
<td style="text-align:center">日，1-2位显示，如 2</td>
</tr>
<tr>
<td>EEE</td>
<td style="text-align:center">简写星期几，如Sun</td>
</tr>
<tr>
<td>EEEE</td>
<td style="text-align:center">全写星期几，如Sunday</td>
</tr>
<tr>
<td>aa</td>
<td style="text-align:center">上下午，AM/PM</td>
</tr>
<tr>
<td>H</td>
<td style="text-align:center">时，24小时制，0-23</td>
</tr>
<tr>
<td>K</td>
<td style="text-align:center">时，12小时制，0-11</td>
</tr>
<tr>
<td>m</td>
<td style="text-align:center">分，1-2位 ( 0-9 是一位 )</td>
</tr>
<tr>
<td>mm</td>
<td style="text-align:center">分，2位</td>
</tr>
<tr>
<td>s</td>
<td style="text-align:center">秒，1-2位</td>
</tr>
<tr>
<td>ss</td>
<td style="text-align:center">秒，2位</td>
</tr>
<tr>
<td>S</td>
<td style="text-align:center">毫秒</td>
</tr>
<tr>
<td>Z</td>
<td style="text-align:center">GMT</td>
</tr>
</tbody>
</table>
<p>了解了上面的格式，那就容易多了，故格式是：<font color="#B22222" size="3">EEE, dd MMM yyyy HH:mm:ss Z</font></p>
<figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="name">NSDateFormatter</span> *<span class="atom">formatter</span> = [[<span class="name">NSDateFormatter</span> <span class="atom">alloc</span>] <span class="atom">init</span>];</span><br><span class="line">[<span class="atom">formatter</span> <span class="atom">setDateFormat</span>:@<span class="string">"EEE, dd MMM yyyy HH:mm:ss Z"</span>];</span><br><span class="line"></span><br><span class="line"><span class="name">NSDate</span> *<span class="atom">date</span> = [<span class="atom">formatter</span> <span class="atom">dateFromString</span>:@<span class="string">"Sat, 21 May 2016 07:57:20 GMT"</span>];</span><br></pre></td></tr></table></figure>
<p>但是上面的代码 得出的 date 可能是 nil,后面查了下原来是少设置了<font color="#B22222" size="3">NSLocale (区域设置)</font></p>
<p>因为时间格式是英文的，所以：</p>
<figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="name">NSDateFormatter</span> *<span class="atom">formatter</span> = [[<span class="name">NSDateFormatter</span> <span class="atom">alloc</span>] <span class="atom">init</span>];</span><br><span class="line">[<span class="atom">formatter</span> <span class="atom">setDateFormat</span>:@<span class="string">"EEE, dd MMM yyyy HH:mm:ss Z"</span>];</span><br><span class="line">[<span class="atom">formatter</span> <span class="atom">setLocale</span>:[[<span class="name">NSLocale</span> <span class="atom">alloc</span>] <span class="atom">initWithLocaleIdentifier</span>:@<span class="string">"en_US"</span>]];</span><br><span class="line"><span class="name">NSDate</span> *<span class="atom">date</span> = [<span class="atom">formatter</span> <span class="atom">dateFromString</span>:@<span class="string">"Sat, 21 May 2016 07:57:20 GMT"</span>];</span><br></pre></td></tr></table></figure>
<p>另外，关于是使用  <font color="#B22222" size="3">en_US_POSIX还是en_US</font> 可以看<a href="http://www.lidaren.com/archives/811" target="_blank" rel="external">这篇文章</a><br><br>当然，你设置成了  <font color="#B22222" size="3">zh_CN</font> ，那格式出来的是中文了，如“EEE, dd MMM yyyy HH:mm:ss Z”格式出来的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">周六, <span class="number">21</span> <span class="number">5</span>月 <span class="number">2016</span> <span class="number">16</span>:<span class="number">37</span>:<span class="number">57</span> +<span class="number">0800</span></span><br></pre></td></tr></table></figure>
<h3 id="时间差计算">时间差计算</h3><p>要计算两个日期的有多少天，多少个月，如果要自己计算的话，那就爽歪歪了，不过所幸 iOS的日历功能( <font color="#B22222" size="3">NSCalendar</font> )可以给我们提供一些便利。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSDate</span> *date1 = [formatter dateFromString:<span class="string">@"2016-05-21"</span>];</span><br><span class="line"><span class="built_in">NSDate</span> *date2 = [formatter dateFromString:<span class="string">@"2013-11-25"</span>];</span><br><span class="line"><span class="built_in">NSCalendar</span> *gregorian = [[<span class="built_in">NSCalendar</span> alloc] initWithCalendarIdentifier:<span class="built_in">NSCalendarIdentifierGregorian</span>];</span><br><span class="line"><span class="built_in">NSDateComponents</span> *components = [gregorian components:<span class="built_in">NSCalendarUnitYear</span> | <span class="built_in">NSCalendarUnitMonth</span> | <span class="built_in">NSCalendarUnitDay</span> fromDate:date2 toDate:date1 options:<span class="number">0</span>];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"year = %ld month = %ld day = %ld"</span>,components<span class="variable">.year</span>,components<span class="variable">.month</span>,components<span class="variable">.day</span>);</span><br></pre></td></tr></table></figure>
<h3 id="参考：">参考：<br></h3><p><a href="http://blog.csdn.net/crayondeng/article/details/8755306" target="_blank" rel="external">http://blog.csdn.net/crayondeng/article/details/8755306</a><br><br><a href="http://www.125135.com/339261.htm" target="_blank" rel="external">http://www.125135.com/339261.htm</a><br><br><a href="http://www.cnblogs.com/kaysun/p/5466508.html" target="_blank" rel="external">http://www.cnblogs.com/kaysun/p/5466508.html</a></p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2016/04/23/JSPatch-stduy/" itemprop="url">
                JSPatch 学习
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2016-04-23T21:14:30+08:00" content="2016-04-23">
            2016-04-23
          </time>
        </span>

        

        
          
        
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><h3 id="引言">引言</h3><p>好久前就已经了解到JSPatch（JSPatch是iOS平台的热修复框架，能够及时的修复线上的一些小bug，iOS应用审核时间之长，大家都懂得），一直以来都没有抽出时间去学习，今天抽出时间来学习下，突然又发现只有官方的一些教程，自己照着写写满满都是泪（崩溃的次数多）。学JSPatch写法，首先大家需要先补一下JavaScript的知识。</p>
<h3 id="基础用法">基础用法</h3><p>关于基础的用法大家可以先看<a href="https://github.com/bang590/JSPatch/wiki/JSPatch-基础用法" target="_blank" rel="external">官方的Wiki</a>,大致有13个知识点，我这里直接就上用法了。<br></p>
<h4 id="require">require</h4><p>首先，用到哪个类就需要require一下，否则会崩溃，比如UIView、UILabel等等，中间逗号隔开</p>
<figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">'UILabel,UIView'</span>);</span><br></pre></td></tr></table></figure>
<h4 id="调用OC的方法">调用OC的方法</h4><p>因为JavaScript是链式语法，所以说和写OC有很大的不同,写的时候要注意</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">'UIView, UIColor'</span>);</span><br><span class="line"><span class="keyword">var</span> view = UIView.alloc().init();<span class="comment">//实例方法</span></span><br><span class="line"><span class="keyword">var</span> red = UIColor.redColor();<span class="comment">//类方法</span></span><br></pre></td></tr></table></figure>
<p>UIView 有很多的Property，这些Property如何调用呢？<br><br>等于调用这个 Property 的 getter / setter 方法，获取时记得加 (),如：</p>
<figure class="highlight sml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">require(<span class="symbol">'UIView</span>, <span class="type">UIColor'</span>);</span><br><span class="line">var view = <span class="type">UIView</span>.alloc<span class="literal">()</span>.init<span class="literal">()</span>;</span><br><span class="line">view.setBackgroundColor(<span class="type">UIColor</span>.grayColor<span class="literal">()</span>);</span><br></pre></td></tr></table></figure>
<h4 id="常量、枚举、宏、全局变量">常量、枚举、宏、全局变量</h4><p>Objective-C 里的常量/枚举不能直接在 JS 上使用，可以直接在 JS 上用具体值代替：</p>
<figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="keyword">label</span> = UILabel.alloc().init();</span><br><span class="line"><span class="keyword">label</span>.setTextAlignment(<span class="number">1</span>);<span class="comment">//这里需要写具体的值</span></span><br></pre></td></tr></table></figure>
<p>宏也不使用，若定义的宏是一个值，可以在 JS 定义同样的全局变量代替，若定义的宏是程序，可以在JS展开宏</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">define</span> TABBAR_HEIGHT <span class="number">40</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> SCREEN_WIDTH [[UIScreen mainScreen] bounds].size.height</span></span><br><span class="line">[view setWidth:SCREEN_WIDTH height:TABBAR_HEIGHT];</span><br><span class="line"><span class="comment">//JS</span></span><br><span class="line">view.setWidth_height(<span class="number">40</span>, UIScreen.mainScreen().bounds().height);</span><br></pre></td></tr></table></figure>
<p>若宏的值是某些在底层才能获取到的值，例如 CGFLOAT_MIN，可以通过在某个类或实例方法里将它返回，或者用添加扩展的方式提供支持，</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">JPMacroSupport</span></span></span><br><span class="line">+ (<span class="keyword">void</span>)main:(JSContext *)context</span><br><span class="line">&#123;</span><br><span class="line">  context[<span class="string">@"CGFLOAT_MIN"</span>] = ^<span class="built_in">CGFloat</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">CGFLOAT_MIN</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">require(<span class="string">'JPEngine'</span>).addExtensions([<span class="string">'JPMacroSupport'</span>])</span><br><span class="line">var <span class="built_in">float</span>M<span class="keyword">in</span> = CGFLOAT_MIN();</span><br></pre></td></tr></table></figure>
<p>当然全局变量也是如此：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="built_in">NSString</span> *name;</span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">JPTestObject</span></span></span><br><span class="line">+ (<span class="built_in">NSString</span> *)name &#123;</span><br><span class="line">  <span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">var</span> name = JPTestObject.<span class="function"><span class="title">name</span><span class="params">()</span></span> <span class="comment">//拿到全局变量值</span></span><br></pre></td></tr></table></figure>
<h4 id="defineClass">defineClass</h4><p>在 defineClass 里定义 OC 已存在的方法即可覆盖:</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">defineClass</span>(<span class="string">'ViewController'</span>, &#123;</span><br><span class="line">    <span class="tag">viewDidLoad</span>: <span class="tag">function</span>() &#123;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>如果想调用原方法，在方法名前加 ORIG 即可调用未覆盖前的 OC 原方法:</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">defineClass(<span class="string">'ViewController'</span>, &#123;</span><br><span class="line">    viewDidLoad: <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">self</span>.ORIGviewDidLoad();</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>下面是一个UILabel添加到View上的例子：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">require<span class="list">(<span class="quoted">'UILabel</span>,UIView,UIColor,UIFont')</span><span class="comment">;</span></span><br><span class="line">defineClass<span class="list">(<span class="quoted">'ViewController</span>', &#123;</span><br><span class="line">    viewDidLoad: function<span class="list">()</span> &#123;</span><br><span class="line">        self.ORIGviewDidLoad<span class="list">()</span><span class="comment">;</span></span><br><span class="line">        var view = self.view<span class="list">()</span><span class="comment">;</span></span><br><span class="line">        var label = UILabel.alloc<span class="list">()</span>.initWithFrame<span class="list">(&#123;x:<span class="number">100</span>, y:<span class="number">200</span>, width:<span class="number">100</span>, height:<span class="number">100</span>&#125;)</span><span class="comment">;</span></span><br><span class="line">        label.setFont<span class="list">(<span class="keyword">UIFont</span>.systemFontOfSize<span class="list">(<span class="number">10</span>)</span>)</span><span class="comment">;</span></span><br><span class="line">        label.setTextAlignment<span class="list">(<span class="number">1</span>)</span><span class="comment">;</span></span><br><span class="line">        label.setText<span class="list">(<span class="string">"你好 ！"</span>)</span><span class="comment">;</span></span><br><span class="line">        label.setBackgroundColor<span class="list">(<span class="keyword">UIColor</span>.grayColor<span class="list">()</span>)</span><span class="comment">;</span></span><br><span class="line">        view.addSubview<span class="list">(<span class="keyword">label</span>)</span><span class="comment">;</span></span><br><span class="line">        var background = UIView.alloc<span class="list">()</span>.initWithFrame<span class="list">(&#123;x:<span class="number">100</span>,y:<span class="number">350</span>,width:<span class="number">100</span>,height:<span class="number">100</span>&#125;)</span><span class="comment">;</span></span><br><span class="line">        background.setBackgroundColor<span class="list">(<span class="keyword">UIColor</span>.grayColor<span class="list">()</span>)</span><span class="comment">;</span></span><br><span class="line">        self.setBackgroundView<span class="list">(<span class="keyword">background</span>)</span><span class="comment">;</span></span><br><span class="line">        view.addSubview<span class="list">(<span class="keyword">self</span>.backgroundView<span class="list">()</span>)</span><span class="comment">;</span></span><br><span class="line">    &#125;,</span><br><span class="line">&#125;)</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>开始的时候一直不知道OC中的“self.view”在JavaScript中怎么调用，试了好久直接调用“self.view()”就行了。</p>
<p><br><br><br></p>
<hr>
<p>参考：<br><br><a href="https://github.com/bang590/JSPatch/wiki" target="_blank" rel="external">官方的Wiki</a></p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">&raquo;</a>
  </nav>

 </div>

        

        
      </div>

      
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      <section class="site-overview">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" src="/images/default_avatar.jpg" alt="Share" itemprop="image"/>
          <p class="site-author-name" itemprop="name">Share</p>
        </div>
        <p class="site-description motion-element" itemprop="description">just do it !</p>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">12</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          <div class="site-state-item site-state-categories">
            
              <span class="site-state-item-count">0</span>
              <span class="site-state-item-name">分类</span>
              
          </div>

          <div class="site-state-item site-state-tags">
            <a href="/tags">
              <span class="site-state-item-count">0</span>
              <span class="site-state-item-name">标签</span>
              </a>
          </div>

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        <div class="links-of-author motion-element">
          
        </div>

      </section>

      

    </div>
  </aside>


    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner"> <div class="copyright" >
  
  &copy; &nbsp;  2015 - 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="icon-next-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Share</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>


 </div>
    </footer>

    <div class="back-to-top"></div>
  </div>

  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  
  
    
    

  


  
  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script>
  <script type="text/javascript" src="/js/fancy-box.js?v=0.4.5.1"></script>


  <script type="text/javascript" src="/js/helpers.js?v=0.4.5.1"></script>
  

  <script type="text/javascript" src="/vendors/velocity/velocity.min.js"></script>
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js"></script>

  <script type="text/javascript" src="/js/motion_global.js?v=0.4.5.1" id="motion.global"></script>




  <script type="text/javascript" src="/js/nav-toggle.js?v=0.4.5.1"></script>
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  

  <script type="text/javascript">
    $(document).ready(function () {
      if (CONFIG.sidebar === 'always') {
        displaySidebar();
      }
      if (isMobile()) {
        FastClick.attach(document.body);
      }
    });
  </script>

  
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
      processEscapes: true,
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
  });
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for (i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>


  
  

  
  <script type="text/javascript" src="/js/lazyload.js"></script>
  <script type="text/javascript">
    $(function () {
      $("#posts").find('img').lazyload({
        placeholder: "/images/loading.gif",
        effect: "fadeIn"
      });
    });
  </script>
</body>
</html>
