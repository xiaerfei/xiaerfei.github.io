<!doctype html>
<html class="theme-next use-motion theme-next-mist">
<head>
  

<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />








  <link rel="stylesheet" type="text/css" href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5"/>




<link rel="stylesheet" type="text/css" href="/css/main.css?v=0.4.5.1"/>


    <meta name="description" content="just do it !" />



  <meta name="keywords" content="Hexo,next" />





  <link rel="shorticon icon" type="image/x-icon" href="/favicon.ico?v=0.4.5.1" />


<meta name="description" content="just do it !">
<meta property="og:type" content="website">
<meta property="og:title" content="吾生也有涯，而知也无涯">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="吾生也有涯，而知也无涯">
<meta property="og:description" content="just do it !">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="吾生也有涯，而知也无涯">
<meta name="twitter:description" content="just do it !">


<script type="text/javascript" id="hexo.configuration">
  var CONFIG = {
    scheme: 'Mist',
    sidebar: 'post'
  };
</script>



  <title> 吾生也有涯，而知也无涯 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  <!--[if lte IE 8]>
  <div style=' clear: both; height: 59px; padding:0 0 0 15px; position: relative;margin:0 auto;'>
    <a href="http://windows.microsoft.com/en-US/internet-explorer/products/ie/home?ocid=ie6_countdown_bannercode">
      <img src="http://7u2nvr.com1.z0.glb.clouddn.com/picouterie.jpg" border="0" height="42" width="820"
           alt="You are using an outdated browser. For a faster, safer browsing experience, upgrade for free today or use other browser ,like chrome firefox safari."
           style='margin-left:auto;margin-right:auto;display: block;'/>
    </a>
  </div>
<![endif]-->
  






  <div class="container one-column 
   page-home 
">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><h1 class="site-meta">
  <span class="logo-line-before"><i></i></span>
  <a href="/" class="brand" rel="start">
      <span class="logo">
        <i class="icon-next-logo"></i>
      </span>
      <span class="site-title">吾生也有涯，而知也无涯</span>
  </a>
  <span class="logo-line-after"><i></i></span>
</h1>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu ">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            <i class="menu-item-icon icon-next-home"></i> <br />
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            <i class="menu-item-icon icon-next-archives"></i> <br />
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            <i class="menu-item-icon icon-next-tags"></i> <br />
            标签
          </a>
        </li>
      

      
      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div id="content" class="content"> 
  <section id="posts" class="posts-expand">
    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2017/04/28/06-index-heap/" itemprop="url">
                索引堆
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2017-04-28T20:00:35+08:00" content="2017-04-28">
            2017-04-28
          </time>
        </span>

        

        
          
        
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><h2 id="索引堆">索引堆</h2><h3 id="索引堆的原理与实现">索引堆的原理与实现</h3><p>索引堆实际上是对二叉堆的优化。</p>
<p>在原来的数据结构中为每个数据增加一个索引，这样在数据更新的时候，只交换其索引，这样对于复杂的数据结构能提高一些性能。如下图：</p>
<p><img src="http://7xv4w8.com1.z0.glb.clouddn.com/index-heap-01m.png" alt=""></p>
<p>当索引 <code>10</code> 对应的值改为 <code>70</code>时，进行堆维护之后，则变为：</p>
<p><img src="http://7xv4w8.com1.z0.glb.clouddn.com/index-heap-02m.png" alt=""></p>
<p>可以看到，我们仅仅只是对 index 进行了交换，data 的顺序不变。其它的思路不变。</p>
<p>可以把在上节实现的堆排序的代码拿过来修改一下：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> void index_max_heap_shift_up(Index_max_heap *index_max_heap,<span class="keyword">int</span> k) &#123;</span><br><span class="line">    <span class="keyword">while</span> (k &gt; <span class="number">1</span> &amp;&amp; index_max_heap-&gt;item[index_max_heap-&gt;indexs[k/<span class="number">2</span>]] &lt; index_max_heap-&gt;item[index_max_heap-&gt;indexs[k]]) &#123;</span><br><span class="line">        <span class="comment">/// 仅交换 index</span></span><br><span class="line">        swap(&amp;index_max_heap-&gt;indexs[k/<span class="number">2</span>], &amp;index_max_heap-&gt;indexs[k]);</span><br><span class="line">        k /= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> void index_max_heap_shift_down(Index_max_heap *index_max_heap,<span class="keyword">int</span> k) &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">2</span>*k &lt;= index_max_heap-&gt;count) &#123;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">2</span>*k;</span><br><span class="line">        <span class="keyword">if</span> (index + <span class="number">1</span> &lt;= index_max_heap-&gt;count &amp;&amp; index_max_heap-&gt;item[index_max_heap-&gt;indexs[index + <span class="number">1</span>]] &gt; index_max_heap-&gt;item[index_max_heap-&gt;indexs[index]]) &#123;</span><br><span class="line">            index += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (index_max_heap-&gt;item[index_max_heap-&gt;indexs[k]] &gt; index_max_heap-&gt;item[index_max_heap-&gt;indexs[index]]) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        swap(&amp;index_max_heap-&gt;indexs[k], &amp;index_max_heap-&gt;indexs[index]);</span><br><span class="line">        k = index;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="实现更改索引堆的数据">实现更改索引堆的数据</h3><p>当数据变化的时候，我们要更改索引堆中对应的数据。假设 indexs 中存储的是数据的索引，现在我们要更改 索引为 <code>5</code> 对应的数据：</p>
<figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">item<span class="string">[5]</span> = newItem;</span><br></pre></td></tr></table></figure>
<p>现在我们要维护索引堆，但是并不知道 <code>5</code> 在 <code>indexs</code> 中的哪个位置，所以只能循环遍历出 <code>i</code>：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">for <span class="list">(<span class="keyword">int</span> i = <span class="number">1</span><span class="comment">; i &lt;= count; i++) &#123;</span></span><br><span class="line">    if <span class="list">(<span class="keyword">indexs</span>[i] == <span class="number">5</span>)</span> &#123;</span><br><span class="line">        shiftUp<span class="list">(<span class="keyword">i</span>)</span><span class="comment">;</span></span><br><span class="line">        shiftDown<span class="list">(<span class="keyword">i</span>)</span><span class="comment">;</span></span><br><span class="line">        return<span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="增加反向查找索引_index">增加反向查找索引 index</h3><p>可以看到上面的查找还是比较耗时的，这里我们做一下优化，增加一个反向查找 <code>index</code> 的数组 <code>reverses</code>。</p>
<p><img src="http://7xv4w8.com1.z0.glb.clouddn.com/index-heap-03.png" alt=""></p>
<p>我们再将索引 <code>10</code> 对应的值改为 <code>70</code>：</p>
<p><img src="http://7xv4w8.com1.z0.glb.clouddn.com/index-heap-04.png" alt=""></p>
<h3 id="全部的代码如下">全部的代码如下</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">"IndexMaxHeap.h"</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">"SortHelper.h"</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> Index_max_heap_s Index_max_heap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> Index_max_heap_s &#123;</span><br><span class="line">    <span class="keyword">int</span> count;                                      <span class="comment">//-&gt; 当前堆内数据的大小</span></span><br><span class="line">    <span class="keyword">int</span> capacity;                                   <span class="comment">//-&gt; 当前堆的容量</span></span><br><span class="line">    <span class="keyword">void</span> (*insert)(Index_max_heap *,<span class="keyword">int</span>,<span class="keyword">int</span>);       <span class="comment">//-&gt; 插入函数</span></span><br><span class="line">    <span class="keyword">int</span> (*extract_max)(Index_max_heap *);           <span class="comment">//-&gt; 输出一个最大值</span></span><br><span class="line">    <span class="keyword">int</span> (*extract_max_index)(Index_max_heap *);     <span class="comment">//-&gt; 输出一个最大值的索引</span></span><br><span class="line">    <span class="keyword">int</span> (*get_item_by_index)(Index_max_heap *,<span class="keyword">int</span>); <span class="comment">//-&gt; 返回一个指定的索引值</span></span><br><span class="line">    <span class="keyword">void</span> (*change_item_by_index)(Index_max_heap *,<span class="keyword">int</span>,<span class="keyword">int</span>); <span class="comment">//-&gt; 更改指定索引的值</span></span><br><span class="line">    <span class="keyword">int</span> *item;                                      <span class="comment">//-&gt; 数组指针</span></span><br><span class="line">    <span class="keyword">int</span> *indexs;                                    <span class="comment">//-&gt; 数组指针 索引</span></span><br><span class="line">    <span class="keyword">int</span> *reverses;                                  <span class="comment">//-&gt; 数组指针 反向查找索引</span></span><br><span class="line">    <span class="keyword">void</span> (*print_to_dot)(Index_max_heap *);         <span class="comment">//-&gt; 生成 dot 语言 函数</span></span><br><span class="line">&#125; Index_max_heap;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">index_max_heap_shift_up</span><span class="params">(Index_max_heap *index_max_heap,<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (k &gt; <span class="number">1</span> &amp;&amp; index_max_heap-&gt;item[index_max_heap-&gt;indexs[k/<span class="number">2</span>]] &lt; index_max_heap-&gt;item[index_max_heap-&gt;indexs[k]]) &#123;</span><br><span class="line">        <span class="comment">/// 仅交换 index</span></span><br><span class="line">        swap(&amp;index_max_heap-&gt;indexs[k/<span class="number">2</span>], &amp;index_max_heap-&gt;indexs[k]);</span><br><span class="line">        index_max_heap-&gt;reverses[index_max_heap-&gt;indexs[k/<span class="number">2</span>]] = k/<span class="number">2</span>;</span><br><span class="line">        index_max_heap-&gt;reverses[index_max_heap-&gt;indexs[k]] = k;</span><br><span class="line">        k /= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">index_max_heap_shift_down</span><span class="params">(Index_max_heap *index_max_heap,<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">2</span>*k &lt;= index_max_heap-&gt;count) &#123;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">2</span>*k;</span><br><span class="line">        <span class="keyword">if</span> (index + <span class="number">1</span> &lt;= index_max_heap-&gt;count &amp;&amp; index_max_heap-&gt;item[index_max_heap-&gt;indexs[index + <span class="number">1</span>]] &gt; index_max_heap-&gt;item[index_max_heap-&gt;indexs[index]]) &#123;</span><br><span class="line">            index += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (index_max_heap-&gt;item[index_max_heap-&gt;indexs[k]] &gt; index_max_heap-&gt;item[index_max_heap-&gt;indexs[index]]) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        swap(&amp;index_max_heap-&gt;indexs[k], &amp;index_max_heap-&gt;indexs[index]);</span><br><span class="line">        index_max_heap-&gt;reverses[index_max_heap-&gt;indexs[k]] = k;</span><br><span class="line">        index_max_heap-&gt;reverses[index_max_heap-&gt;indexs[index]] = index;</span><br><span class="line"></span><br><span class="line">        k = index;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(Index_max_heap* index_max_heap,<span class="keyword">int</span> index,<span class="keyword">int</span> item)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index_max_heap-&gt;count &gt; index_max_heap-&gt;capacity) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    index_max_heap-&gt;count += <span class="number">1</span>;</span><br><span class="line">    index_max_heap-&gt;item[index_max_heap-&gt;count] = item;</span><br><span class="line">    index_max_heap-&gt;reverses[index] = index_max_heap-&gt;count;</span><br><span class="line">    index_max_heap-&gt;indexs[index_max_heap-&gt;count] = index;</span><br><span class="line">    index_max_heap_shift_up(index_max_heap, index_max_heap-&gt;count);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">extract_max</span><span class="params">(Index_max_heap* index_max_heap)</span> </span>&#123;</span><br><span class="line">    assert(index_max_heap-&gt;count &gt; <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> ret = index_max_heap-&gt;item[index_max_heap-&gt;indexs[<span class="number">1</span>]];</span><br><span class="line">    </span><br><span class="line">    swap(&amp;index_max_heap-&gt;indexs[<span class="number">1</span>], &amp;index_max_heap-&gt;indexs[index_max_heap-&gt;count]);</span><br><span class="line">    index_max_heap-&gt;reverses[index_max_heap-&gt;indexs[<span class="number">1</span>]] = <span class="number">1</span>;</span><br><span class="line">    index_max_heap-&gt;reverses[index_max_heap-&gt;indexs[index_max_heap-&gt;count]] = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    index_max_heap-&gt;count -= <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    index_max_heap_shift_down(index_max_heap, <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">extract_max_index</span><span class="params">(Index_max_heap* index_max_heap)</span> </span>&#123;</span><br><span class="line">    assert(index_max_heap-&gt;count &gt; <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> ret = index_max_heap-&gt;indexs[<span class="number">1</span>];</span><br><span class="line">    </span><br><span class="line">    swap(&amp;index_max_heap-&gt;indexs[<span class="number">1</span>], &amp;index_max_heap-&gt;indexs[index_max_heap-&gt;count]);</span><br><span class="line">    index_max_heap-&gt;reverses[index_max_heap-&gt;indexs[<span class="number">1</span>]] = <span class="number">1</span>;</span><br><span class="line">    index_max_heap-&gt;reverses[index_max_heap-&gt;indexs[index_max_heap-&gt;count]] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    index_max_heap-&gt;count -= <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    index_max_heap_shift_down(index_max_heap, <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">contain</span><span class="params">(Index_max_heap* index_max_heap,<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    assert(i + <span class="number">1</span> &gt;= <span class="number">1</span> &amp;&amp; i + <span class="number">1</span> &lt;= index_max_heap-&gt;capacity );</span><br><span class="line">    <span class="keyword">return</span> index_max_heap-&gt;reverses[i + <span class="number">1</span>] != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">get_item_by_index</span><span class="params">(Index_max_heap* index_max_heap,<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    assert(contain(index_max_heap,index));</span><br><span class="line">    <span class="keyword">return</span> index_max_heap-&gt;item[index + <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">change_item_by_index</span><span class="params">(Index_max_heap* index_max_heap,<span class="keyword">int</span> index,<span class="keyword">int</span> item)</span> </span>&#123;</span><br><span class="line">    assert(contain(index_max_heap,index));</span><br><span class="line">    index += <span class="number">1</span>;</span><br><span class="line">    index_max_heap-&gt;item[index] = item;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//    for (int i = 1; i &lt;= index_max_heap-&gt;count; i++) &#123;</span></span><br><span class="line"><span class="comment">//        if (index_max_heap-&gt;indexs[i] == index) &#123;</span></span><br><span class="line"><span class="comment">//            index_max_heap_shift_up(index_max_heap, i);</span></span><br><span class="line"><span class="comment">//            index_max_heap_shift_down(index_max_heap, i);</span></span><br><span class="line"><span class="comment">//            return;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> i = index_max_heap-&gt;reverses[index];</span><br><span class="line">    index_max_heap_shift_up(index_max_heap, i);</span><br><span class="line">    index_max_heap_shift_down(index_max_heap, i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print_to_dot</span><span class="params">(Index_max_heap *index_max_heap)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n&lt;---------- dot start ----------&gt;\n\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"digraph heap &#123;\nnode[shape=circle];\nnodesep=0.3;\n"</span>);</span><br><span class="line">    <span class="keyword">int</span> count = index_max_heap-&gt;count;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= count; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> leftIndex = <span class="number">2</span> * i;</span><br><span class="line">        <span class="keyword">int</span> rightIndex = <span class="number">2</span> * i + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (leftIndex &lt;= count) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"\t%d -&gt; %d;\n"</span>,index_max_heap-&gt;item[index_max_heap-&gt;indexs[i]],index_max_heap-&gt;item[index_max_heap-&gt;indexs[leftIndex]]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (rightIndex &lt;= count) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"\t%d -&gt; %d;\n"</span>,index_max_heap-&gt;item[index_max_heap-&gt;indexs[i]],index_max_heap-&gt;item[index_max_heap-&gt;indexs[rightIndex]]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"&#125;\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n\n&lt;---------- dot end ----------&gt;\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> Index_max_heap <span class="title">create_index_max_heap</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> *item = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * (capacity + <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">int</span> *indexs = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * (capacity + <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">int</span> *reverses = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * (capacity + <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; capacity; i++) &#123;</span><br><span class="line">        item[i] = <span class="number">0</span>;</span><br><span class="line">        indexs[i] = <span class="number">0</span>;</span><br><span class="line">        reverses[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Index_max_heap index_max_heap = &#123;</span><br><span class="line">        .count = <span class="number">0</span>,</span><br><span class="line">        .capacity = capacity,</span><br><span class="line">        .insert = insert,</span><br><span class="line">        .extract_max = extract_max,</span><br><span class="line">        .extract_max_index = extract_max_index,</span><br><span class="line">        .get_item_by_index = get_item_by_index,</span><br><span class="line">        .change_item_by_index = change_item_by_index,</span><br><span class="line">        .item = item,</span><br><span class="line">        .indexs = indexs,</span><br><span class="line">        .reverses = reverses,</span><br><span class="line">        .print_to_dot = print_to_dot</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> index_max_heap;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">pragma</span> mark - test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_index_max_heap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//    int *a = generateNoRepeatRandomArray(20,0,100);</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> arr[] = &#123; <span class="number">31</span>,<span class="number">2</span>, <span class="number">1</span>,<span class="number">45</span>,<span class="number">73</span>, <span class="number">69</span>, <span class="number">60</span>, <span class="number">59</span>,<span class="number">91</span>, <span class="number">49</span>,  <span class="number">43</span>, <span class="number">32</span>,  <span class="number">29</span>, <span class="number">18</span>,<span class="number">88</span>, <span class="number">17</span>, <span class="number">9</span>,<span class="number">76</span>, <span class="number">6</span>,  <span class="number">0</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    Index_max_heap index_max_heap = create_index_max_heap(<span class="number">50</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">        index_max_heap.insert(&amp;index_max_heap,i,arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">void</span> (*change_item_by_index)(Index_max_heap *index_max_heap,<span class="keyword">int</span>,<span class="keyword">int</span>) = index_max_heap.change_item_by_index;</span><br><span class="line">    change_item_by_index(&amp;index_max_heap,<span class="number">8</span>,<span class="number">22</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">void</span> (*print_to_dot)(Index_max_heap *index_max_heap) = index_max_heap.print_to_dot;</span><br><span class="line">    print_to_dot(&amp;index_max_heap);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> (*extract_max)(Index_max_heap *index_max_heap) = index_max_heap.extract_max;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">20</span>; i ++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d, "</span>,extract_max(&amp;index_max_heap));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2017/04/25/05-heap-sort/" itemprop="url">
                排序算法之堆排序
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2017-04-25T23:15:06+08:00" content="2017-04-25">
            2017-04-25
          </time>
        </span>

        

        
          
        
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><h2 id="关于二叉树的一些概念">关于二叉树的一些概念</h2><p><a href="http://www.cnblogs.com/idorax/p/6441043.html" target="_blank" rel="external">一些基本概念</a></p>
<h2 id="堆的定义">堆的定义</h2><p>堆(heap)，是数据结构中的堆（不是内存模型中的堆）。堆通常是一个可以被看做一棵树，它满足下列性质：</p>
<ul>
<li>堆中任意节点的值总是不大于(不小于)其子节点的值；</li>
<li>堆总是一棵完全树；</li>
</ul>
<h2 id="二叉堆的定义">二叉堆的定义</h2><p>二叉堆是一颗完全树，它分为两种：最大堆和最小堆。</p>
<ul>
<li>最大堆：父结点的键值总是大于或等于任何一个子节点的键值</li>
<li>最小堆：父结点的键值总是小于或等于任何一个子节点的键值</li>
</ul>
<p><img src="http://7xv4w8.com1.z0.glb.clouddn.com/heap-diaplay-00.png" alt=""></p>
<blockquote>
<p>二叉堆的性质</p>
</blockquote>
<p>二叉堆一般都通过”数组”来实现。数组实现的二叉堆，父节点和子节点的位置存在一定的关系。</p>
<p>设二叉堆的顶点索引为 1：</p>
<ul>
<li>性质一：索引为 <code>i</code> 的左孩子的索引是 <code>2*i</code>；</li>
<li>性质二：索引为 <code>i</code> 的右孩子的索引是 <code>2*i + 1</code>；</li>
<li>性质三：索引为 <code>i</code> 的父节点的索引是 <code>floor(i/2)</code>；</li>
</ul>
<p>设二叉堆的顶点索引为 0：</p>
<ul>
<li>性质一：索引为 <code>i</code> 的左孩子的索引是 <code>2*i + 1</code>；</li>
<li>性质二：索引为 <code>i</code> 的右孩子的索引是 <code>2*i + 2</code>；</li>
<li>性质三：索引为 <code>i</code> 的父节点的索引是 <code>floor((i-1)/2)</code>；</li>
</ul>
<h2 id="二叉堆的基本实现_（最大堆）">二叉堆的基本实现 （最大堆）</h2><p><img src="http://7xv4w8.com1.z0.glb.clouddn.com/heap-diaplay-01m.png" alt=""></p>
<blockquote>
<p>用数组存储二叉堆</p>
</blockquote>
<p><img src="http://7xv4w8.com1.z0.glb.clouddn.com/heap-diaplay-02.png" alt=""></p>
<h3 id="shiftUp">shiftUp</h3><p>向二叉堆中添加一个元素，我们就要为它找到一个合适的位置，例如添加的是 <code>95</code> 这个元素</p>
<p><img src="http://7xv4w8.com1.z0.glb.clouddn.com/heap-diaplay-03m.png" alt=""></p>
<p>显然此时这个二叉堆已经不满足我们对最大堆的定义，我们要维护的它（最大堆的定义），这里需要几步。我们要不断的把它(<code>95</code>)和它的父节点相比较，大于父节点就交换，直至小于它的父节点。</p>
<blockquote>
<p>第一步 和父节点 <code>50</code> 比较</p>
</blockquote>
<p><code>95</code> 大于 <code>50</code>，所以 <code>95</code> 和 父节点 <code>50</code> 交换位置</p>
<p><img src="http://7xv4w8.com1.z0.glb.clouddn.com/heap-diaplay-04.png" alt=""></p>
<blockquote>
<p>第二步 和父节点 <code>58</code> 比较</p>
</blockquote>
<p><code>95</code> 大于 <code>58</code>，所以 <code>95</code> 和 父节点 <code>58</code> 交换位置</p>
<p><img src="http://7xv4w8.com1.z0.glb.clouddn.com/heap-diaplay-05.png" alt=""></p>
<blockquote>
<p>第三步 和父节点 <code>86</code> 比较</p>
</blockquote>
<p><code>95</code> 大于 <code>86</code>，所以 <code>95</code> 和 父节点 <code>86</code> 交换位置</p>
<p><img src="http://7xv4w8.com1.z0.glb.clouddn.com/heap-diaplay-06.png" alt=""></p>
<p><strong>至此，就完成了整个 <code>shiftUp</code> 的过程</strong></p>
<h3 id="shiftUp_程序的编写">shiftUp 程序的编写</h3><p>我们首先建立一个结构体：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> Heap_sort_max_s Heap_sort_max;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> Heap_sort_max_s &#123;</span><br><span class="line">    <span class="keyword">int</span> count;                              <span class="comment">//-&gt; 当前堆内数据的大小</span></span><br><span class="line">    <span class="keyword">int</span> capacity;                           <span class="comment">//-&gt; 当前堆的容量</span></span><br><span class="line">    <span class="keyword">void</span> (*insert)(Heap_sort_max *,<span class="keyword">int</span>);    <span class="comment">//-&gt; 插入函数</span></span><br><span class="line">    <span class="keyword">int</span> (*extract_max)(Heap_sort_max *);    <span class="comment">//-&gt; 输出一个最大值</span></span><br><span class="line">    <span class="keyword">int</span> *item;                              <span class="comment">//-&gt; 数组指针</span></span><br><span class="line">    <span class="keyword">void</span> (*print_to_dot)(Heap_sort_max *);  <span class="comment">//-&gt; 生成 dot 语言 函数</span></span><br><span class="line">&#125; Heap_sort_max;</span><br></pre></td></tr></table></figure>
<p>insert 函数：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> void insert(Heap_sort_max* heap_sort_max,<span class="keyword">int</span> item) &#123;</span><br><span class="line">    <span class="keyword">if</span> (heap_sort_max-&gt;count &gt; heap_sort_max-&gt;capacity) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    heap_sort_max-&gt;count += <span class="number">1</span>;</span><br><span class="line">    heap_sort_max-&gt;item[heap_sort_max-&gt;count] = item;</span><br><span class="line">    heap_sort_max_shift_up(heap_sort_max, heap_sort_max-&gt;count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>shiftUp 函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heap_sort_max_shift_up</span><span class="params">(Heap_sort_max *heap_sort_max,<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (k &gt; <span class="number">1</span> &amp;&amp; heap_sort_max-&gt;item[k/<span class="number">2</span>] &lt; heap_sort_max-&gt;item[k]) &#123;</span><br><span class="line">        swap(&amp;heap_sort_max-&gt;item[k/<span class="number">2</span>], &amp;heap_sort_max-&gt;item[k]);</span><br><span class="line">        k /= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其它：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print_to_dot</span><span class="params">(Heap_sort_max *heap_sort_max)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n&lt;---------- dot start ----------&gt;\n\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"digraph heap &#123;\nnode[shape=circle];\nnodesep=0.3;\n"</span>);</span><br><span class="line">    <span class="keyword">int</span> count = heap_sort_max-&gt;count;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= count; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> leftIndex = <span class="number">2</span> * i;</span><br><span class="line">        <span class="keyword">int</span> rightIndex = <span class="number">2</span> * i + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (leftIndex &lt;= count) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"\t%d -&gt; %d;\n"</span>,heap_sort_max-&gt;item[i],heap_sort_max-&gt;item[leftIndex]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (rightIndex &lt;= count) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"\t%d -&gt; %d;\n"</span>,heap_sort_max-&gt;item[i],heap_sort_max-&gt;item[rightIndex]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"&#125;\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n\n&lt;---------- dot end ----------&gt;\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> Heap_sort_max <span class="title">create_heap_sort_max</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> *p = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * capacity);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; capacity; i++) &#123;</span><br><span class="line">        p[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Heap_sort_max heap_sort_max = &#123;</span><br><span class="line">        .count = <span class="number">0</span>,</span><br><span class="line">        .capacity = capacity,</span><br><span class="line">        .insert = insert,</span><br><span class="line">        .extract_max = extract_max,</span><br><span class="line">        .item = p,</span><br><span class="line">        .print_to_dot = print_to_dot</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> heap_sort_max;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">free_heap_sort_max</span><span class="params">(Heap_sort_max *heap_sort_max)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">free</span>(heap_sort_max-&gt;item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="测试_insert">测试 insert</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_heap_sort_max</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> *a = generateNoRepeatRandomArray(<span class="number">20</span>,<span class="number">0</span>,<span class="number">100</span>);</span><br><span class="line">    </span><br><span class="line">    Heap_sort_max heap_sort_max = create_heap_sort_max(<span class="number">50</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">        heap_sort_max.insert(&amp;heap_sort_max,a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">void</span> (*print_to_dot)(Heap_sort_max *heap_sort_max) = heap_sort_max.print_to_dot;</span><br><span class="line">    print_to_dot(&amp;heap_sort_max);</span><br><span class="line">    </span><br><span class="line">    free_heap_sort_max(&amp;heap_sort_max);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们创建一个空间为 50 大小的堆，向其中插入 20 个随机的元素。最终由 dot 生成的图片：</p>
<p><img src="http://7xv4w8.com1.z0.glb.clouddn.com/heap-display-max-00.png" alt=""></p>
<hr>
<h3 id="shiftDown">shiftDown</h3><p>下面我们要从堆中取出一个最大的元素 <code>95</code>，为了使这个堆仍然是一个完全二叉树，那么我们将最后一个元素放到堆顶，此时的 <code>count</code> 应将 减去一。</p>
<p><img src="http://7xv4w8.com1.z0.glb.clouddn.com/heap-diaplay-07.png" alt=""></p>
<p>现在这个二叉堆已经不满足我们对最大堆的定义，我们要维护的它，对它进行 <code>shiftDown</code> 操作。</p>
<blockquote>
<p>第一步 和 子节点 <code>86</code> 、<code>60</code> 比较</p>
</blockquote>
<p><code>50</code> 小于 它的两个子节点 <code>86</code> 、<code>60</code>，但 <code>86</code> 比 <code>60</code> 要大，所以 <code>86</code> 和 <code>50</code> 交换：</p>
<p><img src="http://7xv4w8.com1.z0.glb.clouddn.com/heap-diaplay-08.png" alt=""></p>
<blockquote>
<p>第二步 和 子节点 <code>46</code> 、<code>58</code> 比较</p>
</blockquote>
<p><code>50</code> 小于 它的左节点 <code>58</code> ，大于右结点 <code>46</code>，所以 <code>58</code> 和 <code>50</code> 交换：</p>
<p><img src="http://7xv4w8.com1.z0.glb.clouddn.com/heap-diaplay-09.png" alt=""></p>
<blockquote>
<p>最后</p>
</blockquote>
<p>由于 <code>50</code> 大于 35，所以不必交换。</p>
<p><strong>至此，就完成了整个 <code>shiftDown</code> 的过程</strong></p>
<h3 id="shiftDown_程序的编写">shiftDown 程序的编写</h3><p>shiftDown:</p>
<figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> heap_sort_max_shift_down(Heap_sort_max *heap_sort_max,<span class="keyword">int</span> k) &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">2</span>*k &lt;= heap_sort_max-&gt;<span class="keyword">count</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> <span class="keyword">index</span> = <span class="number">2</span>*k;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">index</span> + <span class="number">1</span> &lt;= heap_sort_max-&gt;<span class="keyword">count</span> &amp;&amp; heap_sort_max-&gt;item[<span class="keyword">index</span> + <span class="number">1</span>] &gt; heap_sort_max-&gt;item[<span class="keyword">index</span>]) &#123;</span><br><span class="line">            <span class="keyword">index</span> += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (heap_sort_max-&gt;item[k] &gt; heap_sort_max-&gt;item[<span class="keyword">index</span>]) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        swap(&amp;heap_sort_max-&gt;item[k], &amp;heap_sort_max-&gt;item[<span class="keyword">index</span>]);</span><br><span class="line">        k = <span class="keyword">index</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出最大值：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">extract_max</span><span class="params">(Heap_sort_max* heap_sort_max)</span> </span>&#123;</span><br><span class="line">    assert(heap_sort_max-&gt;count &gt; <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> ret = heap_sort_max-&gt;item[<span class="number">1</span>];</span><br><span class="line">    </span><br><span class="line">    swap(&amp;heap_sort_max-&gt;item[<span class="number">1</span>], &amp;heap_sort_max-&gt;item[heap_sort_max-&gt;count]);</span><br><span class="line">    heap_sort_max-&gt;count -= <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    heap_sort_max_shift_down(heap_sort_max, <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="堆排序">堆排序</h2><p>我们实现了 <code>shiftUp</code> 和 <code>shiftDown</code> 两个操作，那堆排序也就可以实现了。</p>
<p>实现的基本思路是： 先把元素一个一个插入，然后再一个一个去取堆顶元素。代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heap_sort</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    Heap_sort_max heap_sort_max = create_heap_sort_max(n + <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        heap_sort_max.insert(&amp;heap_sort_max,arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n-<span class="number">1</span>; i &gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">        arr[i] = ((<span class="keyword">int</span> (*)(Heap_sort_max *heap_sort_max))heap_sort_max.extract_max)(&amp;heap_sort_max);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="测试">测试</h3><p>我们用 50w 个元素测试：</p>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span>有序<span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line">sortname:插入排序优化	 sorttime: 0.003090s</span><br><span class="line">sortname:希尔排序　　	 sorttime: 0.025961s</span><br><span class="line">sortname:快速排序随机	 sorttime: 0.067989s</span><br><span class="line">sortname:快速排序双路	 sorttime: 0.059503s</span><br><span class="line">sortname:快速排序三路	 sorttime: 0.109031s</span><br><span class="line">sortname:堆排序　　　	 sorttime: 0.283506s</span><br><span class="line"><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span>近乎有序<span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line">sortname:插入排序优化	 sorttime: 0.011907s</span><br><span class="line">sortname:希尔排序　　	 sorttime: 0.031257s</span><br><span class="line">sortname:快速排序随机	 sorttime: 0.069627s</span><br><span class="line">sortname:快速排序双路	 sorttime: 0.047605s</span><br><span class="line">sortname:快速排序三路	 sorttime: 0.090930s</span><br><span class="line">sortname:堆排序　　　	 sorttime: 0.249643s</span><br><span class="line"><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span>有大量的重复值<span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line">sortname:希尔排序　　	 sorttime: 0.055228s</span><br><span class="line">sortname:快速排序随机	 sorttime: 27.275784s</span><br><span class="line">sortname:快速排序双路	 sorttime: 0.055961s</span><br><span class="line">sortname:快速排序三路	 sorttime: 0.015928s</span><br><span class="line">sortname:堆排序　　　	 sorttime: 0.151020s</span><br><span class="line"><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span>随机<span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line">sortname:希尔排序　　	 sorttime: 0.197971s</span><br><span class="line">sortname:快速排序随机	 sorttime: 0.099134s</span><br><span class="line">sortname:快速排序双路	 sorttime: 0.103923s</span><br><span class="line">sortname:快速排序三路	 sorttime: 0.120655s</span><br><span class="line">sortname:堆排序　　　	 sorttime: 0.210723s</span><br><span class="line"><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span>倒叙<span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line">sortname:希尔排序　　	 sorttime: 0.057273s</span><br><span class="line">sortname:快速排序随机	 sorttime: 0.077192s</span><br><span class="line">sortname:快速排序双路	 sorttime: 0.049288s</span><br><span class="line">sortname:快速排序三路	 sorttime: 0.092265s</span><br><span class="line">sortname:堆排序　　　	 sorttime: 0.130887s</span><br></pre></td></tr></table></figure>
<p>可以看到是，堆排序要比其它的排序稍稍慢一些，不过还是可以接受的。</p>
<h2 id="堆排序优化_heapify">堆排序优化 heapify</h2><p>将排序的数组直接赋值给堆，然后进行 <code>shiftDown</code> 操作，省去 <code>insert</code> 操作。代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapify_sort</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    Heap_sort_max heap_sort_max = create_heap_sort_max(n + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++) &#123;</span><br><span class="line">        heap_sort_max.item[i+<span class="number">1</span>] = arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    heap_sort_max.count = n;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n/<span class="number">2</span>; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">        heap_sort_max_shift_down(&amp;heap_sort_max, i);<span class="comment">/// O(n)</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n-<span class="number">1</span>; i &gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">        arr[i] = ((<span class="keyword">int</span> (*)(Heap_sort_max *heap_sort_max))heap_sort_max.extract_max)(&amp;heap_sort_max);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="测试-1">测试</h3><p>我们用 50w 个元素测试：</p>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span>有序<span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line">sortname:插入排序优化	 sorttime: 0.003090s</span><br><span class="line">sortname:希尔排序　　	 sorttime: 0.025961s</span><br><span class="line">sortname:快速排序随机	 sorttime: 0.067989s</span><br><span class="line">sortname:快速排序双路	 sorttime: 0.059503s</span><br><span class="line">sortname:快速排序三路	 sorttime: 0.109031s</span><br><span class="line">sortname:堆排序　　　	 sorttime: 0.283506s</span><br><span class="line">sortname:堆排序优化　	 sorttime: 0.130963s</span><br><span class="line"><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span>近乎有序<span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line">sortname:插入排序优化	 sorttime: 0.011907s</span><br><span class="line">sortname:希尔排序　　	 sorttime: 0.031257s</span><br><span class="line">sortname:快速排序随机	 sorttime: 0.069627s</span><br><span class="line">sortname:快速排序双路	 sorttime: 0.047605s</span><br><span class="line">sortname:快速排序三路	 sorttime: 0.090930s</span><br><span class="line">sortname:堆排序　　　	 sorttime: 0.249643s</span><br><span class="line">sortname:堆排序优化　	 sorttime: 0.127976s</span><br><span class="line"><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span>有大量的重复值<span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line">sortname:希尔排序　　	 sorttime: 0.055228s</span><br><span class="line">sortname:快速排序随机	 sorttime: 27.275784s</span><br><span class="line">sortname:快速排序双路	 sorttime: 0.055961s</span><br><span class="line">sortname:快速排序三路	 sorttime: 0.015928s</span><br><span class="line">sortname:堆排序　　　	 sorttime: 0.151020s</span><br><span class="line">sortname:堆排序优化　	 sorttime: 0.132577s</span><br><span class="line"><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span>随机<span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line">sortname:希尔排序　　	 sorttime: 0.197971s</span><br><span class="line">sortname:快速排序随机	 sorttime: 0.099134s</span><br><span class="line">sortname:快速排序双路	 sorttime: 0.103923s</span><br><span class="line">sortname:快速排序三路	 sorttime: 0.120655s</span><br><span class="line">sortname:堆排序　　　	 sorttime: 0.210723s</span><br><span class="line">sortname:堆排序优化　	 sorttime: 0.212289s</span><br><span class="line"><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span>倒叙<span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line">sortname:希尔排序　　	 sorttime: 0.057273s</span><br><span class="line">sortname:快速排序随机	 sorttime: 0.077192s</span><br><span class="line">sortname:快速排序双路	 sorttime: 0.049288s</span><br><span class="line">sortname:快速排序三路	 sorttime: 0.092265s</span><br><span class="line">sortname:堆排序　　　	 sorttime: 0.130887s</span><br><span class="line">sortname:堆排序优化　	 sorttime: 0.130506s</span><br></pre></td></tr></table></figure>
<p>可以看到比之前稍稍快一点点。</p>
<h2 id="原地堆排序">原地堆排序</h2><p>之前的堆排序都是用了额外的空，原地堆排序的空间复杂度为 O(1)。</p>
<p><strong>ps:原地堆排序的顶元素是从 <code>0</code> 开始的。</strong></p>
<h3 id="原地堆排序分析">原地堆排序分析</h3><p>首先二叉堆数组是这样的：</p>
<p><img src="" alt=""></p>
<p>然后不断的将堆顶元素和堆尾的元素交换，并且每次交换后将堆元素的大小减一，当剩下最后一个的时候，数组已经从小到大排好序了。</p>
<p><img src="" alt=""></p>
<p>由于原地堆排序的顶元素是从 <code>0</code> 开始的，我们要重新实现 <code>shiftDown</code> 操作：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 顶结点的索引从 0 开始</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heap_autochthonous_sort_shift_down</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> n,<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> ((<span class="number">2</span>*k + <span class="number">1</span>) &lt; n) &#123;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">2</span>*k + <span class="number">1</span>; <span class="comment">// 取左孩子索引</span></span><br><span class="line">        <span class="keyword">if</span> (index + <span class="number">1</span> &lt; n &amp;&amp; arr[index + <span class="number">1</span>] &gt; arr[index]) &#123; index++; &#125;</span><br><span class="line">        <span class="keyword">if</span> (arr[k] &gt; arr[index]) &#123; <span class="keyword">break</span>; &#125;</span><br><span class="line">        swap(&amp;arr[k], &amp;arr[index]);</span><br><span class="line">        k = index;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 原地堆排序 空间O(1)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heap_autochthonous_sort</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/// heapify</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = (n-<span class="number">1</span>)/<span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        heap_autochthonous_sort_shift_down(arr, n, i);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n-<span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">        swap(&amp;arr[<span class="number">0</span>], &amp;arr[i]);</span><br><span class="line">        heap_autochthonous_sort_shift_down(arr, i, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="测试-2">测试</h3><p>我们用 50w 个元素测试：</p>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span>有序<span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line">sortname:插入排序优化	 sorttime: 0.003090s</span><br><span class="line">sortname:希尔排序　　	 sorttime: 0.025961s</span><br><span class="line">sortname:快速排序随机	 sorttime: 0.067989s</span><br><span class="line">sortname:快速排序双路	 sorttime: 0.059503s</span><br><span class="line">sortname:快速排序三路	 sorttime: 0.109031s</span><br><span class="line">sortname:堆排序　　　	 sorttime: 0.283506s</span><br><span class="line">sortname:堆排序优化　	 sorttime: 0.130963s</span><br><span class="line">sortname:堆排序原地　	 sorttime: 0.113156s</span><br><span class="line"><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span>近乎有序<span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line">sortname:插入排序优化	 sorttime: 0.011907s</span><br><span class="line">sortname:希尔排序　　	 sorttime: 0.031257s</span><br><span class="line">sortname:快速排序随机	 sorttime: 0.069627s</span><br><span class="line">sortname:快速排序双路	 sorttime: 0.047605s</span><br><span class="line">sortname:快速排序三路	 sorttime: 0.090930s</span><br><span class="line">sortname:堆排序　　　	 sorttime: 0.249643s</span><br><span class="line">sortname:堆排序优化　	 sorttime: 0.127976s</span><br><span class="line">sortname:堆排序原地　	 sorttime: 0.107415s</span><br><span class="line"></span><br><span class="line"><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span>有大量的重复值<span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line">sortname:希尔排序　　	 sorttime: 0.055228s</span><br><span class="line">sortname:快速排序随机	 sorttime: 27.275784s</span><br><span class="line">sortname:快速排序双路	 sorttime: 0.055961s</span><br><span class="line">sortname:快速排序三路	 sorttime: 0.015928s</span><br><span class="line">sortname:堆排序　　　	 sorttime: 0.151020s</span><br><span class="line">sortname:堆排序优化　	 sorttime: 0.132577s</span><br><span class="line">sortname:堆排序原地　	 sorttime: 0.104522s</span><br><span class="line"></span><br><span class="line"><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span>随机<span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line">sortname:希尔排序　　	 sorttime: 0.197971s</span><br><span class="line">sortname:快速排序随机	 sorttime: 0.099134s</span><br><span class="line">sortname:快速排序双路	 sorttime: 0.103923s</span><br><span class="line">sortname:快速排序三路	 sorttime: 0.120655s</span><br><span class="line">sortname:堆排序　　　	 sorttime: 0.210723s</span><br><span class="line">sortname:堆排序优化　	 sorttime: 0.212289s</span><br><span class="line">sortname:堆排序原地　	 sorttime: 0.180132s</span><br><span class="line"></span><br><span class="line"><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span>逆序<span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line">sortname:希尔排序　　	 sorttime: 0.057273s</span><br><span class="line">sortname:快速排序随机	 sorttime: 0.077192s</span><br><span class="line">sortname:快速排序双路	 sorttime: 0.049288s</span><br><span class="line">sortname:快速排序三路	 sorttime: 0.092265s</span><br><span class="line">sortname:堆排序　　　	 sorttime: 0.130887s</span><br><span class="line">sortname:堆排序优化　	 sorttime: 0.130506s</span><br><span class="line">sortname:堆排序原地　	 sorttime: 0.104213s</span><br></pre></td></tr></table></figure>
<p>可以看到又稍稍快了一点。</p>
<p>最后附上<a href="https://github.com/xiaerfei/AlgorithmStudy" target="_blank" rel="external">Demo</a></p>
<h2 id="结束">结束</h2><p>至此，整个排序算法便介绍完了。</p>
<p>下面是各个排序的时间复杂度和空间复杂度的对比：</p>
<table>
<thead>
<tr>
<th style="text-align:center">–</th>
<th style="text-align:center">平均时间复杂度</th>
<th style="text-align:center">原地排序</th>
<th style="text-align:center">额外空间</th>
<th style="text-align:center">稳定排序</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">插入排序</td>
<td style="text-align:center">O(n^2 )</td>
<td style="text-align:center">✅</td>
<td style="text-align:center">O(1)</td>
<td style="text-align:center">✅</td>
</tr>
<tr>
<td style="text-align:center">归并排序</td>
<td style="text-align:center">O(nlogn)</td>
<td style="text-align:center">❌</td>
<td style="text-align:center">O(n)</td>
<td style="text-align:center">✅</td>
</tr>
<tr>
<td style="text-align:center">快速排序</td>
<td style="text-align:center">O(nlogn)</td>
<td style="text-align:center">✅</td>
<td style="text-align:center">O(logn)</td>
<td style="text-align:center">❌</td>
</tr>
<tr>
<td style="text-align:center">堆排序</td>
<td style="text-align:center">O(nlogn)</td>
<td style="text-align:center">✅</td>
<td style="text-align:center">O(1)</td>
<td style="text-align:center">❌</td>
</tr>
</tbody>
</table>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2017/04/10/04-quick-sort/" itemprop="url">
                排序算法之快速排序
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2017-04-10T21:30:33+08:00" content="2017-04-10">
            2017-04-10
          </time>
        </span>

        

        
          
        
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><h1 id="排序算法之快速排序及其优化">排序算法之快速排序及其优化</h1><h2 id="快速排序介绍">快速排序介绍</h2><p>快速排序（英语：Quicksort），又称划分交换排序（partition-exchange sort），一种排序算法，最早由东尼·霍尔提出。使用分治法（Divide and conquer）策略来把一个序列（list）分为两个子序列（sub-lists）。</p>
<p>快速排序通常明显比其他Ο(n log n)算法更快，因为它的内部循环（inner loop）可以在大部分的架构上很有效率地被实现出来。在平均状况下，排序n个项目要Ο(n log n)次比较。在最坏状况下则需要Ο(n\^2)次比较，但这种状况并不常见。</p>
<h2 id="快速排序_看图说话">快速排序 看图说话</h2><h3 id="实例分析排序过程">实例分析排序过程</h3><p>待排数组：</p>
<p><img src="http://7xv4w8.com1.z0.glb.clouddn.com/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F01.png" alt="快速排序01"></p>
<p>选取数组的第一个元素为基准：5</p>
<p>将小于5的元素放在其左边，大于5的元素放在其右边：</p>
<p><img src="http://7xv4w8.com1.z0.glb.clouddn.com/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F02.png" alt="快速排序02"></p>
<p>然后不断的对左右两边进行上面的分割，最终为：</p>
<p><img src="http://7xv4w8.com1.z0.glb.clouddn.com/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F04.png" alt="快速排序04"></p>
<p><strong>注意：我用线将当前的数组的顺序连接了起来，这已经是排序完成了，大家看了下面的分割过程，自己将这个过程用这样的图在纸上或者keynote等画出来，之后，下面的程序是非常好理解的！</strong></p>
<h3 id="分析分割过程">分析分割过程</h3><p>我们来看分割： 定义 v 为基准值；定义 l 为数组的第一个元素的索引；j 为小于基准值的最后一个元素的索引；i 为当前和基准值比较的值的索引，e 为 其值。</p>
<p>数组arr中 [l+1,j] 区间的值都是 小于 v 的,[j+1,i-1] 都是大于 v 的，具体如下图：</p>
<p><img src="http://7xv4w8.com1.z0.glb.clouddn.com/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F05.png" alt="快速排序05"></p>
<p>1.当 <code>e 小于 v</code> 的时候：<br>把 <code>j+1</code> 位置的值 和 <code>e</code> 交换：</p>
<p><img src="http://7xv4w8.com1.z0.glb.clouddn.com/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F06.png" alt="快速排序06"></p>
<p>然后 <code>j ++</code>,<code>i ++</code>,就行了；</p>
<p>2.当 <code>e 大于 v</code> 的时候：</p>
<p>这个就简单了 直接 <code>i ++</code> 就 O 了；</p>
<p>3.当分割完了之后：</p>
<p><img src="http://7xv4w8.com1.z0.glb.clouddn.com/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F07.png" alt="快速排序07"></p>
<p>此时，只要将 <code>l 和 j + 1</code> 的位置的值交换一下：</p>
<p><img src="http://7xv4w8.com1.z0.glb.clouddn.com/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F08.png" alt="快速排序08"></p>
<p>我们已经将数组分割成为:左边小于 v ,右边 大于 v.</p>
<p>关于边界处理，请看后面的程序。</p>
<p>下面是分割的代码：</p>
<figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> __partition(<span class="built_in">int</span> arr[],<span class="built_in">int</span> l,<span class="built_in">int</span> r) &#123;</span><br><span class="line">    <span class="built_in">int</span> v = arr[l]<span class="comment">;</span></span><br><span class="line">    <span class="built_in">int</span> j = l<span class="comment">;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = l+<span class="number">1</span><span class="comment">; i &lt;= r; i++) &#123;</span></span><br><span class="line">        <span class="keyword">if</span> (arr[i] &lt; v) &#123;</span><br><span class="line">            swap(&amp;arr[j +<span class="number">1</span>], &amp;arr[i])<span class="comment">;</span></span><br><span class="line">            j ++<span class="comment">;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    swap(&amp;arr[l], &amp;arr[j])<span class="comment">;</span></span><br><span class="line">    <span class="keyword">return</span> j<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>相信，有了前面的图，理解这个程序是很容易的。</p>
<p>快速排序，使用递归的方法是很容易理解的，我们这里也采用递归的方法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> __quickSort(<span class="keyword">int</span> arr[],<span class="keyword">int</span> l,<span class="keyword">int</span> r) &#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> p = __partition(arr,l,r);</span><br><span class="line">    </span><br><span class="line">    __quickSort(arr, l, p-<span class="number">1</span>);</span><br><span class="line">    __quickSort(arr, p+<span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    __quickSort(arr,<span class="number">0</span>,n-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面不断的递归分割，直到 <code>l &gt; r</code> 结束递归；你能一步步的看到这里，就可以在纸上，手撸快速排序的代码了。</p>
<h3 id="测试一下">测试一下</h3><p>和前面的一样 还是四种测试用例：</p>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span>有序<span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line">sortname:希尔排序　　	 sorttime: 0.004465s</span><br><span class="line">sortname:归并排序 　　 sorttime: 0.023814s</span><br><span class="line">sortname:快速排序　　	 sorttime: 14.126987s</span><br><span class="line"></span><br><span class="line"><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span>近乎有序<span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line">sortname:希尔排序　　	 sorttime: 0.015746s</span><br><span class="line">sortname:归并排序 　　 sorttime: 0.031117s</span><br><span class="line">sortname:快速排序　　	 sorttime: 0.896174s</span><br><span class="line"></span><br><span class="line"><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span>随机<span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line">sortname:希尔排序　　	 sorttime: 0.034790s</span><br><span class="line">sortname:归并排序 　　 sorttime: 0.037268s</span><br><span class="line">sortname:快速排序　　	 sorttime: 0.018142s</span><br><span class="line"></span><br><span class="line"><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span>倒叙<span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line">sortname:希尔排序　　	 sorttime: 0.010014s</span><br><span class="line">sortname:归并排序 　　 sorttime: 0.024656s</span><br><span class="line">sortname:快速排序　　	 sorttime: 23.304824s</span><br></pre></td></tr></table></figure>
<p>快速排序不是号称最快的排序方法么，可是测试结果说明了一切 😂😂😂</p>
<p>其实我们写的这个并没有经过优化，并且快速排序并非能适应所有的排序场景。</p>
<h2 id="随机化快速排序">随机化快速排序</h2><p>首先想一下归并排序是不是和快速排序的方法很相似啊，不同的是归并排序是等分的而快速排序不是的，是根据选择的基值来分的，我们上面选择的是数组的第一个</p>
<p><img src="http://7xv4w8.com1.z0.glb.clouddn.com/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F09.png" alt="快速排序09"></p>
<p><img src="http://7xv4w8.com1.z0.glb.clouddn.com/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F10.png" alt="快速排序10"></p>
<p>最差的情况是测试用例中 倒叙的：</p>
<p><img src="http://7xv4w8.com1.z0.glb.clouddn.com/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F11.png" alt="快速排序10"></p>
<p>我们想的是：每次得取数组中中间的那个数值作为基值，但这样做需要重新遍历一遍数组，耗费了大量的时间。我们可以去个折中的方法，就是随机取数组中的值作为基值，且看程序：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> __partition_00(<span class="keyword">int</span> arr[],<span class="keyword">int</span> l,<span class="keyword">int</span> r) &#123;</span><br><span class="line">    swap(&amp;arr[l], &amp;arr[rand()%(r-l+<span class="number">1</span>) + l]);</span><br><span class="line">    <span class="keyword">int</span> v = arr[l];</span><br><span class="line">    <span class="keyword">int</span> j = l;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l+<span class="number">1</span>; i &lt;= r; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &lt; v) &#123;</span><br><span class="line">            swap(&amp;arr[j +<span class="number">1</span>], &amp;arr[i]);</span><br><span class="line">            j ++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    swap(&amp;arr[l], &amp;arr[j]);</span><br><span class="line">    <span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序中的 <code>swap(&amp;arr[l], &amp;arr[rand()%(r-l+1) + l]);</code> 就是使用 rand() 函数 随机取了值 和 为l索引上的值交换，作为基值，虽然还是有可能 降为 n^2,但概率远远的降低了。</p>
<p>我们再来看测试：</p>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span>有序<span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line">sortname:希尔排序　　	 sorttime: 0.004857s</span><br><span class="line">sortname:归并排序　　	 sorttime: 0.026325s</span><br><span class="line">sortname:快速排序　　	 sorttime: 14.352925s</span><br><span class="line">sortname:快速排序随机	 sorttime: 0.013611s</span><br><span class="line"></span><br><span class="line"><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span>近乎有序<span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line">sortname:希尔排序　　	 sorttime: 0.012678s</span><br><span class="line">sortname:归并排序　　	 sorttime: 0.025845s</span><br><span class="line">sortname:快速排序　　	 sorttime: 0.632769s</span><br><span class="line">sortname:快速排序随机	 sorttime: 0.013047s</span><br><span class="line"></span><br><span class="line"><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span>随机<span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line">sortname:希尔排序　　	 sorttime: 0.031845s</span><br><span class="line">sortname:归并排序　　	 sorttime: 0.036922s</span><br><span class="line">sortname:快速排序　　	 sorttime: 0.016712s</span><br><span class="line">sortname:快速排序随机	 sorttime: 0.020723s</span><br><span class="line"></span><br><span class="line"><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span>倒序<span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line">sortname:希尔排序　　	 sorttime: 0.010177s</span><br><span class="line">sortname:归并排序　　	 sorttime: 0.023441s</span><br><span class="line">sortname:快速排序　　	 sorttime: 23.705080s</span><br><span class="line">sortname:快速排序随机	 sorttime: 0.014164s</span><br></pre></td></tr></table></figure>
<p>我们再看时间，是不是在性能上有不小的提升</p>
<hr>
<h2 id="双路快速排序">双路快速排序</h2><p>在上面测试的几种用例当中 <code>有大量的重复值</code> 这一项让快速排序慢的不是一点点。那为什么这么慢呢？</p>
<p>我们来看一组测试数据：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">5</span></span><br></pre></td></tr></table></figure>
<p>第一次进行分割之后变成：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">3</span>]   [<span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">5</span>]</span><br></pre></td></tr></table></figure>
<p>相信看到这里大家就明白了，快速排序变成了 O(n^2 ) 了：</p>
<p><img src="http://7xv4w8.com1.z0.glb.clouddn.com/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F11.png" alt="快速排序10"></p>
<p>在这里介绍一种解决方法：双路快速排序</p>
<h3 id="双路快速排序的分析">双路快速排序的分析</h3><p>我们用两路分别从左右两边进行分割；</p>
<ul>
<li><strong>l</strong>:指向选取的 v 在数组的首位；</li>
<li><strong>i</strong>:从左向右指向下一个要扫描的元素；</li>
<li><strong>j</strong>:从右向左指向下一个要扫描的元素；</li>
</ul>
<p><img src="http://7xv4w8.com1.z0.glb.clouddn.com/00-quicksort-twoway.png" alt=""></p>
<blockquote>
<p>然后进行如下操作：</p>
</blockquote>
<ol>
<li>从左向右扫描直到 <strong>&gt;= v</strong> 停止；</li>
<li>从右向左扫描直到 <strong>&lt;= v</strong> 停止；</li>
<li>交换 i 和 j 指向的元素；</li>
<li>i++,j++；</li>
<li>直到 j &lt;= i 停止扫描；</li>
</ol>
<p><img src="http://7xv4w8.com1.z0.glb.clouddn.com/01-quicksort-twoway.png" alt=""></p>
<blockquote>
<p>大家可能会有这样的一个疑问：当 左右的两个 <strong>e 元素</strong> 相等时也会进行交换的</p>
</blockquote>
<p>是的，这样可以确保在一定程度上分割平衡。所以分割实际上是这样的：</p>
<p><em>arr[l+1,i-1] &lt;= v   和 arr[j,r] &gt;= v</em></p>
<h3 id="双路快速排序的程序代码">双路快速排序的程序代码</h3><p>现在分割函数写成了这样：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> __partition_twoWays(<span class="keyword">int</span> arr[],<span class="keyword">int</span> l,<span class="keyword">int</span> r) &#123;</span><br><span class="line">    swap(&amp;arr[l], &amp;arr[rand()%(r-l+<span class="number">1</span>) + l]);</span><br><span class="line">    <span class="keyword">int</span> v = arr[l];</span><br><span class="line">    <span class="keyword">int</span> i = l + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> j = r;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= r &amp;&amp; arr[i] &lt; v) &#123; i ++; &#125;</span><br><span class="line">        <span class="keyword">while</span> (j &gt;= l+<span class="number">1</span> &amp;&amp; arr[j] &gt; v) &#123; j --; &#125;</span><br><span class="line">        <span class="keyword">if</span> (j &lt;= i) &#123; <span class="keyword">break</span>; &#125;</span><br><span class="line">        swap(&amp;arr[i], &amp;arr[j]);</span><br><span class="line">        i++;</span><br><span class="line">        j--;</span><br><span class="line">    &#125;</span><br><span class="line">    swap(&amp;arr[l], &amp;arr[j]);</span><br><span class="line">    <span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="测试">测试</h3><p>我们再来看测试(测试用例 50w个)：</p>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span>有序<span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line">sortname:插入排序优化	 sorttime: 0.002745s</span><br><span class="line">sortname:希尔排序　　	 sorttime: 0.026173s</span><br><span class="line">sortname:快速排序随机	 sorttime: 0.078291s</span><br><span class="line">sortname:快速排序双路	 sorttime: 0.047122s</span><br><span class="line"></span><br><span class="line"><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span>近乎有序<span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line">sortname:插入排序优化	 sorttime: 0.010042s</span><br><span class="line">sortname:希尔排序　　	 sorttime: 0.030206s</span><br><span class="line">sortname:快速排序随机	 sorttime: 0.063545s</span><br><span class="line">sortname:快速排序双路	 sorttime: 0.046858s</span><br><span class="line"></span><br><span class="line"><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span>有大量的重复值<span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line">sortname:希尔排序　　	 sorttime: 0.053225s</span><br><span class="line">sortname:快速排序随机	 sorttime: 27.211613s</span><br><span class="line">sortname:快速排序双路	 sorttime: 0.058205s</span><br><span class="line"></span><br><span class="line"><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span>随机<span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line">sortname:希尔排序　　	 sorttime: 0.179634s</span><br><span class="line">sortname:快速排序随机	 sorttime: 0.102915s</span><br><span class="line">sortname:快速排序双路	 sorttime: 0.102822s</span><br><span class="line"></span><br><span class="line"><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span>倒叙<span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line">sortname:希尔排序　　	 sorttime: 0.056003s</span><br><span class="line">sortname:快速排序随机	 sorttime: 0.065304s</span><br><span class="line">sortname:快速排序双路	 sorttime: 0.048225s</span><br></pre></td></tr></table></figure>
<p>我们可以看到 <strong>双路快速排序</strong> 的时间相比之前快了不少！</p>
<hr>
<h2 id="三路快速排序">三路快速排序</h2><p>关于 <strong>有大量的重复值</strong> 的快速排序还有一种经典的解法 -&gt; 三路快速排序</p>
<h3 id="三路快速排序的分析">三路快速排序的分析</h3><p>我们重新定义了如下几个变量：</p>
<p><img src="http://7xv4w8.com1.z0.glb.clouddn.com/quicksort-thirdway-00.png" alt=""></p>
<ul>
<li><strong>l</strong>:指向选取的 v 在数组的首位；</li>
<li><strong>lt</strong>:从左向右 小于v 的最后一个元素(初始情况: lt = l)；</li>
<li><strong>i</strong>:从左向右指向下一个要扫描的元素(初始情况: i = l + 1)；</li>
<li><strong>gt</strong>:从右向左 大于v 的第一个元素（初始情况: gt = r + 1）；</li>
</ul>
<blockquote>
<p>初始的情况</p>
</blockquote>
<p><img src="http://7xv4w8.com1.z0.glb.clouddn.com/quicksort-thirdway-01.png" alt=""></p>
<blockquote>
<p>当 e == v 时</p>
</blockquote>
<p>这个很简单 直接 i ++ 就行了，如下图</p>
<p><img src="http://7xv4w8.com1.z0.glb.clouddn.com/quicksort-thirdway-02.png" alt=""></p>
<p>然后：</p>
<p><img src="http://7xv4w8.com1.z0.glb.clouddn.com/quicksort-thirdway-03.png" alt=""></p>
<blockquote>
<p>当 e &lt; v 时</p>
</blockquote>
<p>将 <code>i</code> 指向的元素 和 <code>lt+1</code> 指向的元素 交换位置，然后 <strong>i++</strong> , <strong>lt++</strong></p>
<p><img src="http://7xv4w8.com1.z0.glb.clouddn.com/quicksort-thirdway-04.png" alt=""></p>
<p>然后：</p>
<p><img src="http://7xv4w8.com1.z0.glb.clouddn.com/quicksort-thirdway-05.png" alt=""></p>
<blockquote>
<p>当 e &gt; v 时</p>
</blockquote>
<p>将 <code>i</code> 指向的元素 和 <code>gt-1</code> 指向的元素 交换位置，然后 <strong>gt –</strong> </p>
<p><img src="http://7xv4w8.com1.z0.glb.clouddn.com/quicksort-thirdway-06.png" alt=""></p>
<p>然后：</p>
<p><img src="http://7xv4w8.com1.z0.glb.clouddn.com/quicksort-thirdway-07m.png" alt=""></p>
<blockquote>
<p>扫描完成时</p>
</blockquote>
<p><img src="http://7xv4w8.com1.z0.glb.clouddn.com/quicksort-thirdway-08.png" alt=""></p>
<h3 id="三路快速排序的程序代码">三路快速排序的程序代码</h3><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">void __quickSort_threeWays(<span class="keyword">int</span> arr[],<span class="keyword">int</span> l,<span class="keyword">int</span> r) &#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    swap(&amp;arr[l], &amp;arr[<span class="keyword">rand</span>()<span class="variable">%(</span>r-l+<span class="number">1</span>) + l]);</span><br><span class="line">    <span class="keyword">int</span> v = arr[l];</span><br><span class="line">    <span class="regexp">//</span> arr[l+<span class="number">1</span>...<span class="keyword">lt</span>] &lt; v 、 arr[<span class="keyword">lt</span>+<span class="number">1</span>...i-<span class="number">1</span>] == v 和 arr[<span class="keyword">gt</span>...r] &gt; v</span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">lt</span> = l;</span><br><span class="line">    <span class="keyword">int</span> i  = l + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">gt</span> = r + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; <span class="keyword">gt</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &lt; v) &#123;</span><br><span class="line">            swap(&amp;arr[i], &amp;arr[<span class="keyword">lt</span> + <span class="number">1</span>]);</span><br><span class="line">            i++;</span><br><span class="line">            <span class="keyword">lt</span>++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[i] &gt; v) &#123;</span><br><span class="line">            swap(&amp;arr[i], &amp;arr[<span class="keyword">gt</span> - <span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">gt</span> --;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            i ++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    swap(&amp;arr[l], &amp;arr[<span class="keyword">lt</span>]);</span><br><span class="line">    __quickSort_threeWays(arr, l, <span class="keyword">lt</span>-<span class="number">1</span>);</span><br><span class="line">    __quickSort_threeWays(arr, <span class="keyword">gt</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void quickSort_threeWays(<span class="keyword">int</span> arr[],<span class="keyword">int</span> n) &#123;</span><br><span class="line">    <span class="keyword">srand</span>((unsigned)<span class="keyword">time</span>(NULL));</span><br><span class="line">    __quickSort_threeWays(arr,<span class="number">0</span>,n-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="测试-1">测试</h3><p>我们再来看测试(测试用例 50w个)：</p>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span>有序<span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line">sortname:插入排序优化	 sorttime: 0.003101s</span><br><span class="line">sortname:希尔排序　　	 sorttime: 0.023716s</span><br><span class="line">sortname:快速排序随机	 sorttime: 0.070738s</span><br><span class="line">sortname:快速排序双路	 sorttime: 0.057771s</span><br><span class="line">sortname:快速排序三路	 sorttime: 0.110716s</span><br><span class="line"></span><br><span class="line"><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span>近乎有序<span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line">sortname:插入排序优化	 sorttime: 0.014255s</span><br><span class="line">sortname:希尔排序　　	 sorttime: 0.033605s</span><br><span class="line">sortname:快速排序随机	 sorttime: 0.067371s</span><br><span class="line">sortname:快速排序双路	 sorttime: 0.051204s</span><br><span class="line">sortname:快速排序三路	 sorttime: 0.106871s</span><br><span class="line"></span><br><span class="line"><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span>有大量的重复值<span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line">sortname:希尔排序　　	 sorttime: 0.054126s</span><br><span class="line">sortname:快速排序随机	 sorttime: 27.016716s</span><br><span class="line">sortname:快速排序双路	 sorttime: 0.054265s</span><br><span class="line">sortname:快速排序三路	 sorttime: 0.014668s</span><br><span class="line"></span><br><span class="line"><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span>随机<span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line">sortname:希尔排序　　	 sorttime: 0.175923s</span><br><span class="line">sortname:快速排序随机	 sorttime: 0.099126s</span><br><span class="line">sortname:快速排序双路	 sorttime: 0.098717s</span><br><span class="line">sortname:快速排序三路	 sorttime: 0.111747s</span><br><span class="line"></span><br><span class="line"><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span>倒叙<span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line">sortname:希尔排序　　	 sorttime: 0.059569s</span><br><span class="line">sortname:快速排序随机	 sorttime: 0.065489s</span><br><span class="line">sortname:快速排序双路	 sorttime: 0.047557s</span><br><span class="line">sortname:快速排序三路	 sorttime: 0.090296s</span><br></pre></td></tr></table></figure>
<p>我们可以看到对 <strong>有大量的重复值</strong> 排序又快了一点点。当然在其它情况下，三路快速排序的时间都很稳定，所以三路快速排序应当是首选。</p>
<hr>
<h2 id="结束">结束</h2><p>至此，快速排序便介绍完了，后面即将介绍 <strong>堆排序</strong>。</p>
<p>最后附上<a href="https://github.com/xiaerfei/AlgorithmStudy" target="_blank" rel="external">Demo</a></p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2017/03/15/03-merge-sort/" itemprop="url">
                排序算法之归并排序
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2017-03-15T23:15:55+08:00" content="2017-03-15">
            2017-03-15
          </time>
        </span>

        

        
          
        
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><h1 id="排序算法之归并排序及其优化">排序算法之归并排序及其优化</h1><h2 id="归并排序介绍">归并排序介绍</h2><p>归并排序是创建在归并操作上的一种有效的排序算法，效率为O(n log n)。1945年由约翰·冯·诺伊曼首次提出。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用，且各层分治递归可以同时进行。</p>
<h2 id="自顶向下">自顶向下</h2><p>不说废话了，开工。<br>待排数组如下：</p>
<p><img src="http://7xv4w8.com1.z0.glb.clouddn.com/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E5%88%9D%E5%A7%8B%E6%95%B0%E7%BB%84.png" alt="插入排序初始数组"></p>
<h3 id="第一步">第一步</h3><p>我们首先将这 8 个元素，一层一层的分割，如：</p>
<ul>
<li>第一层两组：<strong>[8 , 6, 2 , 3],[ 1, 5, 7, 4]</strong></li>
<li>第二层四组：<strong>[8, 6], [2, 3], [1, 5], [7, 4]</strong></li>
<li>第三层八组：<strong>[8], [6], [2], [3], [1], [5], [7], [4]</strong></li>
</ul>
<p>如下图:</p>
<p><img src="http://7xv4w8.com1.z0.glb.clouddn.com/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F01.png" alt="归并排序01"></p>
<h3 id="第二步_归并操作(Merge)">第二步 归并操作(Merge)</h3><p>从底层开始两两归并（当然也可以三三进行归并），归并之后是有序的。</p>
<p>第三层八组，进行两两归并：</p>
<p><img src="http://7xv4w8.com1.z0.glb.clouddn.com/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F02.png" alt="归并排序02"></p>
<p>第二层四组，进行两两归并：</p>
<p><img src="http://7xv4w8.com1.z0.glb.clouddn.com/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F03.png" alt="归并排序03"></p>
<p>第一层两组，进行两两归并：</p>
<p><img src="http://7xv4w8.com1.z0.glb.clouddn.com/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F04.png" alt="归并排序04"></p>
<p>此时，数组已经排序完成！</p>
<h3 id="第三步_分析程序">第三步 分析程序</h3><p>很明显，上面的是自顶向下，采用的是分治法，我们采用递归的方法，来实现这个算法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    __mergeSort(arr, <span class="number">0</span>, n-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>开始分割：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> __mergeSort(<span class="keyword">int</span> arr[],<span class="keyword">int</span> l,<span class="keyword">int</span> r) &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> mid = l + (r - l)/<span class="number">2</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    __mergeSort(arr, l, mid);</span><br><span class="line">    __mergeSort(arr, mid + <span class="number">1</span>, r);</span><br><span class="line">    </span><br><span class="line">    _merge(arr, l, mid, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意：这里取中间的 mid 有个问题，大多数人都会写成这样：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> mid = (l + r)/<span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<p><strong>这样写不严谨，当<code>l</code>和<code>r</code> 都很大时，<code>(l + r)</code> 会溢出</strong>。</p>
<p>先不断的分割[l,mid],然后[mid+1,r]</p>
<p>最后归并：</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">void _merge(int arr[],int <span class="keyword">l</span>, int mid,int r) &#123;</span><br><span class="line">    int <span class="keyword">count</span> = r-<span class="keyword">l</span>+1;</span><br><span class="line">    int <span class="keyword">ta</span>[<span class="keyword">count</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (int i = <span class="keyword">l</span>; i &lt;= r; i++) &#123;</span><br><span class="line">        int a = i - <span class="keyword">l</span>;</span><br><span class="line">        <span class="keyword">ta</span>[a] = arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int i = <span class="keyword">l</span>,j = mid + 1;</span><br><span class="line">    <span class="keyword">for</span> (int k = <span class="keyword">l</span>; k &lt;= r; k++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; mid) &#123;</span><br><span class="line">            arr[k] = <span class="keyword">ta</span>[j - <span class="keyword">l</span>];</span><br><span class="line">            j ++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (j &gt; r) &#123;</span><br><span class="line">            arr[k] = <span class="keyword">ta</span>[i - <span class="keyword">l</span>];</span><br><span class="line">            i ++ ;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">ta</span>[i - <span class="keyword">l</span>] &lt; <span class="keyword">ta</span>[j - <span class="keyword">l</span>]) &#123;</span><br><span class="line">            arr[k] = <span class="keyword">ta</span>[i-<span class="keyword">l</span>];</span><br><span class="line">            i ++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            arr[k] = <span class="keyword">ta</span>[j - <span class="keyword">l</span>];</span><br><span class="line">            j ++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里创建了一个临时的数组长度为 <code>(r - l) + 1</code> .</p>
<p><strong>注意：如果数据量很大，可能会造成栈溢出，这是归并排序的一个缺点。</strong></p>
<p>咱们来分析一下归并排序的最后一步：</p>
<p><img src="http://7xv4w8.com1.z0.glb.clouddn.com/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F05.png" alt="归并排序05"></p>
<p>先排除边界：</p>
<ul>
<li>当 <code>i &gt; mid</code> 时，说明[l,mid]区间已经结束，所以 [mid+1,r] 直接赋值就行了;</li>
<li>当 <code>j &gt; r</code> 时，说明[mid+1,r]区间已经结束，所以 [l,mid] 直接赋值就行了;</li>
</ul>
<p>开始比较：</p>
<h3 id="第一次比较">第一次比较</h3><p><strong>i -&gt; 2，j -&gt; 1; 2 &gt; 1,将 1 放进去：</strong></p>
<p><img src="http://7xv4w8.com1.z0.glb.clouddn.com/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F06.png" alt="归并排序06"></p>
<h3 id="第二次比较">第二次比较</h3><p>此时数组的状态及各个变量的指向：</p>
<p><img src="http://7xv4w8.com1.z0.glb.clouddn.com/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F07.png" alt="归并排序07"></p>
<p><strong>i -&gt; 2，j -&gt; 4; 2 &lt; 4,将 2 放进去：</strong></p>
<p><img src="http://7xv4w8.com1.z0.glb.clouddn.com/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F08.png" alt="归并排序08"></p>
<h3 id="第三次比较">第三次比较</h3><p>此时数组的状态及各个变量的指向：</p>
<p><img src="http://7xv4w8.com1.z0.glb.clouddn.com/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F09.png" alt="归并排序09"></p>
<p><strong>i -&gt; 3，j -&gt; 4; 3 &lt; 4,将 3 放进去：</strong></p>
<p><img src="http://7xv4w8.com1.z0.glb.clouddn.com/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F11.png" alt="归并排序11"></p>
<h3 id="第四次比较">第四次比较</h3><p>此时数组的状态及各个变量的指向：</p>
<p><img src="http://7xv4w8.com1.z0.glb.clouddn.com/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F10.png" alt="归并排序10"></p>
<p><strong>i -&gt; 6，j -&gt; 4; 6 &gt; 4,将 4 放进去：</strong></p>
<p><img src="http://7xv4w8.com1.z0.glb.clouddn.com/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F12.png" alt="归并排序12"></p>
<p>后面的就不一一解释了，按照这个思路，请继续往下画…</p>
<p>我相信前面的程序，现在是非常清晰了。</p>
<h2 id="自低向上">自低向上</h2><p>其实自低向上很好理解，就是第一步被分割后，开始向上归并，只不过不是使用递归的解法，而是迭代法。</p>
<p>我这里把程序贴出来，大家跟着程序把图画一下，就理解了。</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> mergeSortBackUp(<span class="keyword">int</span> arr[],<span class="keyword">int</span> n) &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> <span class="keyword">size</span> = <span class="number">1</span>; <span class="keyword">size</span> &lt;= n; <span class="keyword">size</span> += <span class="keyword">size</span> ) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i + <span class="keyword">size</span> &lt; n; i += (<span class="keyword">size</span> + <span class="keyword">size</span>)) &#123;</span><br><span class="line">            _merge(arr, i, i + <span class="keyword">size</span> - <span class="number">1</span>, MIN(i + <span class="keyword">size</span> + <span class="keyword">size</span> - <span class="number">1</span>,n-<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意：这里的_merge 函数 用的是上一步的！</strong></p>
<h2 id="测试">测试</h2><p>这里用了 1千万一个数据测试，测试结果如下：</p>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span>有序<span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line">sortname:归并排序 　　	 sorttime: 3.218722s</span><br><span class="line">sortname:归并排序2　　	 sorttime: 2.599350s</span><br><span class="line"></span><br><span class="line"><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span>近乎有序<span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line">sortname:归并排序 　　	 sorttime: 3.078164s</span><br><span class="line">sortname:归并排序2　　	 sorttime: 2.605246s</span><br><span class="line"></span><br><span class="line"><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span>随机<span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line">sortname:归并排序 　　	 sorttime: 4.810648s</span><br><span class="line">sortname:归并排序2　　	 sorttime: 4.118894s</span><br><span class="line"></span><br><span class="line"><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span>倒叙<span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line">sortname:归并排序 　　	 sorttime: 3.054663s</span><br><span class="line">sortname:归并排序2　　	 sorttime: 2.569524s</span><br></pre></td></tr></table></figure>
<hr>
<p>最后附上<a href="https://github.com/xiaerfei/AlgorithmStudy" target="_blank" rel="external">Demo</a></p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2017/03/07/02-shell-sort/" itemprop="url">
                排序算法之希尔排序
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2017-03-07T21:30:10+08:00" content="2017-03-07">
            2017-03-07
          </time>
        </span>

        

        
          
        
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><h2 id="前言">前言</h2><p>希尔排序，也称递减增量排序算法，是插入排序的一种更高效的改进版本。</p>
<p>希尔排序的实质就是分组插入排序，它们的思想高度是一致的的（为了共产主义😁😁😁），不过希尔排序的速度蛮快的，甚至可以与快速排序相媲美！</p>
<p>希尔排序是基于插入排序的以下两点性质而提出改进方法的：</p>
<ul>
<li>插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率；</li>
<li>但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位；</li>
</ul>
<p>不好意思上面的部分来自<a href="https://zh.wikipedia.org/wiki/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F" target="_blank" rel="external">维基百科</a></p>
<p>好了，第一部分介绍完了，我们来看图说画：</p>
<hr>
<h2 id="看图说话">看图说话</h2><p>以一个 n = 11 的数组为例：</p>
<p><img src="http://7xv4w8.com1.z0.glb.clouddn.com/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F01.png" alt="希尔排序01"></p>
<h3 id="第一次">第一次</h3><h4 id="第一步_设步长为_2_则_int_gap_=_11/2_=_5">第一步 设步长为 2 则 int gap = 11/2 = 5</h4><p>将数组分为 5 组，每组两个数据</p>
<p><img src="http://7xv4w8.com1.z0.glb.clouddn.com/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F02.png" alt="希尔排序02"></p>
<h4 id="第二步">第二步</h4><p>那么就被分成了 A B C D E 这几组数据：</p>
<p><img src="http://7xv4w8.com1.z0.glb.clouddn.com/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F03.png" alt="希尔排序03"></p>
<h4 id="第三步">第三步</h4><p>对每组数据进行排序：</p>
<p><img src="http://7xv4w8.com1.z0.glb.clouddn.com/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F04.png" alt="希尔排序04"></p>
<p>于是数组变为下面的：</p>
<p><img src="http://7xv4w8.com1.z0.glb.clouddn.com/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F-05.png" alt="希尔排序05"></p>
<h3 id="第二次">第二次</h3><h4 id="第一步_重复上面第一步_int_gap_=_5/2_=_2">第一步 重复上面第一步 int gap = 5/2 = 2</h4><p>将数组分为 2 组，每组5个数据</p>
<p><img src="http://7xv4w8.com1.z0.glb.clouddn.com/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F-06.png" alt="希尔排序06"></p>
<h4 id="第二步-1">第二步</h4><p>那么就被分成了 A B  这两组数据：</p>
<p><img src="http://7xv4w8.com1.z0.glb.clouddn.com/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F-07.png" alt="希尔排序07"></p>
<h4 id="第三步-1">第三步</h4><p>对每组数据进行排序：</p>
<p><img src="http://7xv4w8.com1.z0.glb.clouddn.com/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F-08.png" alt="希尔排序08"></p>
<p>于是数组变为下面的：</p>
<p><img src="http://7xv4w8.com1.z0.glb.clouddn.com/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F-09.png" alt="希尔排序09"></p>
<h3 id="第三次">第三次</h3><h4 id="第一步_重复上面第一步_int_gap_=_2/2_=_1">第一步 重复上面第一步 int gap = 2/2 = 1</h4><p>将数组分为 1 组，那就是整个数组</p>
<p><img src="http://7xv4w8.com1.z0.glb.clouddn.com/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F-09.png" alt="希尔排序09"></p>
<p>对整个数组进行排序：<br><img src="http://7xv4w8.com1.z0.glb.clouddn.com/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F-10.png" alt="希尔排序10"></p>
<h3 id="第四次">第四次</h3><h4 id="第一步_重复上面第一步_int_gap_=_1/2_=_0">第一步 重复上面第一步 int gap = 1/2 = 0</h4><p>则此时 数组排序已经完成</p>
<hr>
<h3 id="看程序">看程序</h3><p>经过上面的一步步的分析，相信大家已经可以看得懂下面的程序（按照上面的理解即可）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shellsort2</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> j, gap;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (gap = n / <span class="number">2</span>; gap &gt; <span class="number">0</span>; gap /= <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">for</span> (j = gap; j &lt; n; j++)<span class="comment">//从数组第gap个元素开始</span></span><br><span class="line">            <span class="keyword">if</span> (a[j] &lt; a[j - gap])<span class="comment">//每个元素与自己组内的数据进行直接插入排序</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = a[j];</span><br><span class="line">                <span class="keyword">int</span> k = j - gap;</span><br><span class="line">                <span class="keyword">while</span> (k &gt;= <span class="number">0</span> &amp;&amp; a[k] &gt; temp)</span><br><span class="line">                &#123;</span><br><span class="line">                    a[k + gap] = a[k];</span><br><span class="line">                    k -= gap;</span><br><span class="line">                &#125;</span><br><span class="line">                a[k + gap] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="测试">测试</h3><p>下面我们开始测试，同样的四种：</p>
<ol>
<li>有序</li>
<li>近乎有序</li>
<li>随机</li>
<li>倒叙</li>
</ol>
<p>我们测试100W个数据，测试它的排序时间，<a href="https://coding.net/u/xiaerfei/p/baseAlgorithm/git/blob/master/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/SortHelper.c" target="_blank" rel="external">测试用例的程序在这里</a>，测试代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n  = <span class="number">100000</span>;</span><br><span class="line"><span class="comment">// 有序</span></span><br><span class="line"><span class="keyword">int</span> *a = generateSequenceArray(n);</span><br><span class="line"><span class="comment">// 近乎有序</span></span><br><span class="line"><span class="keyword">int</span> *b = generateRandomSequenceArray(n, <span class="number">100</span>);</span><br><span class="line"><span class="comment">// 随机</span></span><br><span class="line"><span class="keyword">int</span> *c = generateRandomArray(n,<span class="number">0</span>,n);</span><br><span class="line"><span class="comment">// 倒叙</span></span><br><span class="line"><span class="keyword">int</span> *d = generateReverseArray(n);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *a1 = copyGenerateRandomArray(a, n);</span><br><span class="line"><span class="keyword">int</span> *a2 = copyGenerateRandomArray(a, n);</span><br><span class="line"><span class="keyword">int</span> *a3 = copyGenerateRandomArray(a, n);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *b1 = copyGenerateRandomArray(b, n);</span><br><span class="line"><span class="keyword">int</span> *b2 = copyGenerateRandomArray(b, n);</span><br><span class="line"><span class="keyword">int</span> *b3 = copyGenerateRandomArray(b, n);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *c1 = copyGenerateRandomArray(c, n);</span><br><span class="line"><span class="keyword">int</span> *c2 = copyGenerateRandomArray(c, n);</span><br><span class="line"><span class="keyword">int</span> *c3 = copyGenerateRandomArray(c, n);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *d1 = copyGenerateRandomArray(d, n);</span><br><span class="line"><span class="keyword">int</span> *d2 = copyGenerateRandomArray(d, n);</span><br><span class="line"><span class="keyword">int</span> *d3 = copyGenerateRandomArray(d, n);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"**************有序*************\n"</span>);</span><br><span class="line">testSort(<span class="string">"插入排序　　"</span>, insertSort,a1, n);</span><br><span class="line">testSort(<span class="string">"插入排序优化"</span>, insertSort2,a2, n);</span><br><span class="line">testSort(<span class="string">"希尔排序　　"</span>, shellsort2,a3, n);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n**************近乎有序*************\n"</span>);</span><br><span class="line">testSort(<span class="string">"插入排序　　"</span>, insertSort,b1, n);</span><br><span class="line">testSort(<span class="string">"插入排序优化"</span>, insertSort2,b2, n);</span><br><span class="line">testSort(<span class="string">"希尔排序　　"</span>, shellsort2,b3, n);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n**************随机*************\n"</span>);</span><br><span class="line">testSort(<span class="string">"插入排序　　"</span>, insertSort,c1, n);</span><br><span class="line">testSort(<span class="string">"插入排序优化"</span>, insertSort2,c2, n);</span><br><span class="line">testSort(<span class="string">"希尔排序　　"</span>, shellsort2,c3, n);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n**************倒叙*************\n"</span>);</span><br><span class="line">testSort(<span class="string">"插入排序　　"</span>, insertSort,d1, n);</span><br><span class="line">testSort(<span class="string">"插入排序优化"</span>, insertSort2,d2, n);</span><br><span class="line">testSort(<span class="string">"希尔排序　　"</span>, shellsort2,d3, n);</span><br><span class="line"></span><br><span class="line"><span class="built_in">free</span>(a);<span class="built_in">free</span>(a1);<span class="built_in">free</span>(a2);<span class="built_in">free</span>(a3);</span><br><span class="line"></span><br><span class="line"><span class="built_in">free</span>(b);<span class="built_in">free</span>(b1);<span class="built_in">free</span>(b2);<span class="built_in">free</span>(b3);</span><br><span class="line"></span><br><span class="line"><span class="built_in">free</span>(c);<span class="built_in">free</span>(c1);<span class="built_in">free</span>(c2);<span class="built_in">free</span>(c3);</span><br><span class="line"></span><br><span class="line"><span class="built_in">free</span>(d);<span class="built_in">free</span>(d1);<span class="built_in">free</span>(d2);<span class="built_in">free</span>(d3);</span><br></pre></td></tr></table></figure>
<p>log如下：</p>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span>有序<span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line">sortname:插入排序　　	 sorttime: 0.000404s</span><br><span class="line">sortname:插入排序优化	 sorttime: 0.000474s</span><br><span class="line">sortname:希尔排序　　	 sorttime: 0.003668s</span><br><span class="line"></span><br><span class="line"><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span>近乎有序<span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line">sortname:插入排序　　	 sorttime: 0.042827s</span><br><span class="line">sortname:插入排序优化	 sorttime: 0.020470s</span><br><span class="line">sortname:希尔排序　　	 sorttime: 0.011824s</span><br><span class="line"></span><br><span class="line"><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span>随机<span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line">sortname:插入排序　　	 sorttime: 17.607321s</span><br><span class="line">sortname:插入排序优化	 sorttime: 8.014994s</span><br><span class="line">sortname:希尔排序　　	 sorttime: 0.032545s</span><br><span class="line"></span><br><span class="line"><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span>倒叙<span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line">sortname:插入排序　　	 sorttime: 35.988631s</span><br><span class="line">sortname:插入排序优化	 sorttime: 16.293709s</span><br><span class="line">sortname:希尔排序　　	 sorttime: 0.009289s</span><br></pre></td></tr></table></figure>
<p>由此可以看出 希尔排序的强悍，特别是对于最坏情况的排序，是未优化过的插入排序的近4000倍！</p>
<p>不知道希尔排序 大家搞明白了么！！！ 😀😀😀</p>
<p>最后附上<a href="https://github.com/xiaerfei/AlgorithmStudy" target="_blank" rel="external">Demo</a></p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2017/03/05/01-insert-sort/" itemprop="url">
                排序算法之插入排序
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2017-03-05T22:28:11+08:00" content="2017-03-05">
            2017-03-05
          </time>
        </span>

        

        
          
        
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><h1 id="排序算法之插入排序">排序算法之插入排序</h1><p>从这周开始，每周我将写一些工作中常用的算法如下：</p>
<ol>
<li><a href="http://0.0.0.0:4000/2017/03/05/bubble-sort/" target="_blank" rel="external">冒泡排序和选择排序</a>；</li>
<li>插入排序；</li>
<li>希尔排序；</li>
<li>归并排序及其优化；</li>
<li>快速排序及其优化；</li>
<li>堆排序；</li>
</ol>
<p>下面开始正文：</p>
<h2 id="插入排序">插入排序</h2><p>关于插入排序的理论部分就不说了，去看<a href="https://zh.wikipedia.org/wiki/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F" target="_blank" rel="external">维基百科</a>，里面有各种语言的实现版本。咱们看图说话，容易理解。</p>
<p>待排数组如下：</p>
<p><img src="http://7xv4w8.com1.z0.glb.clouddn.com/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E5%88%9D%E5%A7%8B%E6%95%B0%E7%BB%84.png" alt="插入排序初始数组"></p>
<h3 id="第一步">第一步</h3><p>我们首先考虑 <code>8</code> 这个元素，只有 <code>8</code> 这一个元素，所以就排好序了。</p>
<p><img src="http://7xv4w8.com1.z0.glb.clouddn.com/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F01.png" alt="插入排序01"></p>
<h3 id="第二步">第二步</h3><p>我们来考虑 <code>6</code> 这个元素：</p>
<p><img src="http://7xv4w8.com1.z0.glb.clouddn.com/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F02.png" alt="插入排序02"></p>
<p>我们要把 <code>6</code> 放在其前面数组中合适的位置，和它前面的 <code>8</code> 相比 <code>6</code> 比 <code>8</code> 要小，所以 <code>6</code> 和 <code>8</code> 要互换位置：</p>
<p><img src="http://7xv4w8.com1.z0.glb.clouddn.com/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F03.png" alt="插入排序03"></p>
<p>此时前两个元素就排好的位置：</p>
<p><img src="http://7xv4w8.com1.z0.glb.clouddn.com/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F04.png" alt="插入排序04"></p>
<h3 id="第三步">第三步</h3><p>我们来考虑 <code>2</code> 这个元素：</p>
<p><img src="http://7xv4w8.com1.z0.glb.clouddn.com/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F05.png" alt="插入排序05"><br>我们把 <code>2</code> 和 <code>8</code> 比，<code>2</code> 比 <code>8</code> 小，所以互换位置：</p>
<p><img src="http://7xv4w8.com1.z0.glb.clouddn.com/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F06.png" alt="插入排序06"><br>然后，把 <code>2</code> 和 <code>6</code> 比，<code>2</code> 比 <code>6</code> 小，所以互换位置：</p>
<p><img src="http://7xv4w8.com1.z0.glb.clouddn.com/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F07.png" alt="插入排序07"></p>
<p>至此前三个元素就排好的位置：</p>
<p><img src="http://7xv4w8.com1.z0.glb.clouddn.com/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F08.png" alt="插入排序08"></p>
<h3 id="第四步">第四步</h3><p>我们来考虑 <code>3</code> 这个元素：</p>
<p><img src="http://7xv4w8.com1.z0.glb.clouddn.com/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F09.png" alt="插入排序09"><br>我们把 <code>3</code> 和 <code>8</code> 比，<code>3</code> 比 <code>8</code> 小，所以互换位置：</p>
<p><img src="http://7xv4w8.com1.z0.glb.clouddn.com/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F10.png" alt="插入排序10"></p>
<p>然后，把 <code>3</code> 和 <code>6</code> 比，<code>3</code> 比 <code>6</code> 小，所以互换位置：</p>
<p><img src="http://7xv4w8.com1.z0.glb.clouddn.com/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F11.png" alt="插入排序11"><br>然后，把 <code>3</code> 和 <code>2</code> 比，<code>3</code> 比 <code>2</code> 大，所以不互换位置。</p>
<p><img src="http://7xv4w8.com1.z0.glb.clouddn.com/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F11.png" alt="插入排序11"><br>至此前四个元素就排好的位置：</p>
<p><img src="http://7xv4w8.com1.z0.glb.clouddn.com/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F12.png" alt="插入排序12"><br>后面就不一一列举了，思路尽在 一二三四步骤中。</p>
<h2 id="写程序">写程序</h2><p>上面的思路理解了，下面的程序就比较好写了：</p>
<p><img src="http://7xv4w8.com1.z0.glb.clouddn.com/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F13.png" alt="插入排序13"><br>我们从数组的索引为 <code>1</code> 的位置开始，因为索引为 <code>0</code> 的位置已经排好序（假设数组长度为 <code>n</code>）即：</p>
<figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">1</span><span class="comment">; i &lt; n; i++) &#123;</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>大范围的确定好了，我们要进行小范围的比较排序了，那么 <code>1</code>位置的元素假设为第 <code>j</code> 位，要和之前的 位置 <code>j-1</code>位置的元素比较，如果大于不需要交换，否则需要交换：那么：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt; <span class="number">0</span>; j--) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr[j] &lt; arr[j - <span class="number">1</span>]) &#123;</span><br><span class="line">        swap(&amp;arr[j], &amp;arr[j-<span class="number">1</span>]);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>故完整的如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt; <span class="number">0</span>; j--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[j] &lt; arr[j - <span class="number">1</span>]) &#123;</span><br><span class="line">            swap(&amp;arr[j], &amp;arr[j-<span class="number">1</span>]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然，也可以这么写(嗯，更好看，装下逼也是可以的😜😜😜)：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt; <span class="number">0</span> &amp;&amp; (arr[j] &lt; arr[j - <span class="number">1</span>]); j--) &#123;</span><br><span class="line">            swap(&amp;arr[j], &amp;arr[j-<span class="number">1</span>]);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="测试">测试</h2><p>下面我们开始测试。测试用例呢 分为四种，分别为：</p>
<ol>
<li>有序</li>
<li>近乎有序</li>
<li>随机</li>
<li>倒叙</li>
</ol>
<p>我们测试10W个数据，测试它的排序时间，<a href="https://coding.net/u/xiaerfei/p/baseAlgorithm/git/blob/master/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/SortHelper.c" target="_blank" rel="external">测试用例的程序在这里</a>，测试代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n  = <span class="number">100000</span>;</span><br><span class="line"><span class="comment">// 有序</span></span><br><span class="line"><span class="keyword">int</span> *a = generateSequenceArray(n);</span><br><span class="line"><span class="comment">// 近乎有序</span></span><br><span class="line"><span class="keyword">int</span> *b = generateRandomSequenceArray(n, <span class="number">100</span>);</span><br><span class="line"><span class="comment">// 随机</span></span><br><span class="line"><span class="keyword">int</span> *c = generateRandomArray(n,<span class="number">0</span>,n);</span><br><span class="line"><span class="comment">// 倒叙</span></span><br><span class="line"><span class="keyword">int</span> *d = generateReverseArray(n);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *a1 = copyGenerateRandomArray(a, n);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *b1 = copyGenerateRandomArray(b, n);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *c1 = copyGenerateRandomArray(c, n);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *d1 = copyGenerateRandomArray(d, n);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"**************有序*************\n"</span>);</span><br><span class="line">testSort(<span class="string">"插入排序　　"</span>, insertSort,a1, n);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n**************近乎有序*************\n"</span>);</span><br><span class="line">testSort(<span class="string">"插入排序　　"</span>, insertSort,b1, n);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n**************随机*************\n"</span>);</span><br><span class="line">testSort(<span class="string">"插入排序　　"</span>, insertSort,c1, n);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n**************倒叙*************\n"</span>);</span><br><span class="line">testSort(<span class="string">"插入排序　　"</span>, insertSort,d1, n);</span><br><span class="line"></span><br><span class="line"><span class="built_in">free</span>(a);<span class="built_in">free</span>(a1);</span><br><span class="line"></span><br><span class="line"><span class="built_in">free</span>(b);<span class="built_in">free</span>(b1);</span><br><span class="line"></span><br><span class="line"><span class="built_in">free</span>(c);<span class="built_in">free</span>(c1);</span><br><span class="line"></span><br><span class="line"><span class="built_in">free</span>(d);<span class="built_in">free</span>(d1);</span><br></pre></td></tr></table></figure>
<p>运行之后的log（这里是在MacBook Pro上测试的结果，其它可能不是这个时间，但大底相同）：</p>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span>有序<span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line">sortname:插入排序　　	 sorttime: 0.000647s</span><br><span class="line"></span><br><span class="line"><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span>近乎有序<span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line">sortname:插入排序　　	 sorttime: 0.051551s</span><br><span class="line"></span><br><span class="line"><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span>随机<span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line">sortname:插入排序　　	 sorttime: 18.110468s</span><br><span class="line"></span><br><span class="line"><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span>倒叙<span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line">sortname:插入排序　　	 sorttime: 36.259288s</span><br></pre></td></tr></table></figure>
<p><strong>由此可以看出：插入排序对于近乎有序的数组用时很少，当数组随机或者是最坏情况，那就比较耗时。</strong></p>
<p>那，我们能不能改进呢？ 答案是可以的</p>
<h2 id="插入排序的优化">插入排序的优化</h2><p>在上面的看图说话中，某个元素要想找到自己的位置，则必须和之前的比较，完了之后可能要交换位置，如果说该元素是最小的，且是最后一个，那要交换 <code>n-1</code> 个了。我们知道 交换元素 是比较耗时的操作，那能不能不交换元素，也能找到它的合适的位置呢？方法还是的有的！采用赋值的方法</p>
<p>我们看第四步：</p>
<p><img src="http://7xv4w8.com1.z0.glb.clouddn.com/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F09.png" alt="插入排序09"><br>进行比较之后 <code>3 比 8 小</code>，我们在这里不进行交换，而是将 <code>3</code> 这个值记录下来为 <code>e = 3</code>,然后将 <code>8 元素值</code> 赋值到 <code>3</code> 的位置</p>
<p><img src="http://7xv4w8.com1.z0.glb.clouddn.com/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F14.png" alt="插入排序14"><br>然后将 <code>e = 3</code> 和 <code>元素 6</code> 比较，<code>3 比 6 小</code>，将 <code>元素 6</code> 赋值给其后一位：</p>
<p><img src="http://7xv4w8.com1.z0.glb.clouddn.com/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F15.png" alt="插入排序15"><br>然后将 <code>e = 3</code> 和 <code>元素 2</code> 比较，<code>3 比 2 大</code>，所以 <code>元素 3</code> 就找到了自己的位置：</p>
<p><img src="http://7xv4w8.com1.z0.glb.clouddn.com/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F16.png" alt="插入排序16"><br>看完图之后，这个思路是不是很清晰，下面的程序也是非常好写的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">int</span> e = arr[i];<span class="comment">//将该元素记录下来</span></span><br><span class="line">   <span class="keyword">int</span> j;</span><br><span class="line">   <span class="keyword">for</span> (j = i; j &gt; <span class="number">0</span> &amp;&amp; arr[j - <span class="number">1</span>] &gt; e; j--) &#123;</span><br><span class="line">       arr[j] = arr[j - <span class="number">1</span>];</span><br><span class="line">   &#125;</span><br><span class="line">   arr[j] = e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="插入排序优化测试">插入排序优化测试</h3><p>我们利用前面的测试方法，测试一下：</p>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span>有序<span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line">sortname:插入排序　　	 sorttime: 0.000647s</span><br><span class="line">sortname:插入排序优化	 sorttime: 0.000554s</span><br><span class="line"></span><br><span class="line"><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span>近乎有序<span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line">sortname:插入排序　　	 sorttime: 0.051551s</span><br><span class="line">sortname:插入排序优化	 sorttime: 0.025874s</span><br><span class="line"></span><br><span class="line"><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span>随机<span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line">sortname:插入排序　　	 sorttime: 18.110468s</span><br><span class="line">sortname:插入排序优化	 sorttime: 8.335453s</span><br><span class="line"></span><br><span class="line"><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span>倒叙<span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line">sortname:插入排序　　	 sorttime: 36.259288s</span><br><span class="line">sortname:插入排序优化	 sorttime: 16.780035s</span><br></pre></td></tr></table></figure>
<p>看看测试时间，这个优化还是有明显的提高的！！！</p>
<p>不知道这一节你掌握了么？😜😜😜</p>
<p>最后附上<a href="https://github.com/xiaerfei/AlgorithmStudy" target="_blank" rel="external">Demo</a></p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2017/02/20/00-bubble-sort/" itemprop="url">
                排序算法之冒泡排序和选择排序
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2017-02-20T22:28:11+08:00" content="2017-02-20">
            2017-02-20
          </time>
        </span>

        

        
          
        
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><p>从这周开始，每周我将写一些工作中常用的算法如下：</p>
<ol>
<li>冒泡排序和选择排序；</li>
<li><a href="http://xiaerfei.github.io/2017/03/05/insert-sort/" target="_blank" rel="external">插入排序</a>；</li>
<li>希尔排序；</li>
<li>归并排序及其优化；</li>
<li>快速排序及其优化；</li>
<li>堆排序；</li>
</ol>
<p>下面开始正文：</p>
<h2 id="冒泡排序">冒泡排序</h2><p>冒泡排序可能是我们学习某种编程语言（大多数都是 C）之后，接触到的第一个排序算法。我在网上找了很多的博客之类的介绍冒泡排序的，但总是总是有点纰漏，比如 分析的和写的例子不一致（😂😂😂），很尴尬。下面我们详细来分析一下冒泡排序的过程：</p>
<p>待排序数组为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="number">6</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">9</span> &#125;</span><br></pre></td></tr></table></figure>
<p><strong>冒泡排序的原理是：<code>临近的``数字两两进行比较</code>,按照<code>从小到大</code>或者<code>从大到小</code>的顺序进行交换。</strong></p>
<p><strong>这里注意：是临近的两个数字两两进行比较，如果非，那就不是冒泡排序。</strong></p>
<p>起始数组如下：</p>
<p><img src="http://7xv4w8.com1.z0.glb.clouddn.com/%E5%86%92%E6%B3%A1-%E8%B5%B7%E5%A7%8B%E6%95%B0%E7%BB%84.png" alt="起始数组"></p>
<ol>
<li>第一趟排序</li>
</ol>
<p>第一次比较： <code>6 &gt; 2</code>  6 大于 2 进行交换，交换后：</p>
<p><img src="http://7xv4w8.com1.z0.glb.clouddn.com/%E5%86%92%E6%B3%A1-%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%AF%94%E8%BE%83.png" alt="00"></p>
<p>第二次比较： <code>6 &gt; 4</code>  6 大于 4 进行交换，交换后：</p>
<p><img src="http://7xv4w8.com1.z0.glb.clouddn.com/%E5%86%92%E6%B3%A1-%E7%AC%AC%E4%BA%8C%E6%AC%A1%E6%AF%94%E8%BE%83.png" alt=""></p>
<p>第三次比较： <code>6 &gt; 1</code>  6 大于 1 进行交换，交换后：</p>
<p><img src="http://7xv4w8.com1.z0.glb.clouddn.com/%E5%86%92%E6%B3%A1-%E7%AC%AC%E4%B8%89%E6%AC%A1%E6%AF%94%E8%BE%83.png" alt=""></p>
<p>第四次比较： <code>6 &gt; 5</code> 6 大于 5 进行交换，交换后：</p>
<p><img src="http://7xv4w8.com1.z0.glb.clouddn.com/%E5%86%92%E6%B3%A1-%E7%AC%AC%E5%9B%9B%E6%AC%A1%E6%AF%94%E8%BE%83.png" alt=""></p>
<p>第五次比较： <code>6 &lt; 9</code> 6 小于 9 不进行交换：</p>
<p><img src="http://7xv4w8.com1.z0.glb.clouddn.com/%E5%86%92%E6%B3%A1-%E7%AC%AC%E4%BA%94%E6%AC%A1%E6%AF%94%E8%BE%83.png" alt=""></p>
<p><strong>后面的第二、三、四、五、六的过程和上面的一样，最终如下面：</strong></p>
<p><img src="http://7xv4w8.com1.z0.glb.clouddn.com/%E5%86%92%E6%B3%A1-%E6%9C%80%E7%BB%88%E6%8E%92%E5%BA%8F.png" alt=""></p>
<p><strong>注意：第二次比较的时候，最后一位就不参与了，因为最大的已经冒了出来，第三次比较，倒数第二位不参与了，以此类推。</strong></p>
<p>至此，程序就很容易写出来了：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n ; i ++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n-i; j ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &lt; arr[j-<span class="number">1</span>]) &#123;</span><br><span class="line">                swap(&amp;arr[j], &amp;arr[j-<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="冒泡排序的优化">冒泡排序的优化</h2><p>我们看一下 每次排序的结果：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">第一次：<span class="number">2</span> <span class="number">4</span> <span class="number">1</span> <span class="number">5</span> <span class="number">6</span> <span class="number">9</span> </span><br><span class="line">第二次：<span class="number">2</span> <span class="number">1</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">9</span> </span><br><span class="line">第三次：<span class="number">1</span> <span class="number">2</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">9</span> </span><br><span class="line">第四次：<span class="number">1</span> <span class="number">2</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">9</span> </span><br><span class="line">第五次：<span class="number">1</span> <span class="number">2</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">9</span> </span><br><span class="line">第六次：<span class="number">1</span> <span class="number">2</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">9</span></span><br></pre></td></tr></table></figure>
<p>从中我们发现第三次的时候，已经排好序了，第四、五、六次没必要执行了，这就是我们要对冒泡排序进行优化的地方。</p>
<p>我们可以设置一个flag ，当没有发生交换的时候，记录一下，这时候数组已经有序了。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubbleSort2</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n &amp;&amp; flag ; i ++) &#123;</span><br><span class="line">        flag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n - i; j ++) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (arr[j] &lt; arr[j-<span class="number">1</span>]) &#123;</span><br><span class="line">                flag = <span class="number">1</span>;</span><br><span class="line">                swap(&amp;arr[j], &amp;arr[j-<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然，还有其他的优化方案，大家不妨搜下。</p>
<h2 id="选择排序">选择排序</h2><p>理解的前面的冒泡排序，选择排序是很容易理解的。选择排序顾名思义，每次循环要找出一个最小的值，然后再交换。</p>
<p>测试用例还是之前的：</p>
<p><img src="http://7xv4w8.com1.z0.glb.clouddn.com/%E5%86%92%E6%B3%A1-%E8%B5%B7%E5%A7%8B%E6%95%B0%E7%BB%84.png" alt="起始数组"></p>
<p>第一次大循环找到最小的值 <code>1</code> 然后和 <code>第0位</code>的交换，交换后：</p>
<p><img src="http://7xv4w8.com1.z0.glb.clouddn.com/%E9%80%89%E6%8B%A9-%E7%AC%AC%E4%B8%80%E6%AC%A1.png" alt=""></p>
<p>第二次大循环找到最小的值 <code>2</code> 然后和 <code>第1位</code>的交换，交换后：</p>
<p><img src="http://7xv4w8.com1.z0.glb.clouddn.com/%E9%80%89%E6%8B%A9-%E7%AC%AC%E4%B8%80%E6%AC%A1.png" alt=""></p>
<p>当然第三次大循环和第二次一样</p>
<p>第四次大循环找到最小的值 <code>5</code> 然后和 <code>第3位</code>的交换，交换后：</p>
<p><img src="http://7xv4w8.com1.z0.glb.clouddn.com/%E5%86%92%E6%B3%A1-%E6%9C%80%E7%BB%88%E6%8E%92%E5%BA%8F.png" alt=""><br>后面的就已经排序好了。</p>
<p><strong>从上面可以看出，选择排序是一个不断寻找最小值的排序方法。</strong></p>
<p>所以代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">selectSort</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> minIndex = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &lt; arr[minIndex]) &#123;</span><br><span class="line">                minIndex = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(&amp;arr[i], &amp;arr[minIndex]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>是不是很简单 😁😁😁！</p>
<p>最后附上<a href="https://github.com/xiaerfei/AlgorithmStudy" target="_blank" rel="external">Demo</a></p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2017/02/14/Multi-thread/" itemprop="url">
                iOS多线程
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2017-02-14T15:00:40+08:00" content="2017-02-14">
            2017-02-14
          </time>
        </span>

        

        
          
        
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><h2 id="iOS多线程">iOS多线程</h2><h3 id="前言">前言</h3><p>在这篇文章中我整理了iOS多线程开发需要的一些知识点、方法和事项。本文主要讲述三部分 NSThread、Operation 和 GCD。<br><br>本文不算是原创，是一些我觉得写的比较有质量文章的综合，文中摘抄了这些文章中的部分内容，在文中和文章末尾我已标注出处，之所以要摘抄是因为在需要之时，打开URL 是404 😂😂😂。我综合了这些文中给自己学习之用，也给大家方便查看之用，如有错误之处，见谅，不过欢迎指出。</p>
<h3 id="基本概念">基本概念</h3><p>我们先了解一线iOS多线程的一些基本概念(<a href="http://blog.leichunfeng.com/blog/2015/07/29/ios-concurrency-programming-operation-queues/#jtss-tsina" target="_blank" rel="external">这些基本概念参考了这里</a>)：</p>
<ul>
<li>进程（process）:指的是一个正在运行中的可执行文件。每一个进程都拥有独立的虚拟内存空间和系统资源，包括端口权限等，且至少包含一个主线程和任意数量的辅助线程（说白了就是：用于指代一个可执行程序，他可以包含多个线程）。另外，当一个进程的主线程退出时，这个进程就结束了；</li>
<li>线程（thread）:指的是一个独立的代码执行路径，也就是说线程是代码执行路径的最小分支。在 iOS 中，线程的底层实现是基于 <a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/Multithreading/Introduction/Introduction.html" target="_blank" rel="external">POSIX threads API</a> 的，也就是我们常说的 pthreads ；</li>
<li>任务（task），指的是我们需要执行的工作，是一个抽象的概念，用通俗的话说，就是一段代码。</li>
</ul>
<p><br></p>
<h4 id="串行_和_并发">串行 和 并发</h4><p>从本质上来说，串行和并发的主要区别在于允许同时执行的任务数量。</p>
<ul>
<li>串行：指的是一次只能执行一个任务，必须等一个任务执行完成后才能执行下一个任务；</li>
<li>并发：指的是允许多个任务在一段时间内同时执行。</li>
</ul>
<p><br></p>
<h4 id="同步_和_异步">同步 和 异步</h4><p>同步和异步操作的主要区别在于是否等待操作执行完成，亦即是否阻塞当前线程。</p>
<ul>
<li>同步操作：等待操作执行完成后再继续执行接下来的代码；</li>
<li>异步操作：它会在调用后立即返回，不会等待操作的执行结果。</li>
</ul>
<p><br></p>
<h4 id="队列_和_线程">队列 和 线程</h4><p>在 iOS 中，有两种不同类型的队列，分别是串行队列和并发队列。正如我们上面所说的，串行队列一次只能执行一个任务，而并发队列则可以允许多个任务同时执行。iOS 系统就是使用这些队列来进行任务调度的，它会根据调度任务的需要和系统当前的负载情况动态地创建和销毁线程，而不需要我们手动地管理</p>
<p><br></p>
<h4 id="iOS中的几种多线程类型">iOS中的几种多线程类型</h4><p>iOS 中其实目前有 4 种多线程，他们分别是：</p>
<ul>
<li>Pthreads：非常底层的东东；</li>
<li>NSThread：封装性最差，最偏向于底层，主要基于thread使用；</li>
<li>GCD：基于C的API，直接使用比较方便，主要基于task使用；</li>
<li>NSOperation &amp; NSOperationQueue：基于GCD封装的NSObject对象，对于复杂的多线程项目使用比较方便，主要基于队列使用。</li>
</ul>
<hr>
<p>下面开始介绍这几种类型<br><br></p>
<h3 id="Pthreads">Pthreads</h3><p>POSIX线程（POSIX threads），简称Pthreads，是线程的POSIX标准。该标准定义了创建和操纵线程的一整套API。在类Unix操作系统（Unix、Linux、Mac OS X等）中，都使用Pthreads作为操作系统的线程。<br><br>这个需要自己管理线程的生命周期，创建和销毁，写起来也是相当麻烦，若非是写一些非常底层的几乎是用不到的，这里暂时略过，如需要可自行去理解。<br><br></p>
<h3 id="NSThread">NSThread</h3><p>NSThread是苹果封装的，并且是面向对象的，这对我们来说就简便了许多，但是它的生命周期还是需要我们手动管理的；NSThread除Pthreads之外唯一一个基于线程封装的，每一个NSThread对象代表着一个线程。(<a href="http://www.jianshu.com/p/8ed06312d8bd" target="_blank" rel="external">这部分参考了这里</a>)<br><br></p>
<h4 id="线程的创建">线程的创建</h4><p>NSThread提供了2种创建线程的方法:</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="typename">void</span>)<span class="string">detachNewThreadSelector:</span>(SEL)selector <span class="string">toTarget:</span>(id)target <span class="string">withObject:</span>(nullable id)argument;</span><br><span class="line">- (instancetype)<span class="string">initWithTarget:</span>(id)target <span class="string">selector:</span>(SEL)selector <span class="string">object:</span>(nullable id)argument</span><br></pre></td></tr></table></figure>
<ul>
<li>detach方法直接创建并启动一个线程去Selector，由于没有返回值，如果需要获取新创建的Thread，需要在执行的Selector中调用-[NSThread currentThread]获取;</li>
<li>init方法初始化线程并返回，线程的入口函数由Selector传入。线程创建出来之后需要手动调用-start方法启动;<br><br><h4 id="线程操作">线程操作</h4>NSThread给线程提供的主要操作方法有启动，睡眠，取消，退出<br><br><h4 id="启动">启动</h4>使用init方法将线程创建出来之后，线程并不会立即运行，需要手动调用-start方法才会启动线程：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)<span class="function">start <span class="title">NS_AVAILABLE</span><span class="params">(<span class="number">10</span>_5, <span class="number">2</span>_0)</span></span>;</span><br></pre></td></tr></table></figure>
<p>在启动之前可以设置 线程的名称(当然启动后也可以在Selecter 中设置也可以)：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (nullable, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *name <span class="built_in">NS_AVAILABLE</span>(<span class="number">10</span>_5, <span class="number">2</span>_0);</span><br></pre></td></tr></table></figure>
<p>不过优先级 需要在 start 之前 设置，否则会无效：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@<span class="function">property NSQualityOfService qualityOfService <span class="title">NS_AVAILABLE</span><span class="params">(<span class="number">10</span>_10, <span class="number">8</span>_0)</span></span>;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h4 id="睡眠">睡眠</h4><p>NSThread提供了2个让线程睡眠的方法:</p>
<ul>
<li>根据NSDate传入睡眠时间；</li>
<li>直接传入NSTimeInterval</li>
</ul>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="tag">void</span>)<span class="rule"><span class="attribute">sleepUntilDate</span>:<span class="value">(NSDate *)date</span></span>;</span><br><span class="line">+ (<span class="tag">void</span>)<span class="rule"><span class="attribute">sleepForTimeInterval</span>:<span class="value">(NSTimeInterval)ti</span></span>;</span><br></pre></td></tr></table></figure>
<p>这里讲一下  sleepUntilDate:  和   runloop的runUntilDate: 上的一些区别：</p>
<ul>
<li>sleepUntilDate:相当于执行一个sleep的任务。在执行过程中，即使有其他任务传入runloop，runloop也不会立即响应，必须sleep任务完成之后，才会响应其他任务；</li>
<li>runUntilDate:虽然会阻塞线程，阻塞过程中并不妨碍新任务的执行。当有新任务的时候，会先执行接收到的新任务，新任务执行完之后，如果时间到了，再继续执行runUntilDate:之后的代码；</li>
</ul>
<p><br></p>
<h4 id="取消">取消</h4><p>NSThread提供了一个取消的方法和一个属性：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@property (readonly, getter=isCancelled) <span class="function">BOOL cancelled <span class="title">NS_AVAILABLE</span><span class="params">(<span class="number">10</span>_5, <span class="number">2</span>_0)</span></span>;</span><br><span class="line">- (<span class="keyword">void</span>)<span class="function">cancel <span class="title">NS_AVAILABLE</span><span class="params">(<span class="number">10</span>_5, <span class="number">2</span>_0)</span></span>;</span><br></pre></td></tr></table></figure>
<p>这里 cancel 方法要注意：调用-cancel方法并不会立刻取消线程，它仅仅是将cancelled属性设置为YES。cancelled也仅仅是一个用于记录状态的属性。线程取消的功能需要我们在main函数中自己实现；<br><br>要实现取消的功能，我们需要自己在线程的main函数中定期检查isCancelled状态来判断线程是否需要退出，当isCancelled为YES的时候，需要手动退出。<br></p>
<h4 id="退出">退出</h4><p>-exit函数可以让线程立即退出。<br><br>停止方法会立即终止除主线程以外所有线程（无论是否在执行任务）并退出，需要在掌控所有线程状态的情况下调用此方法，否则可能会导致内存问题。<br></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">void</span>)<span class="built_in">exit</span>;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h4 id="主线程和当前线程">主线程和当前线程</h4><p>NSThread提供了非常方便的获取和判断主线程的API：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@property (readonly) <span class="function">BOOL isMainThread <span class="title">NS_AVAILABLE</span><span class="params">(<span class="number">10</span>_5, <span class="number">2</span>_0)</span></span>;</span><br><span class="line">+ (BOOL)<span class="function">isMainThread <span class="title">NS_AVAILABLE</span><span class="params">(<span class="number">10</span>_5, <span class="number">2</span>_0)</span></span>; <span class="comment">// reports whether current thread is main</span></span><br><span class="line">+ (NSThread *)<span class="function">mainThread <span class="title">NS_AVAILABLE</span><span class="params">(<span class="number">10</span>_5, <span class="number">2</span>_0)</span></span>;</span><br></pre></td></tr></table></figure>
<p>获取当前线程：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">+ </span>(NSThread *)currentThread;</span><br></pre></td></tr></table></figure>
<p>是否为多线程：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ <span class="list">(<span class="keyword">BOOL</span>)</span>isMultiThreaded<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>关于isMultiThreaded 苹果在这里作了解释(相信你能看懂 😜😜😜)：</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Return</span> <span class="type">Value</span></span><br><span class="line"><span class="type">YES</span> <span class="keyword">if</span> the application <span class="keyword">is</span> multithreaded, <span class="type">NO</span> otherwise.</span><br><span class="line"></span><br><span class="line"><span class="type">Discussion</span></span><br><span class="line"><span class="type">An</span> application <span class="keyword">is</span> considered multithreaded <span class="keyword">if</span> a thread was ever detached <span class="keyword">from</span> the main thread <span class="keyword">using</span> either detachNewThreadSelector:toTarget:withObject: <span class="keyword">or</span> start. <span class="type">If</span> you detached a thread <span class="keyword">in</span> your application <span class="keyword">using</span> a non-<span class="type">Cocoa</span> <span class="type">API</span>, such <span class="keyword">as</span> the <span class="type">POSIX</span> <span class="keyword">or</span> <span class="type">Multiprocessing</span> <span class="type">Services</span> <span class="type">APIs</span>, this <span class="keyword">method</span> could still <span class="keyword">return</span> <span class="type">NO</span>. <span class="type">The</span> detached thread does <span class="keyword">not</span> have to be currently running <span class="keyword">for</span> the application to be considered multithreaded—this <span class="keyword">method</span> only indicates whether a single thread has been spawned.</span><br></pre></td></tr></table></figure>
<p><br></p>
<h4 id="线程优先级">线程优先级</h4><p>NSThread有4个优先级的API：</p>
<p>这两个用于设置和获取当前线程的优先级：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="tag">double</span>)<span class="tag">threadPriority</span>;</span><br><span class="line">+ (<span class="tag">BOOL</span>)<span class="rule"><span class="attribute">setThreadPriority</span>:<span class="value">(double)p</span></span>;</span><br></pre></td></tr></table></figure>
<p>后两个通过对象设置和获取优先级：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@<span class="function">property <span class="keyword">double</span> threadPriority <span class="title">NS_AVAILABLE</span><span class="params">(<span class="number">10</span>_6, <span class="number">4</span>_0)</span></span>; <span class="comment">// To be deprecated; use qualityOfService below</span></span><br><span class="line">@<span class="function">property NSQualityOfService qualityOfService <span class="title">NS_AVAILABLE</span><span class="params">(<span class="number">10</span>_10, <span class="number">8</span>_0)</span></span>; <span class="comment">// read-only after the thread is started</span></span><br></pre></td></tr></table></figure>
<p>在iOS 8 之前：</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">[NSThread setThreadPriority:1.0]</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>这个方法的优先级的数值设置让人困惑，因为你不知道你应该设置多大的值是比较合适的，因此在iOS8之后，threadPriority添加了一句注释：To be deprecated; use qualityOfService below <br><br>意为iOS 8以后推荐使用qualityOfService属性：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSInteger</span>, <span class="built_in">NSQualityOfService</span>) &#123;</span><br><span class="line">    <span class="built_in">NSQualityOfServiceUserInteractive</span> = <span class="number">0x21</span>, 最高优先级，用于用户交互事件</span><br><span class="line">    <span class="built_in">NSQualityOfServiceUserInitiated</span> = <span class="number">0x19</span>,   次高优先级，用于用户需要马上执行的事件</span><br><span class="line">    <span class="built_in">NSQualityOfServiceUtility</span> = <span class="number">0x11</span>,         普通优先级，用于普通任务       </span><br><span class="line">    <span class="built_in">NSQualityOfServiceBackground</span> = <span class="number">0x09</span>,      最低优先级，用于不重要的任务</span><br><span class="line">    <span class="built_in">NSQualityOfServiceDefault</span> = -<span class="number">1</span>            默认优先级，主线程和没有设置优先级的线程都默认为这个优先级</span><br><span class="line">&#125; <span class="built_in">NS_ENUM_AVAILABLE</span>(<span class="number">10</span>_10, <span class="number">8</span>_0);</span><br></pre></td></tr></table></figure>
<p>比如给线程设置次高优先级：</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">[newThread setQualityOfService:NSQualityOfServiceUserInitiated]</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p><br></p>
<h4 id="线程通讯">线程通讯</h4><p>创建线程之后，经常需要从主线程把耗时的任务丢给辅助线程，当任务完成之后辅助线程再把结果传回主线程传，这些线程通讯一般用的都是perform方法：</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)performSelectorOnMainThread:(<span class="type">SEL</span>)aSelector withObject:(nullable id)arg waitUntilDone:(<span class="type">BOOL</span>)wait modes:(nullable <span class="type">NSArray</span>&lt;<span class="type">NSString</span> *&gt; *)<span class="type">array</span>;</span><br><span class="line">- (<span class="type">void</span>)performSelectorOnMainThread:(<span class="type">SEL</span>)aSelector withObject:(nullable id)arg waitUntilDone:(<span class="type">BOOL</span>)wait;</span><br><span class="line">	// equivalent to the first <span class="keyword">method</span> <span class="keyword">with</span> kCFRunLoopCommonModes</span><br><span class="line">- (<span class="type">void</span>)performSelector:(<span class="type">SEL</span>)aSelector onThread:(<span class="type">NSThread</span> *)thr withObject:(nullable id)arg waitUntilDone:(<span class="type">BOOL</span>)wait modes:(nullable <span class="type">NSArray</span>&lt;<span class="type">NSString</span> *&gt; *)<span class="type">array</span> <span class="type">NS_AVAILABLE</span>(<span class="number">10_5</span>, <span class="number">2_0</span>);</span><br><span class="line">- (<span class="type">void</span>)performSelector:(<span class="type">SEL</span>)aSelector onThread:(<span class="type">NSThread</span> *)thr withObject:(nullable id)arg waitUntilDone:(<span class="type">BOOL</span>)wait <span class="type">NS_AVAILABLE</span>(<span class="number">10_5</span>, <span class="number">2_0</span>);</span><br><span class="line">	// equivalent to the first <span class="keyword">method</span> <span class="keyword">with</span> kCFRunLoopCommonModes</span><br></pre></td></tr></table></figure>
<p>①：将selector丢给主线程执行，可以指定runloop mode<br><br>②：将selector丢给主线程执行，runloop mode默认为common mode<br><br>③：将selector丢个指定线程执行，可以指定runloop mode<br><br>④：将selector丢个指定线程执行，runloop mode默认为default mode<br><br>一般用③④方法将任务丢给辅助线程，任务执行完成之后再使用①②方法将结果传回主线程<br><br>注意：perform方法只对拥有runloop的线程有效，如果创建的线程没有添加runloop，perform的selector将无法执行。<br><br><br></p>
<h4 id="线程通知">线程通知</h4><p>NSThread有三个线程相关的通知:</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FOUNDATION_EXPORT <span class="built_in">NSString</span> * <span class="keyword">const</span> <span class="built_in">NSWillBecomeMultiThreadedNotification</span>;</span><br><span class="line">FOUNDATION_EXPORT <span class="built_in">NSString</span> * <span class="keyword">const</span> <span class="built_in">NSDidBecomeSingleThreadedNotification</span>;</span><br><span class="line">FOUNDATION_EXPORT <span class="built_in">NSString</span> * <span class="keyword">const</span> <span class="built_in">NSThreadWillExitNotification</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>NSWillBecomeMultiThreadedNotification：由当前线程派生出第一个其他线程时发送；</li>
<li>NSDidBecomeSingleThreadedNotification：暂时不知道；</li>
<li>NSThreadWillExitNotification：线程退出时发送；</li>
</ul>
<p><br></p>
<h4 id="NSThread的简单使用">NSThread的简单使用</h4><p>NSThread 创建还是很简单的：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSThread</span> *thread = [[<span class="built_in">NSThread</span> alloc] initWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(threadAction) object:<span class="literal">nil</span>];</span><br><span class="line">thread<span class="variable">.name</span> = <span class="string">@"com.myCreate.www"</span>;</span><br><span class="line">[thread start];</span><br></pre></td></tr></table></figure>
<p>在线程启动之后会首先执行-threadAction，正常情况下threadAction方法执行结束之后，线程就会退出。为了线程可以长期复用接收消息，我们需要给线程加上runLoop</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)threadAction</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"当前线程：%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    <span class="built_in">NSRunLoop</span> *runLoop = [<span class="built_in">NSRunLoop</span> currentRunLoop];</span><br><span class="line">    [runLoop addPort:[<span class="built_in">NSMachPort</span> port] forMode:<span class="built_in">NSDefaultRunLoopMode</span>];</span><br><span class="line">    <span class="keyword">while</span> (![[<span class="built_in">NSThread</span> currentThread] isCancelled]) &#123;</span><br><span class="line">        [runLoop runMode:<span class="built_in">NSDefaultRunLoopMode</span> beforeDate:[<span class="built_in">NSDate</span> dateWithTimeIntervalSinceNow:<span class="number">10</span>]];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>自定义的线程默认是没有runloop的，调用-currentRunLoop，方法内部会为线程创建runloop；</li>
<li>如果没有数据源，runloop会在启动之后会立刻退出。所以需要给runloop添加一个数据源，这里添加的是NSPort数据源；</li>
<li>定期检查isCancelled，当外部调用-cancel方法将isCancelled置为YES的时候，线程可以退出；</li>
</ul>
<p><br></p>
<h4 id="结束线程">结束线程</h4><p>当我们想要结束线程的时候，我们可以使用CFRunLoopStop()配合-cancel来结束线程：</p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">[<span class="list">[<span class="keyword">NSThread</span> currentThread] cancel]<span class="comment">;</span></span><br><span class="line">CFRunLoopStop<span class="list">(<span class="keyword">CFRunLoopGetCurrent</span><span class="list">()</span>)</span><span class="comment">;</span></span></span></span><br></pre></td></tr></table></figure>
<p><br></p>
<h4 id="NSThread的一个小例子">NSThread的一个小例子</h4><p>这个例子很好的说明了NSThread使用时要注意些什么。<br><br>这个例子是：模拟售票<a href="http://www.jianshu.com/p/334bde6790be#" target="_blank" rel="external">这个例子来自这</a><br><br>情景：某演唱会门票发售，在广州和北京均开设窗口进行销售<br><br>下面是主要代码：新建两个线程<br></p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"***************售票开始****************"</span>);</span><br><span class="line"><span class="built_in">NSThread</span> *saleTicketsWindow_1 = [[<span class="built_in">NSThread</span> alloc] initWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(saleTicketsWindow_Action) object:<span class="literal">nil</span>];</span><br><span class="line">saleTicketsWindow_1<span class="variable">.name</span> = <span class="string">@"北京售票中心"</span>;</span><br><span class="line">[saleTicketsWindow_1 start];</span><br><span class="line">   </span><br><span class="line"><span class="built_in">NSThread</span> *saleTicketsWindow_2 = [[<span class="built_in">NSThread</span> alloc] initWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(saleTicketsWindow_Action) object:<span class="literal">nil</span>];</span><br><span class="line">saleTicketsWindow_2<span class="variable">.name</span> = <span class="string">@"广州售票中心"</span>;</span><br><span class="line">[saleTicketsWindow_2 start];</span><br></pre></td></tr></table></figure>
<p>开始执行售票<br></p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)saleTicketsWindow_Action</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (_ticketCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            _ticketCount --;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"剩余票数：%ld 窗口：%@"</span>, _ticketCount, [<span class="built_in">NSThread</span> currentThread]<span class="variable">.name</span>]);</span><br><span class="line">            [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">0.2</span>];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"***************售票完成****************"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">10</span> <span class="number">17</span>:<span class="number">54</span>:<span class="number">22.636</span> NSThreadTest[<span class="number">2323</span>:<span class="number">1382484</span>] 剩余票数：<span class="number">9</span> 窗口：广州售票中心</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">10</span> <span class="number">17</span>:<span class="number">54</span>:<span class="number">22.636</span> NSThreadTest[<span class="number">2323</span>:<span class="number">1382483</span>] 剩余票数：<span class="number">10</span> 窗口：北京售票中心</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">10</span> <span class="number">17</span>:<span class="number">54</span>:<span class="number">22.841</span> NSThreadTest[<span class="number">2323</span>:<span class="number">1382483</span>] 剩余票数：<span class="number">7</span> 窗口：北京售票中心</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">10</span> <span class="number">17</span>:<span class="number">54</span>:<span class="number">22.841</span> NSThreadTest[<span class="number">2323</span>:<span class="number">1382484</span>] 剩余票数：<span class="number">8</span> 窗口：广州售票中心</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">10</span> <span class="number">17</span>:<span class="number">54</span>:<span class="number">23.043</span> NSThreadTest[<span class="number">2323</span>:<span class="number">1382484</span>] 剩余票数：<span class="number">5</span> 窗口：广州售票中心</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">10</span> <span class="number">17</span>:<span class="number">54</span>:<span class="number">23.043</span> NSThreadTest[<span class="number">2323</span>:<span class="number">1382483</span>] 剩余票数：<span class="number">6</span> 窗口：北京售票中心</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">10</span> <span class="number">17</span>:<span class="number">54</span>:<span class="number">23.244</span> NSThreadTest[<span class="number">2323</span>:<span class="number">1382484</span>] 剩余票数：<span class="number">4</span> 窗口：广州售票中心</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">10</span> <span class="number">17</span>:<span class="number">54</span>:<span class="number">23.244</span> NSThreadTest[<span class="number">2323</span>:<span class="number">1382483</span>] 剩余票数：<span class="number">3</span> 窗口：北京售票中心</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">10</span> <span class="number">17</span>:<span class="number">54</span>:<span class="number">23.449</span> NSThreadTest[<span class="number">2323</span>:<span class="number">1382483</span>] 剩余票数：<span class="number">1</span> 窗口：北京售票中心</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">10</span> <span class="number">17</span>:<span class="number">54</span>:<span class="number">23.449</span> NSThreadTest[<span class="number">2323</span>:<span class="number">1382484</span>] 剩余票数：<span class="number">2</span> 窗口：广州售票中心</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">10</span> <span class="number">17</span>:<span class="number">54</span>:<span class="number">23.655</span> NSThreadTest[<span class="number">2323</span>:<span class="number">1382483</span>] 剩余票数：<span class="number">0</span> 窗口：北京售票中心</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">10</span> <span class="number">17</span>:<span class="number">54</span>:<span class="number">23.655</span> NSThreadTest[<span class="number">2323</span>:<span class="number">1382484</span>] ***************售票完成****************</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">10</span> <span class="number">17</span>:<span class="number">54</span>:<span class="number">23.656</span> NSThreadTest[<span class="number">2323</span>:<span class="number">1382484</span>] 线程退出了：广州售票中心</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">10</span> <span class="number">17</span>:<span class="number">54</span>:<span class="number">23.861</span> NSThreadTest[<span class="number">2323</span>:<span class="number">1382483</span>] ***************售票完成****************</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">10</span> <span class="number">17</span>:<span class="number">54</span>:<span class="number">23.861</span> NSThreadTest[<span class="number">2323</span>:<span class="number">1382483</span>] 线程退出了：北京售票中心</span><br></pre></td></tr></table></figure>
<p>可以看到，票的销售过程中出现了剩余数量错乱的情况，这就是线程同步问题。<br><br>售票是一个典型的需要线程同步的场景，由于售票渠道有很多，而票的资源是有限的，当多个渠道在短时间内卖出大量的票的时候，如果没有同步机制来管理票的数量，将会导致票的总数和售出票数对应不上的错误。<br></p>
<p>iOS实现线程加锁有几种方式，现在使用NSLock或@synchronized两种方式都可行<br></p>
<p>使用NSLock:<br></p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    [_lock lock];</span><br><span class="line">    <span class="keyword">if</span> (_ticketCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        _ticketCount --;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"剩余票数：%ld 窗口：%@"</span>, _ticketCount, [<span class="built_in">NSThread</span> currentThread]<span class="variable">.name</span>]);</span><br><span class="line">        [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">0.2</span>];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"***************售票完成****************"</span>);</span><br><span class="line">        [_lock unlock];</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    [_lock unlock];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用@synchronized:<br></p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">@synchronized</span>(<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (_ticketCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            _ticketCount --;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"剩余票数：%ld 窗口：%@"</span>, _ticketCount, [<span class="built_in">NSThread</span> currentThread]<span class="variable">.name</span>]);</span><br><span class="line">            [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">0.2</span>];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"***************售票完成****************"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="NSOperation">NSOperation</h3><p>NSOperation 只是一个抽象类，所以不能封装任务，因此，如果我们想要使用它来执行具体任务的话，就必须创建自己的子类或使用它的 2 个子类。分别是：NSInvocationOperation 和 NSBlockOperation 。创建一个 Operation 后，需要调用 start 方法来启动任务，它会 默认在当前队列同步执行。当然你也可以在中途取消一个任务，只需要调用其 cancel 方法即可。</p>
<h4 id="NSInvocationOperation">NSInvocationOperation</h4><p>下面是NSInvocationOperation的简单使用，可以看到 NSInvocationOperation 开始任务之后是在主线程执行任务的。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.创建对象</span></span><br><span class="line"><span class="built_in">NSInvocationOperation</span> *operation = [[<span class="built_in">NSInvocationOperation</span> alloc] initWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(invocationAction) object:<span class="literal">nil</span>];</span><br><span class="line"><span class="comment">//2.开始执行</span></span><br><span class="line">[operation start];</span><br><span class="line"><span class="comment">//3.结果</span></span><br><span class="line"><span class="comment">/*</span><br><span class="line"> 2016-05-06 05:53:43.219 NSOperationTest[5885:2491863] NSInvocationOperation --- &lt;NSThread: 0x7fa269c06dc0&gt;&#123;number = 1, name = main&#125;</span><br><span class="line"> 是在主线程</span><br><span class="line"> */</span></span><br></pre></td></tr></table></figure>
<h4 id="NSBlockOperation">NSBlockOperation</h4><p>NSBlockOperation 默认会在当前线程执行任务。但是 NSBlockOperation 还有一个方法：addExecutionBlock: ，通过这个方法可以给 Operation 添加多个执行 Block。这样 Operation 中的任务 会并发执行，它会 在主线程和其它的多个线程执行这些任务.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">NSBlockOperation *blockOperation = [NSBlockOperation blockOperationWithBlock:^&#123;</span><br><span class="line">    NSLog(@<span class="string">"NSBlockOperation --- %@"</span>, [NSThread currentThread]);</span><br><span class="line">&#125;];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    [blockOperation addExecutionBlock:^&#123;</span><br><span class="line">        NSLog(@<span class="string">"NSBlockOperation 第%d次：%@"</span>, i, [NSThread currentThread]);</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br><span class="line">[blockOperation start];</span><br><span class="line"></span><br><span class="line"> <span class="number">2016</span>-<span class="number">05</span>-<span class="number">06</span> <span class="number">05</span>:<span class="number">57</span>:<span class="number">46.227</span> NSBlockOperationTest[<span class="number">5921</span>:<span class="number">2510961</span>] NSBlockOperation --- &lt;NSThread: <span class="number">0x7fc4c0401af0</span>&gt;&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line"> </span><br><span class="line"> <span class="number">2016</span>-<span class="number">05</span>-<span class="number">06</span> <span class="number">06</span>:<span class="number">01</span>:<span class="number">25.939</span> NSBlockOperationTest[<span class="number">5939</span>:<span class="number">2525676</span>] NSBlockOperation 第<span class="number">2</span>次：&lt;NSThread: <span class="number">0x7fb6cbe04590</span>&gt;&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line"> <span class="number">2016</span>-<span class="number">05</span>-<span class="number">06</span> <span class="number">06</span>:<span class="number">01</span>:<span class="number">25.940</span> NSBlockOperationTest[<span class="number">5939</span>:<span class="number">2525676</span>] NSBlockOperation 第<span class="number">3</span>次：&lt;NSThread: <span class="number">0x7fb6cbe04590</span>&gt;&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line"> <span class="number">2016</span>-<span class="number">05</span>-<span class="number">06</span> <span class="number">06</span>:<span class="number">01</span>:<span class="number">25.940</span> NSBlockOperationTest[<span class="number">5939</span>:<span class="number">2525676</span>] NSBlockOperation 第<span class="number">4</span>次：&lt;NSThread: <span class="number">0x7fb6cbe04590</span>&gt;&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line"> <span class="number">2016</span>-<span class="number">05</span>-<span class="number">06</span> <span class="number">06</span>:<span class="number">01</span>:<span class="number">25.940</span> NSBlockOperationTest[<span class="number">5939</span>:<span class="number">2525717</span>] NSBlockOperation 第<span class="number">0</span>次：&lt;NSThread: <span class="number">0x7fb6cbf03040</span>&gt;&#123;number = <span class="number">2</span>, name = (null)&#125;</span><br><span class="line"> <span class="number">2016</span>-<span class="number">05</span>-<span class="number">06</span> <span class="number">06</span>:<span class="number">01</span>:<span class="number">25.940</span> NSBlockOperationTest[<span class="number">5939</span>:<span class="number">2525710</span>] NSBlockOperation 第<span class="number">1</span>次：&lt;NSThread: <span class="number">0x7fb6cbc3f6e0</span>&gt;&#123;number = <span class="number">3</span>, name = (null)&#125;</span><br></pre></td></tr></table></figure>
<p>注意：addExecutionBlock 方法必须在 start() 方法之前执行，否则就会报错：</p>
<figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Terminating app due <span class="keyword">to</span> uncaught exception <span class="attribute">'NSInvalidArgumentException</span>', reason: '*** -[NSBlockOperation addExecutionBlock:]: blocks cannot be added <span class="keyword">after</span> the operation has started executing <span class="keyword">or</span> finished'</span><br></pre></td></tr></table></figure>
<h4 id="NSOperationQueue">NSOperationQueue</h4><p>在 NSOperationQueue 中，任务不会在当前线程执行。当任务添加到队列，会自动调用任务的 start() 方法，所有任务是并行执行的。maxConcurrentOperationCount 可以设置最大任务并行数量，当设置为 1 时，在某种意义上就是串行了。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">    <span class="built_in">NSOperationQueue</span> *queue = [[<span class="built_in">NSOperationQueue</span> alloc] init];</span><br><span class="line">    <span class="built_in">NSBlockOperation</span> *blockOperation = [<span class="built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"NSBlockOperation --- %@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    &#125;];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        [blockOperation addExecutionBlock:^&#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"NSBlockOperation 第%d次：%@"</span>, i, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;</span><br><span class="line">    [queue addOperation:blockOperation];</span><br><span class="line">或者是：</span><br><span class="line">       [queue addOperationWithBlock:^&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"addOperationWithBlock 第%d次：%@"</span>, i, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">        &#125;</span><br><span class="line">        [[<span class="built_in">NSOperationQueue</span> mainQueue] addOperationWithBlock:^&#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"addOperationWithBlock %@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;];</span><br></pre></td></tr></table></figure>
<p>eg:NSOperation 有一个非常实用的功能，那就是添加依赖。比如有 3 个任务：A: 从服务器上下载一张图片，B：给这张图片加个水印，C：把图片返回给服务器。这时就可以用到依赖了:</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSBlockOperation</span> *operation1 = [<span class="built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class="line">       <span class="built_in">NSLog</span>(<span class="string">@"下载图片 --- %@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">   &#125;];</span><br><span class="line">   <span class="built_in">NSBlockOperation</span> *operation2 = [<span class="built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class="line">       <span class="built_in">NSLog</span>(<span class="string">@"打水印 --- %@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">   &#125;];</span><br><span class="line">   <span class="built_in">NSBlockOperation</span> *operation3 = [<span class="built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class="line">       <span class="built_in">NSLog</span>(<span class="string">@"上传图片 --- %@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">   &#125;];</span><br><span class="line">   [operation2 addDependency:operation1];</span><br><span class="line">   [operation3 addDependency:operation2];</span><br><span class="line">   <span class="built_in">NSOperationQueue</span> *operationQueue = [[<span class="built_in">NSOperationQueue</span> alloc] init];</span><br><span class="line">   [operationQueue addOperations:@[operation1,operation2,operation3] waitUntilFinished:<span class="literal">NO</span>];</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2016</span>-<span class="number">05</span>-<span class="number">06</span> <span class="number">06</span>:<span class="number">26</span>:<span class="number">12.732</span> NSOperationQueueTest[<span class="number">6061</span>:<span class="number">2650250</span>] 下载图片 --- &lt;NSThread: <span class="number">0x7fc589e1d740</span>&gt;&#123;number = <span class="number">3</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">05</span>-<span class="number">06</span> <span class="number">06</span>:<span class="number">26</span>:<span class="number">12.733</span> NSOperationQueueTest[<span class="number">6061</span>:<span class="number">2650257</span>] 打水印 --- &lt;NSThread: <span class="number">0x7fc589f01320</span>&gt;&#123;number = <span class="number">4</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">05</span>-<span class="number">06</span> <span class="number">06</span>:<span class="number">26</span>:<span class="number">12.734</span> NSOperationQueueTest[<span class="number">6061</span>:<span class="number">2650257</span>] 上传图片 --- &lt;NSThread: <span class="number">0x7fc589f01320</span>&gt;&#123;number = <span class="number">4</span>, name = (null)&#125;</span><br></pre></td></tr></table></figure>
<p>注意：不能添加相互依赖，会死锁，比如 A依赖B，B依赖A。<br><br>     可以使用 removeDependency 来解除依赖关系。<br><br>     可以在不同的队列之间依赖，反正就是这个依赖是添加到任务身上的，和队列没关系。<br></p>
<p>另外还有以下方法：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSOperation</span></span><br><span class="line"><span class="built_in">BOOL</span> executing; <span class="comment">//判断任务是否正在执行</span></span><br><span class="line"><span class="built_in">BOOL</span> finished; <span class="comment">//判断任务是否完成</span></span><br><span class="line"><span class="keyword">void</span> (^completionBlock)(<span class="keyword">void</span>); <span class="comment">//用来设置完成后需要执行的操作</span></span><br><span class="line">- (<span class="keyword">void</span>)cancel; <span class="comment">//取消任务</span></span><br><span class="line">- (<span class="keyword">void</span>)waitUntilFinished; <span class="comment">//阻塞当前线程直到此任务执行完毕</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">NSOperationQueue</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">NSUInteger</span> operationCount; <span class="comment">//获取队列的任务数</span></span><br><span class="line">- (<span class="keyword">void</span>)cancelAllOperations; <span class="comment">//取消队列中所有的任务</span></span><br><span class="line">- (<span class="keyword">void</span>)waitUntilAllOperationsAreFinished; <span class="comment">//阻塞当前线程直到此队列中的所有任务执行完毕</span></span><br><span class="line">[queue setSuspended:<span class="literal">YES</span>]; <span class="comment">// 暂停queue</span></span><br><span class="line">[queue setSuspended:<span class="literal">NO</span>]; <span class="comment">// 继续queue</span></span><br></pre></td></tr></table></figure>
<p>关于NSOperationQueue中 ：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@property (nullable, assign <span class="comment">/* actually retain */</span>) <span class="keyword">dispatch_queue_t</span> <span class="function">underlyingQueue <span class="title">NS_AVAILABLE</span><span class="params">(<span class="number">10</span>_10, <span class="number">8</span>_0)</span></span>;</span><br></pre></td></tr></table></figure>
<p><a href="http://stackoverflow.com/questions/16563410/get-underlying-dispatch-queue-t-from-nsoperationqueue" target="_blank" rel="external">在这里有介绍其用法</a><br><br><a href="http://stackoverflow.com/questions/31062196/can-nsoperation-have-a-lower-qualityofservice-than-nsoperationqueue/31076475#31076475" target="_blank" rel="external">这里也有解释</a><br><br>这里是苹果的解释：</p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Discussion</span><br><span class="line">The default <span class="built_in">value</span> <span class="operator">of</span> this property is nil. You can <span class="built_in">set</span> <span class="operator">the</span> <span class="built_in">value</span> <span class="operator">of</span> this property <span class="built_in">to</span> <span class="operator">an</span> existing <span class="built_in">dispatch</span> queue <span class="built_in">to</span> have enqueued operations interspersed <span class="operator">with</span> blocks submitted <span class="built_in">to</span> that <span class="built_in">dispatch</span> queue.</span><br><span class="line"></span><br><span class="line">The <span class="built_in">value</span> <span class="operator">of</span> this property should only be <span class="built_in">set</span> <span class="keyword">if</span> there are no operations <span class="operator">in</span> <span class="operator">the</span> queue; setting <span class="operator">the</span> <span class="built_in">value</span> <span class="operator">of</span> this property when operationCount is <span class="operator">not</span> equal <span class="built_in">to</span> <span class="number">0</span> raises <span class="operator">an</span> invalidArgumentException. The <span class="built_in">value</span> <span class="operator">of</span> this property must <span class="operator">not</span> be <span class="operator">the</span> <span class="built_in">value</span> returned <span class="keyword">by</span> dispatch_get_main_queue(). The quality-<span class="operator">of</span>-service level <span class="built_in">set</span> <span class="keyword">for</span> <span class="operator">the</span> underlying <span class="built_in">dispatch</span> queue overrides <span class="keyword">any</span> <span class="built_in">value</span> <span class="built_in">set</span> <span class="keyword">for</span> <span class="operator">the</span> operation queue<span class="string">'s qualityOfService property.</span></span><br></pre></td></tr></table></figure>
<h4 id="自定义Operation">自定义Operation</h4><p>后面会有专门有一节介绍</p>
<hr>
<h3 id="GCD">GCD</h3><p>Grand Central Dispatch 是苹果为多核的并行运算提出的解决方案，所以会自动合理地利用更多的CPU内核（比如双核、四核），最重要的是它会自动管理线程的生命周期（创建线程、调度任务、销毁线程），完全不需要我们管理，我们只需要告诉干什么就行。</p>
<p>在 GCD 中，加入了两个非常重要的概念： 任务 和 队列。 任务即你要执行的，同步、异步和队列 前面已经讲解过。<br></p>
<pre><code>放到串行队列的任务，<span class="keyword">GCD</span> 会 FIFO（先进先出） 地取出来一个，执行一个，然后取下一个，这样一个一个的执行。&lt;br/&gt;

放到并行队列的任务，<span class="keyword">GCD</span> 也会 FIFO的取出来，但不同的是，它取出来一个就会放到别的线程，然后再取出来一个又放到另一个的线程。这样由于取的动作很快，忽略不计，看起来，所有的任务都是一起执行的。不过需要注意，<span class="keyword">GCD</span> 会根据系统资源控制并行的数量，所以如果任务很多，它并不会让所有任务同时执行。&lt;br/&gt;
</code></pre><h4 id="创建队列">创建队列</h4><p>先讲概念：</p>
<p>GCD中的FIFO队列称为dispatch queue，用来保证先进来的任务先得到执行。</p>
<p> dispatch queue分三种</p>
<ul>
<li>Serial：又叫private dispatch queues，同时只执行一个任务。Serial queue常用于同步访问特定的资源或数据。当你创建多个Serial queue时，虽然各自是同步，但serial queue之间是并发执行。(DISPATCH_QUEUE_SERIAL)</li>
<li>Concurrent：又叫global dispatch queue，可以并发的执行多个任务，但执行完成顺序是随机的。(DISPATCH_QUEUE_CONCURRENT)</li>
<li>Main dispatch queue：全局可用的serial queue，在应用程序主线程上执行任务。</li>
</ul>
<p>公开的5个不同队列：<br> 运行在主线程中的main queue，<br> 3个不同优先级的后台队列（High Priority Queue，Default Priority Queue，Low Priority Queue），<br> 以及一个优先级更低的后台队列Background Priority Queue（用于I/O）</p>
<p> 5种队列，主队列（main queue）,四种通用调度队列，自己定制的队列。四种通用调度队列为</p>
<ul>
<li>QOS_CLASS_USER_INTERACTIVE：user interactive等级表示任务需要被立即执行提供好的体验，用来更新UI，响应事件等。这个等级最好保持小规模。</li>
<li>QOS_CLASS_USER_INITIATED：  user initiated等级表示任务由UI发起异步执行。适用场景是需要及时结果同时又可以继续交互的时候。</li>
<li>QOS_CLASS_UTILITY：         utility等级表示需要长时间运行的任务，伴有用户可见进度指示器。经常会用来做计算，I/O，网络，持续的数据填充等任务。这个任务节能。</li>
<li>QOS_CLASS_BACKGROUND：      background等级表示用户不会察觉的任务，使用它来处理预加载，或者不需要用户交互和对时间不敏感的任务。</li>
</ul>
<h5 id="主队列">主队列</h5><p>这是一个特殊的 串行队列,它用于刷新 UI，任何需要刷新 UI 的工作都要在主队列执行.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dispatch_queue_t</span> <span class="built_in">queue</span> = dispatch_get_main_queue();</span><br></pre></td></tr></table></figure>
<h5 id="自定义的队列">自定义的队列</h5><p>其中第一个参数是标识符，用于 DEBUG 的时候标识唯一的队列，可以为空.</p>
<p>第二个参数用来表示创建的队列是串行的还是并行的，传入 DISPATCH_QUEUE_SERIAL 或 NULL 表示创建串行队列。传入 DISPATCH_QUEUE_CONCURRENT 表示创建并行队列。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dispatch_queue_t</span></span><br><span class="line">dispatch_queue_create(<span class="keyword">const</span> <span class="keyword">char</span> *_Nullable label,</span><br><span class="line">		<span class="keyword">dispatch_queue_attr_t</span> _Nullable attr);</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 串行队列</span></span><br><span class="line"><span class="keyword">dispatch_queue_t</span> createQueue = dispatch_queue_create(<span class="string">"com.testQueue"</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">dispatch_queue_t</span> createQueue = dispatch_queue_create(<span class="string">"com.testQueue"</span>, DISPATCH_QUEUE_SERIAL);</span><br><span class="line"><span class="comment">// 并行队列</span></span><br><span class="line"><span class="keyword">dispatch_queue_t</span> createQueue = dispatch_queue_create(<span class="string">"com.testQueue"</span>, DISPATCH_QUEUE_CONCURRENT);</span><br></pre></td></tr></table></figure>
<p>系统还提供了 全局并行队列</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dispatch_queue_t</span> createQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p>全局队列有这几种优先级：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hexcolor">#def</span>ine DISPATCH_QUEUE_PRIORITY_HIGH <span class="number">2</span></span><br><span class="line"><span class="hexcolor">#def</span>ine DISPATCH_QUEUE_PRIORITY_DEFAULT <span class="number">0</span></span><br><span class="line"><span class="hexcolor">#def</span>ine DISPATCH_QUEUE_PRIORITY_LOW (-<span class="number">2</span>)</span><br><span class="line"><span class="hexcolor">#def</span>ine DISPATCH_QUEUE_PRIORITY_BACKGROUND INT16_MIN</span><br></pre></td></tr></table></figure>
<h5 id="创建任务">创建任务</h5><p>同步任务：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_sync</span>(queue, ^&#123;</span><br><span class="line">    </span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">"com.testQueue"</span>, DISPATCH_QUEUE_SERIAL);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"async之前 - %@"</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line"><span class="built_in">dispatch_sync</span>(queue, ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"async1 - %@"</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">dispatch_sync</span>(queue, ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"async2 - %@"</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">dispatch_sync</span>(queue, ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"async3 - %@"</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"async之后 - %@"</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br></pre></td></tr></table></figure>
<p>log:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2016</span>-<span class="number">05</span>-<span class="number">05</span> <span class="number">07</span>:<span class="number">03</span>:<span class="number">01.137</span> syncTest[<span class="number">5181</span>:<span class="number">1954382</span>] async之前 - &lt;NSThread: <span class="number">0x7fd7e9400ec0</span>&gt;&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">05</span>-<span class="number">05</span> <span class="number">07</span>:<span class="number">03</span>:<span class="number">01.138</span> syncTest[<span class="number">5181</span>:<span class="number">1954382</span>] async1 - &lt;NSThread: <span class="number">0x7fd7e9400ec0</span>&gt;&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">05</span>-<span class="number">05</span> <span class="number">07</span>:<span class="number">03</span>:<span class="number">01.138</span> syncTest[<span class="number">5181</span>:<span class="number">1954382</span>] async2 - &lt;NSThread: <span class="number">0x7fd7e9400ec0</span>&gt;&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">05</span>-<span class="number">05</span> <span class="number">07</span>:<span class="number">03</span>:<span class="number">01.138</span> syncTest[<span class="number">5181</span>:<span class="number">1954382</span>] async3 - &lt;NSThread: <span class="number">0x7fd7e9400ec0</span>&gt;&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">05</span>-<span class="number">05</span> <span class="number">07</span>:<span class="number">03</span>:<span class="number">01.138</span> syncTest[<span class="number">5181</span>:<span class="number">1954382</span>] async之后 - &lt;NSThread: <span class="number">0x7fd7e9400ec0</span>&gt;&#123;number = <span class="number">1</span>, name = main&#125;</span><br></pre></td></tr></table></figure>
<p>注意：</p>
<p>1.同步队列无论设置是DISPATCH_QUEUE_SERIAL还是DISPATCH_QUEUE_CONCURRENT，任务都是在主线程执行,会阻塞主线程</p>
<p>2.dispatch_sync 中 queue 不能是 dispatch_get_main_queue() 即为主线程队列，否则会creash</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NSLog</span>(<span class="at_rule">@<span class="string">"dispatch_sync  enter"</span>);</span></span><br><span class="line"><span class="function">dispatch_sync</span>(<span class="function">dispatch_get_main_queue</span>(), ^&#123;</span><br><span class="line">    <span class="function">NSLog</span>(<span class="at_rule">@<span class="string">"dispatch_sync action"</span>);</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="function">NSLog</span>(<span class="at_rule">@<span class="string">"dispatch_sync leave"</span>);</span></span><br></pre></td></tr></table></figure>
<p>异步任务：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_async</span>(createQueue, ^&#123;</span><br><span class="line">    </span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//并行队列 DISPATCH_QUEUE_CONCURRENT</span></span><br><span class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">"com.testQueue"</span>, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"async之前 - %@"</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line"><span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"async1 - %@"</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"async2 - %@"</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"async3 - %@"</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"async之后 - %@"</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br></pre></td></tr></table></figure>
<p>log:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">21</span> <span class="number">07</span>:<span class="number">19</span>:<span class="number">53.817</span> asyncTest[<span class="number">13930</span>:<span class="number">8566716</span>] async之前 - &lt;NSThread: <span class="number">0x600000066a40</span>&gt;&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">21</span> <span class="number">07</span>:<span class="number">19</span>:<span class="number">53.818</span> asyncTest[<span class="number">13930</span>:<span class="number">8566716</span>] async之后 - &lt;NSThread: <span class="number">0x600000066a40</span>&gt;&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">21</span> <span class="number">07</span>:<span class="number">20</span>:<span class="number">59.683</span> asyncTest[<span class="number">13930</span>:<span class="number">8566864</span>] async2 - &lt;NSThread: <span class="number">0x60800007d700</span>&gt;&#123;number = <span class="number">4</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">21</span> <span class="number">07</span>:<span class="number">20</span>:<span class="number">59.683</span> asyncTest[<span class="number">13930</span>:<span class="number">8566862</span>] async3 - &lt;NSThread: <span class="number">0x60000007a9c0</span>&gt;&#123;number = <span class="number">3</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">21</span> <span class="number">07</span>:<span class="number">20</span>:<span class="number">59.683</span> asyncTest[<span class="number">13930</span>:<span class="number">8566867</span>] async1 - &lt;NSThread: <span class="number">0x60000007ad00</span>&gt;&#123;number = <span class="number">5</span>, name = (null)&#125;</span><br></pre></td></tr></table></figure>
<h4 id="队列组">队列组</h4><h5 id="创建队列-1">创建队列</h5><p>group 可以分为 串行和并行的，区别在于DISPATCH_QUEUE_SERIAL和DISPATCH_QUEUE_CONCURRENT设置不同</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dispatch_group_t</span> group = dispatch_group_create();</span><br><span class="line"><span class="keyword">dispatch_queue_t</span> <span class="built_in">queue</span> = dispatch_queue_create(<span class="string">"com.testQueue"</span>, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">dispatch_group_async(group, <span class="built_in">queue</span>, ^&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        NSLog(@<span class="string">"group-01 - %@"</span>, [NSThread currentThread]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);    </span><br><span class="line">dispatch_group_async(group, <span class="built_in">queue</span>, ^&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        NSLog(@<span class="string">"group-03 - %@"</span>, [NSThread currentThread]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>log: 串行,但是异步的，不会阻塞当前线程</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">21</span> <span class="number">08</span>:<span class="number">05</span>:<span class="number">14.110</span> GCDTest[<span class="number">14034</span>:<span class="number">8745909</span>] group-<span class="number">01</span> - &lt;NSThread: <span class="number">0x60000027d100</span>&gt;&#123;number = <span class="number">4</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">21</span> <span class="number">08</span>:<span class="number">05</span>:<span class="number">14.111</span> GCDTest[<span class="number">14034</span>:<span class="number">8745909</span>] group-<span class="number">01</span> - &lt;NSThread: <span class="number">0x60000027d100</span>&gt;&#123;number = <span class="number">4</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">21</span> <span class="number">08</span>:<span class="number">05</span>:<span class="number">14.112</span> GCDTest[<span class="number">14034</span>:<span class="number">8745909</span>] group-<span class="number">01</span> - &lt;NSThread: <span class="number">0x60000027d100</span>&gt;&#123;number = <span class="number">4</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">21</span> <span class="number">08</span>:<span class="number">05</span>:<span class="number">14.112</span> GCDTest[<span class="number">14034</span>:<span class="number">8745909</span>] group-<span class="number">01</span> - &lt;NSThread: <span class="number">0x60000027d100</span>&gt;&#123;number = <span class="number">4</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">21</span> <span class="number">08</span>:<span class="number">05</span>:<span class="number">14.112</span> GCDTest[<span class="number">14034</span>:<span class="number">8745909</span>] group-<span class="number">01</span> - &lt;NSThread: <span class="number">0x60000027d100</span>&gt;&#123;number = <span class="number">4</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">21</span> <span class="number">08</span>:<span class="number">05</span>:<span class="number">19.589</span> GCDTest[<span class="number">14034</span>:<span class="number">8745909</span>] group-<span class="number">03</span> - &lt;NSThread: <span class="number">0x60000027d100</span>&gt;&#123;number = <span class="number">4</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">21</span> <span class="number">08</span>:<span class="number">05</span>:<span class="number">19.590</span> GCDTest[<span class="number">14034</span>:<span class="number">8745909</span>] group-<span class="number">03</span> - &lt;NSThread: <span class="number">0x60000027d100</span>&gt;&#123;number = <span class="number">4</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">21</span> <span class="number">08</span>:<span class="number">05</span>:<span class="number">19.590</span> GCDTest[<span class="number">14034</span>:<span class="number">8745909</span>] group-<span class="number">03</span> - &lt;NSThread: <span class="number">0x60000027d100</span>&gt;&#123;number = <span class="number">4</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">21</span> <span class="number">08</span>:<span class="number">05</span>:<span class="number">19.591</span> GCDTest[<span class="number">14034</span>:<span class="number">8745909</span>] group-<span class="number">03</span> - &lt;NSThread: <span class="number">0x60000027d100</span>&gt;&#123;number = <span class="number">4</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">21</span> <span class="number">08</span>:<span class="number">05</span>:<span class="number">19.591</span> GCDTest[<span class="number">14034</span>:<span class="number">8745909</span>] group-<span class="number">03</span> - &lt;NSThread: <span class="number">0x60000027d100</span>&gt;&#123;number = <span class="number">4</span>, name = (null)&#125;</span><br></pre></td></tr></table></figure>
<p>并行:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">21</span> <span class="number">08</span>:<span class="number">09</span>:<span class="number">46.984</span> GCDTest[<span class="number">14058</span>:<span class="number">8768392</span>] group-<span class="number">03</span> - &lt;NSThread: <span class="number">0x608000273900</span>&gt;&#123;number = <span class="number">4</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">21</span> <span class="number">08</span>:<span class="number">09</span>:<span class="number">46.984</span> GCDTest[<span class="number">14058</span>:<span class="number">8768371</span>] group-<span class="number">01</span> - &lt;NSThread: <span class="number">0x608000273200</span>&gt;&#123;number = <span class="number">3</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">21</span> <span class="number">08</span>:<span class="number">09</span>:<span class="number">46.984</span> GCDTest[<span class="number">14058</span>:<span class="number">8768392</span>] group-<span class="number">03</span> - &lt;NSThread: <span class="number">0x608000273900</span>&gt;&#123;number = <span class="number">4</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">21</span> <span class="number">08</span>:<span class="number">09</span>:<span class="number">46.984</span> GCDTest[<span class="number">14058</span>:<span class="number">8768371</span>] group-<span class="number">01</span> - &lt;NSThread: <span class="number">0x608000273200</span>&gt;&#123;number = <span class="number">3</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">21</span> <span class="number">08</span>:<span class="number">09</span>:<span class="number">46.985</span> GCDTest[<span class="number">14058</span>:<span class="number">8768392</span>] group-<span class="number">03</span> - &lt;NSThread: <span class="number">0x608000273900</span>&gt;&#123;number = <span class="number">4</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">21</span> <span class="number">08</span>:<span class="number">09</span>:<span class="number">46.985</span> GCDTest[<span class="number">14058</span>:<span class="number">8768371</span>] group-<span class="number">01</span> - &lt;NSThread: <span class="number">0x608000273200</span>&gt;&#123;number = <span class="number">3</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">21</span> <span class="number">08</span>:<span class="number">09</span>:<span class="number">46.985</span> GCDTest[<span class="number">14058</span>:<span class="number">8768392</span>] group-<span class="number">03</span> - &lt;NSThread: <span class="number">0x608000273900</span>&gt;&#123;number = <span class="number">4</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">21</span> <span class="number">08</span>:<span class="number">09</span>:<span class="number">46.985</span> GCDTest[<span class="number">14058</span>:<span class="number">8768371</span>] group-<span class="number">01</span> - &lt;NSThread: <span class="number">0x608000273200</span>&gt;&#123;number = <span class="number">3</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">21</span> <span class="number">08</span>:<span class="number">09</span>:<span class="number">46.985</span> GCDTest[<span class="number">14058</span>:<span class="number">8768392</span>] group-<span class="number">03</span> - &lt;NSThread: <span class="number">0x608000273900</span>&gt;&#123;number = <span class="number">4</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">21</span> <span class="number">08</span>:<span class="number">09</span>:<span class="number">46.986</span> GCDTest[<span class="number">14058</span>:<span class="number">8768371</span>] group-<span class="number">01</span> - &lt;NSThread: <span class="number">0x608000273200</span>&gt;&#123;number = <span class="number">3</span>, name = (null)&#125;</span><br></pre></td></tr></table></figure>
<h5 id="监听任务组事件的执行完毕">监听任务组事件的执行完毕</h5><p>1.dispatch_group_notify </p>
<p>用来监听任务组事件的执行完毕, 异步执行闭包，不会阻塞</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span></span><br><span class="line"><span class="title">dispatch_group_notify</span><span class="params">(dispatch_group_t group,</span><br><span class="line">	dispatch_queue_t <span class="built_in">queue</span>,</span><br><span class="line">	dispatch_block_t block)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">dispatch_group_t group = dispatch_group_create<span class="list">()</span><span class="comment">;</span></span><br><span class="line">dispatch_queue_t queue = dispatch_queue_create<span class="list">(<span class="string">"com.testQueue"</span>, DISPATCH_QUEUE_CONCURRENT)</span><span class="comment">;</span></span><br><span class="line">dispatch_group_async<span class="list">(<span class="keyword">group</span>, queue, ^&#123;</span><br><span class="line">    [[NSThread currentThread] setName:@<span class="string">"group-01-thread"</span>]<span class="comment">;</span></span><br><span class="line">    for <span class="list">(<span class="keyword">int</span> i = <span class="number">0</span><span class="comment">; i &lt; 3; i++) &#123;</span></span><br><span class="line">        NSLog<span class="list">(@<span class="string">"group-01 - %@"</span>, [NSThread currentThread])</span><span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><span class="comment">;</span></span><br><span class="line">dispatch_group_async<span class="list">(<span class="keyword">group</span>, queue, ^&#123;</span><br><span class="line">    [[NSThread currentThread] setName:@<span class="string">"group-03-thread"</span>]<span class="comment">;</span></span><br><span class="line">    for <span class="list">(<span class="keyword">int</span> i = <span class="number">0</span><span class="comment">; i &lt; 3; i++) &#123;</span></span><br><span class="line">        NSLog<span class="list">(@<span class="string">"group-03 - %@"</span>, [NSThread currentThread])</span><span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><span class="comment">;</span></span><br><span class="line">NSLog<span class="list">(@<span class="string">"notify leave"</span>)</span><span class="comment">;</span></span><br><span class="line">dispatch_group_notify<span class="list">(<span class="keyword">group</span>, dispatch_get_main_queue<span class="list">()</span>, ^&#123;</span><br><span class="line">    NSLog<span class="list">(@<span class="string">"notify 完成 - %@"</span>, [NSThread currentThread])</span><span class="comment">;</span></span><br><span class="line">&#125;)</span><span class="comment">;</span></span><br><span class="line">NSLog<span class="list">(@<span class="string">"notify leave"</span>)</span><span class="comment">;</span></span></span></span><br></pre></td></tr></table></figure>
<p>log:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">22</span> <span class="number">07</span>:<span class="number">03</span>:<span class="number">18.150</span> GCDTest[<span class="number">19000</span>:<span class="number">9806166</span>] notify leave</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">22</span> <span class="number">07</span>:<span class="number">03</span>:<span class="number">18.150</span> GCDTest[<span class="number">19000</span>:<span class="number">9813919</span>] group-<span class="number">01</span> - &lt;NSThread: <span class="number">0x60000026b700</span>&gt;&#123;number = <span class="number">5</span>, name = group-<span class="number">01</span>-thread&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">22</span> <span class="number">07</span>:<span class="number">03</span>:<span class="number">18.150</span> GCDTest[<span class="number">19000</span>:<span class="number">9814304</span>] group-<span class="number">03</span> - &lt;NSThread: <span class="number">0x608000277800</span>&gt;&#123;number = <span class="number">6</span>, name = group-<span class="number">03</span>-thread&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">22</span> <span class="number">07</span>:<span class="number">03</span>:<span class="number">18.151</span> GCDTest[<span class="number">19000</span>:<span class="number">9806166</span>] notify leave</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">22</span> <span class="number">07</span>:<span class="number">03</span>:<span class="number">18.151</span> GCDTest[<span class="number">19000</span>:<span class="number">9813919</span>] group-<span class="number">01</span> - &lt;NSThread: <span class="number">0x60000026b700</span>&gt;&#123;number = <span class="number">5</span>, name = group-<span class="number">01</span>-thread&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">22</span> <span class="number">07</span>:<span class="number">03</span>:<span class="number">18.151</span> GCDTest[<span class="number">19000</span>:<span class="number">9814304</span>] group-<span class="number">03</span> - &lt;NSThread: <span class="number">0x608000277800</span>&gt;&#123;number = <span class="number">6</span>, name = group-<span class="number">03</span>-thread&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">22</span> <span class="number">07</span>:<span class="number">03</span>:<span class="number">18.152</span> GCDTest[<span class="number">19000</span>:<span class="number">9813919</span>] group-<span class="number">01</span> - &lt;NSThread: <span class="number">0x60000026b700</span>&gt;&#123;number = <span class="number">5</span>, name = group-<span class="number">01</span>-thread&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">22</span> <span class="number">07</span>:<span class="number">03</span>:<span class="number">18.152</span> GCDTest[<span class="number">19000</span>:<span class="number">9814304</span>] group-<span class="number">03</span> - &lt;NSThread: <span class="number">0x608000277800</span>&gt;&#123;number = <span class="number">6</span>, name = group-<span class="number">03</span>-thread&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">22</span> <span class="number">07</span>:<span class="number">03</span>:<span class="number">18.157</span> GCDTest[<span class="number">19000</span>:<span class="number">9806166</span>] notify 完成 - &lt;NSThread: <span class="number">0x60800007b6c0</span>&gt;&#123;number = <span class="number">1</span>, name = main&#125;</span><br></pre></td></tr></table></figure>
<p>2.dispatch_group_wait   </p>
<p>会阻塞当前进程，等所有任务都完成或等待超时。设置等待时间，在等待时间结束后，如果还没有执行完任务组，则返回。返回0代表执行成功，非0则执行失败</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">dispatch_group_wait</span>(<span class="params">dispatch_group_t <span class="keyword">group</span>, dispatch_time_t timeout</span>)</span>;</span><br></pre></td></tr></table></figure>
<p>超时时间 可以根据需要设置，系统提供了两个宏：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hexcolor">#def</span>ine DISPATCH_TIME_NOW (<span class="number">0</span>ull)</span><br><span class="line"><span class="hexcolor">#def</span>ine DISPATCH_TIME_FOREVER (~<span class="number">0</span>ull)</span><br></pre></td></tr></table></figure>
<p>在此之前介绍一下时间：</p>
<p>iOS系统 GCD 中提供了一下几种时间</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hexcolor">#def</span>ine NSEC_PER_SEC  <span class="number">1000000000</span>ull</span><br><span class="line"><span class="hexcolor">#def</span>ine NSEC_PER_MSEC <span class="number">1000000</span>ull</span><br><span class="line"><span class="hexcolor">#def</span>ine USEC_PER_SEC  <span class="number">1000000</span>ull</span><br><span class="line"><span class="hexcolor">#def</span>ine NSEC_PER_USEC <span class="number">1000</span>ull</span><br></pre></td></tr></table></figure>
<p>关键词解释：    </p>
<ul>
<li>NSEC：纳秒</li>
<li>USEC：微秒</li>
<li>MSEC：毫秒</li>
<li>SEC：秒</li>
<li>PER：每</li>
</ul>
<p>故：</p>
<table>
<thead>
<tr>
<th>宏</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>NSEC_PER_SEC</td>
<td style="text-align:center">每秒有多少纳秒</td>
</tr>
<tr>
<td>NSEC_PER_MSEC</td>
<td style="text-align:center">每毫秒有多少纳秒</td>
</tr>
<tr>
<td>USEC_PER_SEC</td>
<td style="text-align:center">每秒有多少微秒</td>
</tr>
<tr>
<td>NSEC_PER_USEC</td>
<td style="text-align:center">每微秒有多少纳秒</td>
</tr>
</tbody>
</table>
<p>所以，延时1秒可以写成如下几种：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dispatch_time<span class="list">(<span class="keyword">DISPATCH_TIME_NOW</span>, <span class="number">1</span> <span class="variable">* NSEC_PER_SEC);</span><br><span class="line">dispatch_time(DISPATCH_TIME_NOW, 1000 *</span> USEC_PER_SEC)</span><span class="comment">;</span></span><br><span class="line">dispatch_time<span class="list">(<span class="keyword">DISPATCH_TIME_NOW</span>, USEC_PER_SEC <span class="variable">* NSEC_PER_USEC);</span><br><span class="line">dispatch_time(DISPATCH_TIME_NOW, NSEC_PER_MSEC *</span> NSEC_PER_USEC)</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>绝对时间，dispatch_group_wait 想等到2016年09月22日23:20:53 的时候超时，那么要使用 dispatch_walltime函数将NSdate 转化为dispatch_time，下面是方法：</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- (dispatch_time_t)switchDateToDispatch_time_tWithDate:(NSDate *)<span class="type">date</span></span><br><span class="line">&#123;</span><br><span class="line">    NSTimeInterval interval;</span><br><span class="line">    double <span class="keyword">second</span>,subsecond;</span><br><span class="line">    struct timespec <span class="property">time</span>;</span><br><span class="line">    dispatch_time_t milestone;</span><br><span class="line">    interval=[<span class="type">date</span> timeIntervalSince1970];</span><br><span class="line">    </span><br><span class="line">    subsecond = modf(interval, &amp;<span class="keyword">second</span>);</span><br><span class="line">    <span class="property">time</span>.tv_sec = <span class="keyword">second</span>;</span><br><span class="line">    <span class="property">time</span>.tv_nsec= subsecond*NSEC_PER_SEC;</span><br><span class="line">    </span><br><span class="line">    milestone = dispatch_walltime(&amp;<span class="property">time</span>, <span class="number">0</span>);</span><br><span class="line"><span class="command">    return</span> milestone;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>好了时间说完了，该说示例了：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dispatch_group_t</span> group = dispatch_group_create();</span><br><span class="line"><span class="keyword">dispatch_queue_t</span> <span class="built_in">queue</span> = dispatch_queue_create(<span class="string">"com.testQueue"</span>, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">dispatch_group_async(group, <span class="built_in">queue</span>, ^&#123;</span><br><span class="line">    [[NSThread currentThread] setName:@<span class="string">"group-01-thread"</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        NSLog(@<span class="string">"group-01 - %@"</span>, [NSThread currentThread]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_group_async(group, <span class="built_in">queue</span>, ^&#123;</span><br><span class="line">    [[NSThread currentThread] setName:@<span class="string">"group-03-thread"</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        NSLog(@<span class="string">"group-03 - %@"</span>, [NSThread currentThread]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">NSLog(@<span class="string">"dispatch_group_wait 之前"</span>);</span><br><span class="line"><span class="keyword">long</span> value = dispatch_group_wait(group, DISPATCH_TIME_FOREVER);</span><br><span class="line">NSLog(@<span class="string">"dispatch_group_wait 之后 value = %ld"</span>,value);</span><br></pre></td></tr></table></figure>
<p>log:</p>
<p>① DISPATCH_TIME_FOREVER 可以看到会阻塞当前线程直到任务全部完成</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">22</span> <span class="number">07</span>:<span class="number">15</span>:<span class="number">14.211</span> GCDTest[<span class="number">19022</span>:<span class="number">9870397</span>] dispatch_group_wait 之前</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">22</span> <span class="number">07</span>:<span class="number">15</span>:<span class="number">14.211</span> GCDTest[<span class="number">19022</span>:<span class="number">9874488</span>] group-<span class="number">01</span> - &lt;NSThread: <span class="number">0x608000268f40</span>&gt;&#123;number = <span class="number">5</span>, name = group-<span class="number">01</span>-thread&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">22</span> <span class="number">07</span>:<span class="number">15</span>:<span class="number">14.211</span> GCDTest[<span class="number">19022</span>:<span class="number">9874995</span>] group-<span class="number">03</span> - &lt;NSThread: <span class="number">0x608000268500</span>&gt;&#123;number = <span class="number">6</span>, name = group-<span class="number">03</span>-thread&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">22</span> <span class="number">07</span>:<span class="number">15</span>:<span class="number">14.211</span> GCDTest[<span class="number">19022</span>:<span class="number">9874488</span>] group-<span class="number">01</span> - &lt;NSThread: <span class="number">0x608000268f40</span>&gt;&#123;number = <span class="number">5</span>, name = group-<span class="number">01</span>-thread&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">22</span> <span class="number">07</span>:<span class="number">15</span>:<span class="number">14.211</span> GCDTest[<span class="number">19022</span>:<span class="number">9874995</span>] group-<span class="number">03</span> - &lt;NSThread: <span class="number">0x608000268500</span>&gt;&#123;number = <span class="number">6</span>, name = group-<span class="number">03</span>-thread&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">22</span> <span class="number">07</span>:<span class="number">15</span>:<span class="number">14.211</span> GCDTest[<span class="number">19022</span>:<span class="number">9874488</span>] group-<span class="number">01</span> - &lt;NSThread: <span class="number">0x608000268f40</span>&gt;&#123;number = <span class="number">5</span>, name = group-<span class="number">01</span>-thread&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">22</span> <span class="number">07</span>:<span class="number">15</span>:<span class="number">14.212</span> GCDTest[<span class="number">19022</span>:<span class="number">9874995</span>] group-<span class="number">03</span> - &lt;NSThread: <span class="number">0x608000268500</span>&gt;&#123;number = <span class="number">6</span>, name = group-<span class="number">03</span>-thread&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">22</span> <span class="number">07</span>:<span class="number">15</span>:<span class="number">14.212</span> GCDTest[<span class="number">19022</span>:<span class="number">9870397</span>] dispatch_group_wait 之后 value = <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>② DISPATCH_TIME_NOW dispatch_group_wait 并未阻塞当前线程 但是 返回非零值，表明任务执行失败或者超时，这明显是超时</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">22</span> <span class="number">07</span>:<span class="number">18</span>:<span class="number">21.506</span> GCDTest[<span class="number">19041</span>:<span class="number">9887622</span>] dispatch_group_wait 之前</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">22</span> <span class="number">07</span>:<span class="number">18</span>:<span class="number">21.506</span> GCDTest[<span class="number">19041</span>:<span class="number">9891849</span>] group-<span class="number">01</span> - &lt;NSThread: <span class="number">0x608000274700</span>&gt;&#123;number = <span class="number">3</span>, name = group-<span class="number">01</span>-thread&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">22</span> <span class="number">07</span>:<span class="number">18</span>:<span class="number">21.506</span> GCDTest[<span class="number">19041</span>:<span class="number">9891894</span>] group-<span class="number">03</span> - &lt;NSThread: <span class="number">0x608000274680</span>&gt;&#123;number = <span class="number">4</span>, name = group-<span class="number">03</span>-thread&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">22</span> <span class="number">07</span>:<span class="number">18</span>:<span class="number">21.506</span> GCDTest[<span class="number">19041</span>:<span class="number">9887622</span>] dispatch_group_wait 之后 value = <span class="number">49</span></span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">22</span> <span class="number">07</span>:<span class="number">18</span>:<span class="number">21.506</span> GCDTest[<span class="number">19041</span>:<span class="number">9891849</span>] group-<span class="number">01</span> - &lt;NSThread: <span class="number">0x608000274700</span>&gt;&#123;number = <span class="number">3</span>, name = group-<span class="number">01</span>-thread&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">22</span> <span class="number">07</span>:<span class="number">18</span>:<span class="number">21.507</span> GCDTest[<span class="number">19041</span>:<span class="number">9891894</span>] group-<span class="number">03</span> - &lt;NSThread: <span class="number">0x608000274680</span>&gt;&#123;number = <span class="number">4</span>, name = group-<span class="number">03</span>-thread&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">22</span> <span class="number">07</span>:<span class="number">18</span>:<span class="number">21.507</span> GCDTest[<span class="number">19041</span>:<span class="number">9891849</span>] group-<span class="number">01</span> - &lt;NSThread: <span class="number">0x608000274700</span>&gt;&#123;number = <span class="number">3</span>, name = group-<span class="number">01</span>-thread&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">22</span> <span class="number">07</span>:<span class="number">18</span>:<span class="number">21.508</span> GCDTest[<span class="number">19041</span>:<span class="number">9891894</span>] group-<span class="number">03</span> - &lt;NSThread: <span class="number">0x608000274680</span>&gt;&#123;number = <span class="number">4</span>, name = group-<span class="number">03</span>-thread&#125;</span><br></pre></td></tr></table></figure>
<p>③ 自定义时间 会阻塞当前的线程</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这里让线程 睡眠2s</span></span><br><span class="line">    dispatch_group_async(group, <span class="built_in">queue</span>, ^&#123;</span><br><span class="line">        [[NSThread currentThread] setName:@<span class="string">"group-03-thread"</span>];</span><br><span class="line">        [NSThread sleepForTimeInterval:<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            NSLog(@<span class="string">"group-03 - %@"</span>, [NSThread currentThread]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"><span class="keyword">long</span> value = dispatch_group_wait(group, dispatch_time(DISPATCH_TIME_NOW, (<span class="keyword">int64_t</span>)(<span class="number">5</span>*NSEC_PER_SEC)));</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">22</span> <span class="number">07</span>:<span class="number">37</span>:<span class="number">32.478</span> GCDTest[<span class="number">19217</span>:<span class="number">10005760</span>] dispatch_group_wait 之前</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">22</span> <span class="number">07</span>:<span class="number">37</span>:<span class="number">32.478</span> GCDTest[<span class="number">19217</span>:<span class="number">10006060</span>] group-<span class="number">01</span> - &lt;NSThread: <span class="number">0x608000274140</span>&gt;&#123;number = <span class="number">3</span>, name = group-<span class="number">01</span>-thread&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">22</span> <span class="number">07</span>:<span class="number">37</span>:<span class="number">32.479</span> GCDTest[<span class="number">19217</span>:<span class="number">10006060</span>] group-<span class="number">01</span> - &lt;NSThread: <span class="number">0x608000274140</span>&gt;&#123;number = <span class="number">3</span>, name = group-<span class="number">01</span>-thread&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">22</span> <span class="number">07</span>:<span class="number">37</span>:<span class="number">32.479</span> GCDTest[<span class="number">19217</span>:<span class="number">10006060</span>] group-<span class="number">01</span> - &lt;NSThread: <span class="number">0x608000274140</span>&gt;&#123;number = <span class="number">3</span>, name = group-<span class="number">01</span>-thread&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">22</span> <span class="number">07</span>:<span class="number">37</span>:<span class="number">34.482</span> GCDTest[<span class="number">19217</span>:<span class="number">10006057</span>] group-<span class="number">03</span> - &lt;NSThread: <span class="number">0x608000273f80</span>&gt;&#123;number = <span class="number">4</span>, name = group-<span class="number">03</span>-thread&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">22</span> <span class="number">07</span>:<span class="number">37</span>:<span class="number">34.483</span> GCDTest[<span class="number">19217</span>:<span class="number">10006057</span>] group-<span class="number">03</span> - &lt;NSThread: <span class="number">0x608000273f80</span>&gt;&#123;number = <span class="number">4</span>, name = group-<span class="number">03</span>-thread&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">22</span> <span class="number">07</span>:<span class="number">37</span>:<span class="number">34.483</span> GCDTest[<span class="number">19217</span>:<span class="number">10006057</span>] group-<span class="number">03</span> - &lt;NSThread: <span class="number">0x608000273f80</span>&gt;&#123;number = <span class="number">4</span>, name = group-<span class="number">03</span>-thread&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">22</span> <span class="number">07</span>:<span class="number">37</span>:<span class="number">34.484</span> GCDTest[<span class="number">19217</span>:<span class="number">10005760</span>] dispatch_group_wait 之后 value = <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>3.dispatch_group_enter  dispatch_group_leave<br>这里 dispatch_group_enter 和 dispatch_group_leave 需要成对出现,否则dispatch_group_notify不会回调用（这里可能会崩溃，不过在我测试中没有发现）</p>
<p>①这是 dispatch_queue_t 的例子：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">dispatch_group_t group = dispatch_group_create<span class="list">()</span><span class="comment">;</span></span><br><span class="line">dispatch_queue_t queue = dispatch_queue_create<span class="list">(<span class="string">"com.testQueue"</span>, DISPATCH_QUEUE_CONCURRENT)</span><span class="comment">;</span></span><br><span class="line">dispatch_group_enter<span class="list">(<span class="keyword">group</span>)</span><span class="comment">;</span></span><br><span class="line">dispatch_group_async<span class="list">(<span class="keyword">group</span>, queue, ^&#123;</span><br><span class="line">    [[NSThread currentThread] setName:@<span class="string">"group-01-thread"</span>]<span class="comment">;</span></span><br><span class="line">    for <span class="list">(<span class="keyword">int</span> i = <span class="number">0</span><span class="comment">; i &lt; 3; i++) &#123;</span></span><br><span class="line">        NSLog<span class="list">(@<span class="string">"group-01 - %@"</span>, [NSThread currentThread])</span><span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line">    dispatch_group_leave<span class="list">(<span class="keyword">group</span>)</span><span class="comment">;</span></span><br><span class="line">&#125;)</span><span class="comment">;</span></span><br><span class="line">dispatch_group_enter<span class="list">(<span class="keyword">group</span>)</span><span class="comment">;</span></span><br><span class="line">dispatch_group_async<span class="list">(<span class="keyword">group</span>, queue, ^&#123;</span><br><span class="line">    [[NSThread currentThread] setName:@<span class="string">"group-03-thread"</span>]<span class="comment">;</span></span><br><span class="line">    [NSThread sleepForTimeInterval:<span class="number">2</span>]<span class="comment">;</span></span><br><span class="line">    for <span class="list">(<span class="keyword">int</span> i = <span class="number">0</span><span class="comment">; i &lt; 3; i++) &#123;</span></span><br><span class="line">        NSLog<span class="list">(@<span class="string">"group-03 - %@"</span>, [NSThread currentThread])</span><span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line">    dispatch_group_leave<span class="list">(<span class="keyword">group</span>)</span><span class="comment">;</span></span><br><span class="line">&#125;)</span><span class="comment">;</span></span><br><span class="line">dispatch_group_notify<span class="list">(<span class="keyword">group</span>, dispatch_get_main_queue<span class="list">()</span>, ^&#123;</span><br><span class="line">    NSLog<span class="list">(@<span class="string">"notify 完成 - %@"</span>, [NSThread currentThread])</span><span class="comment">;</span></span><br><span class="line">&#125;)</span><span class="comment">;</span></span></span></span><br></pre></td></tr></table></figure>
<p>②这是NSOperationQueue的例子：</p>
<figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">dispatch_group_t <span class="keyword">group</span> = dispatch_group_create();</span><br><span class="line">NSOperationQueue *queue = [[NSOperationQueue alloc] init];</span><br><span class="line">dispatch_group_enter(<span class="keyword">group</span>);</span><br><span class="line">NSBlockOperation *<span class="built_in">block</span>Operation_1 = [NSBlockOperation <span class="built_in">block</span>OperationWithBlock:^&#123;</span><br><span class="line">    NSLog(@<span class="string">"NSBlockOperation 1 --- %@"</span>, [NSThread currentThread]);</span><br><span class="line">    [NSThread sleepForTimeInterval:<span class="number">2</span>];</span><br><span class="line">    dispatch_group_leave(<span class="keyword">group</span>);</span><br><span class="line">&#125;];</span><br><span class="line">dispatch_group_enter(<span class="keyword">group</span>);</span><br><span class="line">NSBlockOperation *<span class="built_in">block</span>Operation_2 = [NSBlockOperation <span class="built_in">block</span>OperationWithBlock:^&#123;</span><br><span class="line">    NSLog(@<span class="string">"NSBlockOperation 2 --- %@"</span>, [NSThread currentThread]);</span><br><span class="line">    dispatch_group_leave(<span class="keyword">group</span>);</span><br><span class="line">&#125;];</span><br><span class="line">[<span class="built_in">block</span>Operation_1 <span class="built_in">set</span>Name:@<span class="string">"blockOperation_1"</span>];</span><br><span class="line">[<span class="built_in">block</span>Operation_1 <span class="built_in">set</span>Name:@<span class="string">"blockOperation_2"</span>];</span><br><span class="line">[queue addOperation:<span class="built_in">block</span>Operation_1];</span><br><span class="line">[queue addOperation:<span class="built_in">block</span>Operation_2];</span><br><span class="line">dispatch_group_notify(<span class="keyword">group</span>, dispatch_get_main_queue(), ^&#123;</span><br><span class="line">    NSLog(@<span class="string">"notify 完成 - %@"</span>, [NSThread currentThread]);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h5 id="dispatch_once">dispatch_once</h5><p>dispatch_once 大家都不会陌生，但我认为还是有必要强调一次，dispatch_once_t 必须为静态变量</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line"><span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">    <span class="comment">// to do something</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h5 id="dispatch_after">dispatch_after</h5><p>dispatch_after 能让我们添加进队列的任务延时（这里说延时不严谨，后面会说到）执行</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">NSLog(@<span class="string">"begin"</span>);</span><br><span class="line"><span class="keyword">double</span> delayInSeconds = <span class="number">1.0</span>;</span><br><span class="line"><span class="keyword">dispatch_time_t</span> popTime = dispatch_time(DISPATCH_TIME_NOW, (<span class="keyword">int64_t</span>)(delayInSeconds * NSEC_PER_SEC));</span><br><span class="line">dispatch_after(popTime, dispatch_get_main_queue(), ^&#123;</span><br><span class="line">    NSLog(@<span class="string">"end"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>虽然可以提供NStimer 的功能，但它不是，看下面官方文档：</p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Enqueue <span class="operator">a</span> block <span class="keyword">for</span> execution <span class="keyword">at</span> <span class="operator">the</span> specified <span class="built_in">time</span>.</span><br></pre></td></tr></table></figure>
<p>Enqueue，就是入队，指的就是将一个Block在特定的延时以后，加入到指定的队列中，不是在特定的时间后立即运行！。这里有个例子:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dispatch_queue_t</span> <span class="built_in">queue</span> = dispatch_queue_create(<span class="string">"com.testQueue"</span>, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">NSLog(@<span class="string">"begin"</span>);</span><br><span class="line">dispatch_async(<span class="built_in">queue</span>, ^&#123;</span><br><span class="line">    [[NSThread currentThread] setName:@<span class="string">"group-01-thread"</span>];</span><br><span class="line">    [NSThread sleepForTimeInterval:<span class="number">10</span>];</span><br><span class="line">    NSLog(@<span class="string">"dispatch_group_async"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//1.使用 dispatch_after 延后工作</span></span><br><span class="line"><span class="keyword">double</span> delayInSeconds = <span class="number">5.0</span>;</span><br><span class="line"><span class="keyword">dispatch_time_t</span> popTime = dispatch_time(DISPATCH_TIME_NOW, (<span class="keyword">int64_t</span>)(delayInSeconds * NSEC_PER_SEC));</span><br><span class="line">dispatch_after(popTime, <span class="built_in">queue</span>, ^&#123;</span><br><span class="line">    NSLog(@<span class="string">"dispatch_time"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>log:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">23</span> <span class="number">22</span>:<span class="number">56</span>:<span class="number">05.258</span> GCDTest[<span class="number">20684</span>:<span class="number">11209748</span>] begin</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">23</span> <span class="number">22</span>:<span class="number">56</span>:<span class="number">15.263</span> GCDTest[<span class="number">20684</span>:<span class="number">11209796</span>] dispatch_group_async</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">23</span> <span class="number">22</span>:<span class="number">56</span>:<span class="number">15.263</span> GCDTest[<span class="number">20684</span>:<span class="number">11209796</span>] dispatch_time</span><br></pre></td></tr></table></figure>
<p>从结果也验证了，dispatch_after只是延时提交block，并不是延时后立即执行。所以想用dispatch_after精确控制运行状态的朋友可要注意了~</p>
<h5 id="dispatch_apply">dispatch_apply</h5><p>dispatch_apply的作用是在一个队列（串行或并行）上“运行”多次block，不过会阻塞当前线程，按执行最长任务时间阻塞(异步，同步是所有任务时间总和)，用时间要小心：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dispatch_queue_t</span> <span class="built_in">queue</span> = dispatch_queue_create(<span class="string">"com.testQueue"</span>, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">NSLog(@<span class="string">"apply 之前"</span>);</span><br><span class="line">dispatch_apply(<span class="number">3</span>, <span class="built_in">queue</span>, ^(<span class="keyword">size_t</span> y) &#123;</span><br><span class="line">    <span class="keyword">switch</span> (y) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:[NSThread sleepForTimeInterval:<span class="number">1</span>];<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:[NSThread sleepForTimeInterval:<span class="number">2</span>];<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:[NSThread sleepForTimeInterval:<span class="number">3</span>];<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:<span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    NSLog(@<span class="string">"%ld"</span>,y);</span><br><span class="line">&#125;);</span><br><span class="line">NSLog(@<span class="string">"apply 之后"</span>);</span><br></pre></td></tr></table></figure>
<p>log:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">23</span> <span class="number">23</span>:<span class="number">30</span>:<span class="number">24.984</span> GCDTest[<span class="number">20779</span>:<span class="number">11373252</span>] apply 之前</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">23</span> <span class="number">23</span>:<span class="number">30</span>:<span class="number">25.985</span> GCDTest[<span class="number">20779</span>:<span class="number">11373252</span>] <span class="number">0</span></span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">23</span> <span class="number">23</span>:<span class="number">30</span>:<span class="number">26.987</span> GCDTest[<span class="number">20779</span>:<span class="number">11373585</span>] <span class="number">1</span></span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">23</span> <span class="number">23</span>:<span class="number">30</span>:<span class="number">27.988</span> GCDTest[<span class="number">20779</span>:<span class="number">11373584</span>] <span class="number">2</span></span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">23</span> <span class="number">23</span>:<span class="number">30</span>:<span class="number">27.988</span> GCDTest[<span class="number">20779</span>:<span class="number">11373252</span>] apply 之后</span><br></pre></td></tr></table></figure>
<p>将其放在异步线程去执行，这样就不阻塞主线程了：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">NSLog(@<span class="string">"dispatch_async 之前"</span>);</span><br><span class="line">dispatch_async(dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>), ^&#123;</span><br><span class="line">    <span class="keyword">dispatch_queue_t</span> <span class="built_in">queue</span> = dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">//使用dispatch_apply可以运行的更快</span></span><br><span class="line">    NSLog(@<span class="string">"apply 之前"</span>);</span><br><span class="line">    dispatch_apply(<span class="number">3</span>, <span class="built_in">queue</span>, ^(<span class="keyword">size_t</span> y) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (y) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:[NSThread sleepForTimeInterval:<span class="number">1</span>];<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:[NSThread sleepForTimeInterval:<span class="number">2</span>];<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:[NSThread sleepForTimeInterval:<span class="number">3</span>];<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        NSLog(@<span class="string">"%ld"</span>,y);</span><br><span class="line">    &#125;);</span><br><span class="line">    NSLog(@<span class="string">"apply 之后"</span>);</span><br><span class="line">&#125;);</span><br><span class="line">NSLog(@<span class="string">"dispatch_async 之后"</span>);</span><br></pre></td></tr></table></figure>
<p>log:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">23</span> <span class="number">23</span>:<span class="number">38</span>:<span class="number">21.221</span> GCDTest[<span class="number">20817</span>:<span class="number">11403936</span>] dispatch_async 之前</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">23</span> <span class="number">23</span>:<span class="number">38</span>:<span class="number">21.222</span> GCDTest[<span class="number">20817</span>:<span class="number">11403936</span>] dispatch_async 之后</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">23</span> <span class="number">23</span>:<span class="number">38</span>:<span class="number">21.222</span> GCDTest[<span class="number">20817</span>:<span class="number">11404070</span>] apply 之前</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">23</span> <span class="number">23</span>:<span class="number">38</span>:<span class="number">22.223</span> GCDTest[<span class="number">20817</span>:<span class="number">11404070</span>] <span class="number">0</span></span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">23</span> <span class="number">23</span>:<span class="number">38</span>:<span class="number">23.226</span> GCDTest[<span class="number">20817</span>:<span class="number">11404072</span>] <span class="number">1</span></span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">23</span> <span class="number">23</span>:<span class="number">38</span>:<span class="number">24.225</span> GCDTest[<span class="number">20817</span>:<span class="number">11404069</span>] <span class="number">2</span></span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">23</span> <span class="number">23</span>:<span class="number">38</span>:<span class="number">24.226</span> GCDTest[<span class="number">20817</span>:<span class="number">11404070</span>] apply 之后</span><br></pre></td></tr></table></figure>
<h5 id="dispatch_barrier_async">dispatch_barrier_async</h5><p>dispatch_barrier_async的作用就是向某个队列插入一个block，当目前正在执行的block运行完成后，阻塞这个block后面添加的block，只运行这个block直到完成，然后再继续后续的任务。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">dispatch_group_t group = dispatch_group_create<span class="list">()</span><span class="comment">;</span></span><br><span class="line">//    dispatch_queue_t queue = dispatch_get_global_queue<span class="list">(<span class="keyword">DISPATCH_QUEUE_PRIORITY_DEFAULT</span>, <span class="number">0</span>)</span><span class="comment">;</span></span><br><span class="line">dispatch_queue_t queue = dispatch_queue_create<span class="list">(<span class="string">"com.testQueue"</span>, DISPATCH_QUEUE_CONCURRENT)</span><span class="comment">;</span></span><br><span class="line">dispatch_group_async<span class="list">(<span class="keyword">group</span>, queue, ^&#123;</span><br><span class="line">    NSLog<span class="list">(@<span class="string">"group-01 - %@"</span>, [NSThread currentThread])</span><span class="comment">;</span></span><br><span class="line">&#125;)</span><span class="comment">;</span></span><br><span class="line"></span><br><span class="line">dispatch_barrier_async<span class="list">(<span class="keyword">queue</span>, ^&#123;</span><br><span class="line">    NSLog<span class="list">(@<span class="string">"barrier - %@"</span>, [NSThread currentThread])</span><span class="comment">;</span></span><br><span class="line">&#125;)</span><span class="comment">;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">dispatch_group_async<span class="list">(<span class="keyword">group</span>, queue, ^&#123;</span><br><span class="line">    for <span class="list">(<span class="keyword">int</span> i = <span class="number">0</span><span class="comment">; i &lt; 3; i++) &#123;</span></span><br><span class="line">        NSLog<span class="list">(@<span class="string">"group-02 - %@"</span>, [NSThread currentThread])</span><span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><span class="comment">;</span></span><br><span class="line"></span><br><span class="line">dispatch_group_async<span class="list">(<span class="keyword">group</span>, queue, ^&#123;</span><br><span class="line">    for <span class="list">(<span class="keyword">int</span> i = <span class="number">0</span><span class="comment">; i &lt; 3; i++) &#123;</span></span><br><span class="line">        NSLog<span class="list">(@<span class="string">"group-03 - %@"</span>, [NSThread currentThread])</span><span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><span class="comment">;</span></span></span></span><br></pre></td></tr></table></figure>
<p>log:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">23</span> <span class="number">23</span>:<span class="number">54</span>:<span class="number">08.478</span> GCDTest[<span class="number">20928</span>:<span class="number">11478999</span>] group-<span class="number">01</span> - &lt;NSThread: <span class="number">0x608000265700</span>&gt;&#123;number = <span class="number">3</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">23</span> <span class="number">23</span>:<span class="number">54</span>:<span class="number">08.478</span> GCDTest[<span class="number">20928</span>:<span class="number">11478999</span>] barrier - &lt;NSThread: <span class="number">0x608000265700</span>&gt;&#123;number = <span class="number">3</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">23</span> <span class="number">23</span>:<span class="number">54</span>:<span class="number">08.480</span> GCDTest[<span class="number">20928</span>:<span class="number">11478999</span>] group-<span class="number">02</span> - &lt;NSThread: <span class="number">0x608000265700</span>&gt;&#123;number = <span class="number">3</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">23</span> <span class="number">23</span>:<span class="number">54</span>:<span class="number">08.480</span> GCDTest[<span class="number">20928</span>:<span class="number">11478997</span>] group-<span class="number">03</span> - &lt;NSThread: <span class="number">0x60000026c680</span>&gt;&#123;number = <span class="number">4</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">23</span> <span class="number">23</span>:<span class="number">54</span>:<span class="number">08.481</span> GCDTest[<span class="number">20928</span>:<span class="number">11478999</span>] group-<span class="number">02</span> - &lt;NSThread: <span class="number">0x608000265700</span>&gt;&#123;number = <span class="number">3</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">23</span> <span class="number">23</span>:<span class="number">54</span>:<span class="number">08.481</span> GCDTest[<span class="number">20928</span>:<span class="number">11478997</span>] group-<span class="number">03</span> - &lt;NSThread: <span class="number">0x60000026c680</span>&gt;&#123;number = <span class="number">4</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">23</span> <span class="number">23</span>:<span class="number">54</span>:<span class="number">08.482</span> GCDTest[<span class="number">20928</span>:<span class="number">11478999</span>] group-<span class="number">02</span> - &lt;NSThread: <span class="number">0x608000265700</span>&gt;&#123;number = <span class="number">3</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">23</span> <span class="number">23</span>:<span class="number">54</span>:<span class="number">08.482</span> GCDTest[<span class="number">20928</span>:<span class="number">11478997</span>] group-<span class="number">03</span> - &lt;NSThread: <span class="number">0x60000026c680</span>&gt;&#123;number = <span class="number">4</span>, name = (null)&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>dispatch<em>barrier\</em>(a)sync 只在自己创建的并发队列上有效，在全局(Global)并发队列、串行队列上，效果跟dispatch_(a)sync效果一样。</li>
<li>既然在串行队列上跟dispatch_(a)sync效果一样，那就要小心别死锁！</li>
</ul>
<p>在dispatch_get_global_queue：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">23</span> <span class="number">23</span>:<span class="number">56</span>:<span class="number">14.201</span> GCDTest[<span class="number">20946</span>:<span class="number">11496633</span>] group-<span class="number">01</span> - &lt;NSThread: <span class="number">0x608000263780</span>&gt;&#123;number = <span class="number">3</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">23</span> <span class="number">23</span>:<span class="number">56</span>:<span class="number">14.201</span> GCDTest[<span class="number">20946</span>:<span class="number">11497029</span>] group-<span class="number">02</span> - &lt;NSThread: <span class="number">0x600000277200</span>&gt;&#123;number = <span class="number">5</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">23</span> <span class="number">23</span>:<span class="number">56</span>:<span class="number">14.201</span> GCDTest[<span class="number">20946</span>:<span class="number">11497030</span>] group-<span class="number">03</span> - &lt;NSThread: <span class="number">0x608000265840</span>&gt;&#123;number = <span class="number">6</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">23</span> <span class="number">23</span>:<span class="number">56</span>:<span class="number">14.201</span> GCDTest[<span class="number">20946</span>:<span class="number">11497028</span>] barrier - &lt;NSThread: <span class="number">0x608000265680</span>&gt;&#123;number = <span class="number">4</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">23</span> <span class="number">23</span>:<span class="number">56</span>:<span class="number">14.201</span> GCDTest[<span class="number">20946</span>:<span class="number">11497029</span>] group-<span class="number">02</span> - &lt;NSThread: <span class="number">0x600000277200</span>&gt;&#123;number = <span class="number">5</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">23</span> <span class="number">23</span>:<span class="number">56</span>:<span class="number">14.201</span> GCDTest[<span class="number">20946</span>:<span class="number">11497030</span>] group-<span class="number">03</span> - &lt;NSThread: <span class="number">0x608000265840</span>&gt;&#123;number = <span class="number">6</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">23</span> <span class="number">23</span>:<span class="number">56</span>:<span class="number">14.202</span> GCDTest[<span class="number">20946</span>:<span class="number">11497029</span>] group-<span class="number">02</span> - &lt;NSThread: <span class="number">0x600000277200</span>&gt;&#123;number = <span class="number">5</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">23</span> <span class="number">23</span>:<span class="number">56</span>:<span class="number">14.202</span> GCDTest[<span class="number">20946</span>:<span class="number">11497030</span>] group-<span class="number">03</span> - &lt;NSThread: <span class="number">0x608000265840</span>&gt;&#123;number = <span class="number">6</span>, name = (null)&#125;</span><br></pre></td></tr></table></figure>
<h5 id="暂停与恢复">暂停与恢复</h5><ul>
<li>dispatch_suspend(queue); 暂停队列</li>
<li>dispatch_resume(queue); 恢复队列</li>
</ul>
<p>dispatch_suspend函数对已经执行的处理没有影响。挂起后，追加到 Dispatch Queue 中但尚未执行的处理在此之后停止执行。而dispatch_resume则使得这些处理能够继续执行。</p>
<p>这里有个例子（<a href="https://github.com/ChenYilong/ParseSourceCodeStudy/blob/master/01_Parse的多线程处理思路/Parse的底层多线程处理思路.md#parse-ios-sdk介绍" target="_blank" rel="external">参考来自这里</a>）</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t queue1 = dispatch_queue_create<span class="list">(<span class="string">"com.queue1"</span>, <span class="number">0</span>)</span><span class="comment">;</span></span><br><span class="line">dispatch_queue_t queue2 = dispatch_queue_create<span class="list">(<span class="string">"com.queue2"</span>, <span class="number">0</span>)</span><span class="comment">;</span></span><br><span class="line">dispatch_group_t group  = dispatch_group_create<span class="list">()</span><span class="comment">;</span></span><br><span class="line">dispatch_async<span class="list">(<span class="keyword">queue1</span>, ^&#123;</span><br><span class="line">    NSLog<span class="list">(@<span class="string">"任务 1 ： queue 1..."</span>)</span><span class="comment">;</span></span><br><span class="line">    sleep<span class="list">(<span class="number">1</span>)</span><span class="comment">;</span></span><br><span class="line">    NSLog<span class="list">(@<span class="string">"✅完成任务 1"</span>)</span><span class="comment">;</span></span><br><span class="line">&#125;)</span><span class="comment">;</span></span><br><span class="line"></span><br><span class="line">dispatch_async<span class="list">(<span class="keyword">queue2</span>, ^&#123;</span><br><span class="line">    NSLog<span class="list">(@<span class="string">"任务 1 ： queue 2..."</span>)</span><span class="comment">;</span></span><br><span class="line">    sleep<span class="list">(<span class="number">1</span>)</span><span class="comment">;</span></span><br><span class="line">    NSLog<span class="list">(@<span class="string">"✅完成任务 2"</span>)</span><span class="comment">;</span></span><br><span class="line">&#125;)</span><span class="comment">;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">dispatch_group_async<span class="list">(<span class="keyword">group</span>, queue1, ^&#123;</span><br><span class="line">    NSLog<span class="list">(@<span class="string">"🚫正在暂停 1"</span>)</span><span class="comment">;</span></span><br><span class="line">    dispatch_suspend<span class="list">(<span class="keyword">queue1</span>)</span><span class="comment">;</span></span><br><span class="line">&#125;)</span><span class="comment">;</span></span><br><span class="line">dispatch_group_async<span class="list">(<span class="keyword">group</span>, queue2, ^&#123;</span><br><span class="line">    NSLog<span class="list">(@<span class="string">"🚫正在暂停 2"</span>)</span><span class="comment">;</span></span><br><span class="line">    dispatch_suspend<span class="list">(<span class="keyword">queue2</span>)</span><span class="comment">;</span></span><br><span class="line">&#125;)</span><span class="comment">;</span></span><br><span class="line">dispatch_group_wait<span class="list">(<span class="keyword">group</span>, DISPATCH_TIME_FOREVER)</span><span class="comment">;</span></span><br><span class="line">NSLog<span class="list">(@<span class="string">"＝＝＝＝＝＝＝等待两个queue完成, 再往下进行..."</span>)</span><span class="comment">;</span></span><br><span class="line">dispatch_async<span class="list">(<span class="keyword">queue1</span>, ^&#123;</span><br><span class="line">    NSLog<span class="list">(@<span class="string">"任务 2 ： queue 1"</span>)</span><span class="comment">;</span></span><br><span class="line">&#125;)</span><span class="comment">;</span></span><br><span class="line">dispatch_async<span class="list">(<span class="keyword">queue2</span>, ^&#123;</span><br><span class="line">    NSLog<span class="list">(@<span class="string">"任务 2 ： queue 2"</span>)</span><span class="comment">;</span></span><br><span class="line">&#125;)</span><span class="comment">;</span></span><br><span class="line">NSLog<span class="list">(@<span class="string">"🔴为什么这个NSLog会在上面两个NSLog之前打印❓❓答：dispatch_suspend的作用‼️"</span>)</span><span class="comment">;</span></span><br><span class="line"></span><br><span class="line">dispatch_resume<span class="list">(<span class="keyword">queue1</span>)</span><span class="comment">;</span></span><br><span class="line">dispatch_resume<span class="list">(<span class="keyword">queue2</span>)</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>log:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">24</span> <span class="number">22</span>:<span class="number">12</span>:<span class="number">58.646</span> GCDTest[<span class="number">22178</span>:<span class="number">12407680</span>] 任务 <span class="number">1</span> ： <span class="built_in">queue</span> <span class="number">1.</span>..</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">24</span> <span class="number">22</span>:<span class="number">12</span>:<span class="number">58.646</span> GCDTest[<span class="number">22178</span>:<span class="number">12408707</span>] 任务 <span class="number">1</span> ： <span class="built_in">queue</span> <span class="number">2.</span>..</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">24</span> <span class="number">22</span>:<span class="number">12</span>:<span class="number">59.650</span> GCDTest[<span class="number">22178</span>:<span class="number">12407680</span>] ✅完成任务 <span class="number">1</span></span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">24</span> <span class="number">22</span>:<span class="number">12</span>:<span class="number">59.650</span> GCDTest[<span class="number">22178</span>:<span class="number">12408707</span>] ✅完成任务 <span class="number">2</span></span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">24</span> <span class="number">22</span>:<span class="number">12</span>:<span class="number">59.650</span> GCDTest[<span class="number">22178</span>:<span class="number">12407680</span>] 🚫正在暂停 <span class="number">1</span></span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">24</span> <span class="number">22</span>:<span class="number">12</span>:<span class="number">59.650</span> GCDTest[<span class="number">22178</span>:<span class="number">12408707</span>] 🚫正在暂停 <span class="number">2</span></span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">24</span> <span class="number">22</span>:<span class="number">12</span>:<span class="number">59.650</span> GCDTest[<span class="number">22178</span>:<span class="number">12407286</span>] ＝＝＝＝＝＝＝等待两个<span class="built_in">queue</span>完成, 再往下进行...</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">24</span> <span class="number">22</span>:<span class="number">12</span>:<span class="number">59.651</span> GCDTest[<span class="number">22178</span>:<span class="number">12407286</span>] 🔴为什么这个NSLog会在上面两个NSLog之前打印❓❓答：dispatch_suspend的作用‼️</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">24</span> <span class="number">22</span>:<span class="number">12</span>:<span class="number">59.651</span> GCDTest[<span class="number">22178</span>:<span class="number">12408707</span>] 任务 <span class="number">2</span> ： <span class="built_in">queue</span> <span class="number">1</span></span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">24</span> <span class="number">22</span>:<span class="number">12</span>:<span class="number">59.651</span> GCDTest[<span class="number">22178</span>:<span class="number">12407680</span>] 任务 <span class="number">2</span> ： <span class="built_in">queue</span> <span class="number">2</span></span><br></pre></td></tr></table></figure>
<h4 id="Dispatch_Source_（信号源)">Dispatch Source （信号源)</h4><p>GCD中除了主要的 Dispatch Queue 外，还有不太引人注目的 Dispatch Source .它是BSD系内核惯有功能kqueue的包装。kqueue 是在 XNU 内核中发生各种事件时，在应用程序编程方执行处理的技术。其 CPU 负荷非常小，尽量不占用资源。kqueue 可以说是应用程序处理 XNU 内核中发生的各种事件的方法中最优秀的一种。</p>
<p>Dispatch Source是GCD中的一个基本类型，从字面意思可称为调度源，它的作用是当有一些特定的较底层的系统事件发生时，调度源会捕捉到这些事件，然后可以做其他的逻辑处理，调度源有多种类型，分别监听对应类型的系统事件。</p>
<p>Dispatch Source 可处理的所有事件。如下表所示：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th style="text-align:center">内容</th>
</tr>
</thead>
<tbody>
<tr>
<td>DISPATCH_SOURCE_TYPE_DATA_ADD</td>
<td style="text-align:center">变量增加</td>
</tr>
<tr>
<td>DISPATCH_SOURCE_TYPE_DATA_OR</td>
<td style="text-align:center">变量OR</td>
</tr>
<tr>
<td>DISPATCH_SOURCE_TYPE_MACH_SEND</td>
<td style="text-align:center">MACH端口发送</td>
</tr>
<tr>
<td>DISPATCH_SOURCE_TYPE_MACH_RECV</td>
<td style="text-align:center">MACH端口接收</td>
</tr>
<tr>
<td>DISPATCH_SOURCE_TYPE_PROC</td>
<td style="text-align:center">监测到与进程相关的事件</td>
</tr>
<tr>
<td>DISPATCH_SOURCE_TYPE_READ</td>
<td style="text-align:center">可读取文件映像</td>
</tr>
<tr>
<td>DISPATCH_SOURCE_TYPE_SIGNAL</td>
<td style="text-align:center">接收信号</td>
</tr>
<tr>
<td>DISPATCH_SOURCE_TYPE_TIMER</td>
<td style="text-align:center">定时器</td>
</tr>
<tr>
<td>DISPATCH_SOURCE_TYPE_VNODE</td>
<td style="text-align:center">文件系统有变更</td>
</tr>
<tr>
<td>DISPATCH_SOURCE_TYPE_WRITE</td>
<td style="text-align:center">可写入文件映像</td>
</tr>
</tbody>
</table>
<p> 其中DISPATCH_SOURCE_TYPE_DATA_ADD和DISPATCH_SOURCE_TYPE_DATA_OR是常用的两个，其它用于Mac开发的比较多。</p>
<p> 在任一线程上调用它的的一个函数 dispatch_source_merge_data 后，会执行 Dispatch Source 事先定义好的句柄（可以把句柄简单理解为一个 block ）。</p>
<p>这个过程叫 Custom event ,用户事件。是 dispatch source 支持处理的一种事件。</p>
<p>例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">dispatch_source_t</span> queueSource = dispatch_source_create(DISPATCH_SOURCE_TYPE_DATA_ADD, <span class="number">0</span>, <span class="number">0</span>, dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line"> __block NSUInteger totalComplete = <span class="number">0</span>;</span><br><span class="line">dispatch_source_set_event_handler(queueSource, ^&#123;</span><br><span class="line">    <span class="comment">//当处理事件被最终执行时，计算后的数据可以通过dispatch_source_get_data来获取。</span></span><br><span class="line">    <span class="comment">//这个数据的值在每次响应事件执行后会被重置，所以totalComplete的值是最终累积的值。</span></span><br><span class="line">    NSUInteger value = dispatch_source_get_data(queueSource);</span><br><span class="line">    totalComplete += value;</span><br><span class="line">    NSLog(@<span class="string">"进度：%@"</span>, @((CGFloat)totalComplete/<span class="number">100</span>));</span><br><span class="line">&#125;);</span><br><span class="line">  <span class="comment">/*</span><br><span class="line">  分派源创建时默认处于暂停状态，在分派源分派处理程序之前必须先恢复。</span><br><span class="line">  因为忘记恢复分派源的状态而产生bug是常见的事儿。</span><br><span class="line">  恢复的方法是调用 dispatch_resume :</span><br><span class="line">  */</span></span><br><span class="line"> dispatch_resume(queueSource);</span><br><span class="line"> </span><br><span class="line"> <span class="comment">/*</span><br><span class="line">  在每次循环中执行加1操作。也可以传递已处理记录的数目或已写入的字节数。</span><br><span class="line">  在任何线程中都可以调用 dispatch_source_merge_data 。</span><br><span class="line">  需要注意的是，不可以传递0值(事件不会被触发)，同样也不可以传递负数(会无穷大)。</span><br><span class="line">  */</span></span><br><span class="line"> <span class="keyword">dispatch_queue_t</span> <span class="built_in">queue</span> = dispatch_queue_create(<span class="string">"com.sourcequeue"</span>, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line"> <span class="keyword">for</span> (NSUInteger index = <span class="number">0</span>; index &lt; <span class="number">10</span>; index++) &#123;</span><br><span class="line">     dispatch_async(<span class="built_in">queue</span>, ^&#123;</span><br><span class="line">         dispatch_source_merge_data(queueSource, <span class="number">1</span>);</span><br><span class="line">         [NSThread sleepForTimeInterval:<span class="number">1</span>];</span><br><span class="line">     &#125;);</span><br><span class="line"> &#125;</span><br><span class="line"> NSLog(@<span class="string">"queue for 循环 完成"</span>);</span><br></pre></td></tr></table></figure>
<p>log:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">25</span> <span class="number">09</span>:<span class="number">35</span>:<span class="number">20.128</span> GCDTest[<span class="number">22525</span>:<span class="number">12717227</span>] <span class="built_in">queue</span> <span class="keyword">for</span> 循环 完成</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">25</span> <span class="number">09</span>:<span class="number">35</span>:<span class="number">20.129</span> GCDTest[<span class="number">22525</span>:<span class="number">12718440</span>] 进度：<span class="number">0.3</span></span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">25</span> <span class="number">09</span>:<span class="number">35</span>:<span class="number">20.129</span> GCDTest[<span class="number">22525</span>:<span class="number">12718440</span>] 进度：<span class="number">0.4</span></span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">25</span> <span class="number">09</span>:<span class="number">35</span>:<span class="number">20.129</span> GCDTest[<span class="number">22525</span>:<span class="number">12718440</span>] 进度：<span class="number">0.6</span></span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">25</span> <span class="number">09</span>:<span class="number">35</span>:<span class="number">20.130</span> GCDTest[<span class="number">22525</span>:<span class="number">12718440</span>] 进度：<span class="number">0.9</span></span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">25</span> <span class="number">09</span>:<span class="number">35</span>:<span class="number">20.130</span> GCDTest[<span class="number">22525</span>:<span class="number">12718440</span>] 进度：<span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>可以看到 0.1~1 并没有全部打印，而是跳过：</p>
<p>这是 DispatchSource 能通过合并事件的方式确保在高负载下正常工作 的能力</p>
<p>在同一时间，只有一个处理 block 的实例被分配，如果这个处理方法还没有执行完毕，另一个事件就发生了，事件会以指定方式（ADD或 OR）进行累积。DispatchSource能通过合并事件（block）的方式确保在高负载下正常工作。当处理事件被最终执行时，计算后的数据可以通过 dispatch_source_get_data 来获取。这个数据的值在每次响应时间执行后会被重置，所以上面的例子中进度条 totalComplete 的值是最终积累的值，而 block 不是每次都执行的。但能确保进度条能从0.0到1.0的正常执行。</p>
<h4 id="Dispatch_Semaphore_信号量">Dispatch Semaphore 信号量</h4><p>为了展示作用，举个反例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dispatch_queue_t</span> <span class="built_in">queue</span> = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</span><br><span class="line"> NSMutableArray *<span class="built_in">array</span> = [[NSMutableArray alloc] init];</span><br><span class="line"> <span class="keyword">dispatch_group_t</span> group = dispatch_group_create();</span><br><span class="line"> <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; <span class="number">100000</span>; ++i) &#123;</span><br><span class="line">     dispatch_group_async(group, <span class="built_in">queue</span>, ^&#123;</span><br><span class="line">         [<span class="built_in">array</span> addObject:[NSNumber numberWithInt:i]];</span><br><span class="line">     &#125;);</span><br><span class="line"> &#125;</span><br><span class="line"> dispatch_group_wait(group, DISPATCH_TIME_FOREVER);</span><br><span class="line"> NSLog(@<span class="string">"%@"</span>,  @([<span class="built_in">array</span> count]));</span><br></pre></td></tr></table></figure>
<p>然后就发生了崩溃：</p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">malloc: *** error <span class="keyword">for</span> object <span class="number">0x7f88ed03ca00</span>: pointer being freed was <span class="operator">not</span> allocated</span><br><span class="line">*** <span class="built_in">set</span> <span class="operator">a</span> <span class="built_in">breakpoint</span> <span class="operator">in</span> malloc_error_break <span class="built_in">to</span> debug</span><br></pre></td></tr></table></figure>
<p>这种资源抢夺的情况，一般的做法是使用串行队列，或者像下面一样的同步队列，得以解决：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dispatch_queue_t</span> <span class="built_in">queue</span> = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</span><br><span class="line">NSMutableArray *<span class="built_in">array</span> = [[NSMutableArray alloc] init];</span><br><span class="line"><span class="keyword">dispatch_group_t</span> group = dispatch_group_create();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; <span class="number">1000</span>; ++i) &#123;</span><br><span class="line">    dispatch_sync(<span class="built_in">queue</span>, ^&#123;</span><br><span class="line">        [<span class="built_in">array</span> addObject:[NSNumber numberWithInt:i]];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">dispatch_group_wait(group, DISPATCH_TIME_FOREVER);</span><br><span class="line">NSLog(@<span class="string">"%@"</span>,  @([<span class="built_in">array</span> count]));</span><br></pre></td></tr></table></figure>
<p>dispatch_semaphore_t 的作用之一就是解决这种资源抢夺的情况,下面展示下展示使用 dispatch_semaphore_t 的解决方案：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dispatch_queue_t</span> <span class="built_in">queue</span> = dispatch_queue_create(<span class="string">"com.semaphore"</span>, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line"><span class="keyword">dispatch_semaphore_t</span> semaphore = dispatch_semaphore_create(<span class="number">1</span>);</span><br><span class="line">NSMutableArray *<span class="built_in">array</span> = [[NSMutableArray alloc] init];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">    dispatch_async(<span class="built_in">queue</span>, ^&#123;</span><br><span class="line">        dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</span><br><span class="line">        NSLog(@<span class="string">"🔴%@  index = %d"</span>,[NSThread currentThread],i);</span><br><span class="line">        [<span class="built_in">array</span> addObject:@(i)];</span><br><span class="line">        dispatch_semaphore_signal(semaphore);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">dispatch_barrier_async(<span class="built_in">queue</span>, ^&#123;</span><br><span class="line">    NSLog(@<span class="string">"🔴类名与方法名：%s（在第%d行），描述：%@"</span>, __PRETTY_FUNCTION__, __LINE__, @([<span class="built_in">array</span> count]));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>测试,设置：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dispatch_semaphore_t</span> semaphore = dispatch_semaphore_create(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p>可以发现 程序会永远停留在：</p>
<figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">等待<span class="keyword">Dispatch</span> Semaphore</span><br><span class="line">一直等待，直到<span class="keyword">Dispatch</span> Semaphore的计数值达到大于等于<span class="number">1</span></span><br><span class="line">dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</span><br></pre></td></tr></table></figure>
<p><a href="http://www.cnblogs.com/snailHL/p/3906112.html" target="_blank" rel="external">关于信号量这里有非常详细的解释</a></p>
<p>dispatch_semaphore是GCD用来同步的一种方式，与他相关的共有三个函数，分别是</p>
<p>dispatch_semaphore_create，dispatch_semaphore_signal，dispatch_semaphore_wait。</p>
<p>下面我们逐一介绍三个函数：</p>
<p>①dispatch_semaphore_create的声明为：</p>
<pre><code><span class="keyword">dispatch_semaphore_t</span>  dispatch_semaphore_create(<span class="keyword">long</span> value);

传入的参数为<span class="keyword">long</span>，输出一个<span class="keyword">dispatch_semaphore_t</span>类型且值为value的信号量。

值得注意的是，这里的传入的参数value必须大于或等于<span class="number">0</span>，否则dispatch_semaphore_create会返回<span class="literal">NULL</span>。

（关于信号量，我就不在这里累述了，网上很多介绍这个的。我们这里主要讲一下dispatch_semaphore这三个函数的用法）。
</code></pre><p>②dispatch_semaphore_signal的声明为：</p>
<pre><code><span class="keyword">long</span> dispatch_semaphore_signal(dispatch_semaphore_t dsema)

这个函数会使传入的信号量dsema的值加<span class="number">1</span>；（至于返回值，待会儿再讲）
dispatch_semaphore_signal的返回值为<span class="keyword">long</span>类型，当返回值为<span class="number">0</span>时表示当前并没有线程等待其处理的信号量，其处理

的信号量的值加<span class="number">1</span>即可。当返回值不为<span class="number">0</span>时，表示其当前有（一个或多个）线程等待其处理的信号量，并且该函数唤醒了一

个等待的线程（当线程有优先级时，唤醒优先级最高的线程；否则随机唤醒）。

dispatch_semaphore_wait的返回值也为<span class="keyword">long</span>型。当其返回<span class="number">0</span>时表示在timeout之前，该函数所处的线程被成功唤醒。

当其返回不为<span class="number">0</span>时，表示timeout发生。
</code></pre><p>③dispatch_semaphore_wait的声明为：</p>
<pre><code>long dispatch_semaphore_wait(dispatch_semaphore_t dsema, dispatch_time_t <span class="keyword">timeout</span>)；

这个函数会使传入的信号量dsema的值减<span class="number">1</span>；

这个函数的作用是这样的，如果dsema信号量的值大于<span class="number">0</span>，该函数所处线程就继续执行下面的语句，并且将信号量的值减<span class="number">1</span>；

如果desema的值为<span class="number">0</span>，那么这个函数就阻塞当前线程等待<span class="keyword">timeout</span>（注意<span class="keyword">timeout</span>的类型为dispatch_time_t，

不能直接传入整形或float型数），如果等待的期间desema的值被dispatch_semaphore_signal函数加<span class="number">1</span>了，

且该函数（即dispatch_semaphore_wait）所处线程获得了信号量，那么就继续向下执行并将信号量减<span class="number">1</span>。

如果等待期间没有获取到信号量或者信号量的值一直为<span class="number">0</span>，那么等到<span class="keyword">timeout</span>时，其所处线程自动执行其后语句。
</code></pre><p>关于信号量，这里有一个很形象的解释：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">停车场剩余<span class="number">4</span>个车位，那么即使同时来了四辆车也能停的下。如果此时来了五辆车，那么就有一辆需要等待。</span><br><span class="line">信号量的值就相当于剩余车位的数目，dispatch_semaphore_<span class="built_in">wait</span>函数就相当于来了一辆车，dispatch_semaphore_signal</span><br><span class="line">就相当于走了一辆车。停车位的剩余数目在初始化的时候就已经指明了（dispatch_semaphore_create（long value）），</span><br><span class="line">调用一次dispatch_semaphore_signal，剩余的车位就增加一个；调用一次dispatch_semaphore_<span class="built_in">wait</span>剩余车位就减少一个；</span><br><span class="line">当剩余车位为<span class="number">0</span>时，再来车（即调用dispatch_semaphore_<span class="built_in">wait</span>）就只能等待。有可能同时有几辆车等待一个停车位。有些车主</span><br><span class="line">没有耐心，给自己设定了一段等待时间，这段时间内等不到停车位就走了，如果等到了就开进去停车。而有些车主就像把车停在这，</span><br><span class="line">所以就一直等下去。</span><br></pre></td></tr></table></figure>
<p>本文到此就结束了</p>
<hr>
<p>参考：</p>
<p><a href="https://github.com/ChenYilong/ParseSourceCodeStudy/blob/master/01_Parse的多线程处理思路/Parse的底层多线程处理思路.md" target="_blank" rel="external">Parse源码浅析系列（一）—Parse的底层多线程处理思路：GCD高级用法</a></p>
<p><a href="http://www.cnblogs.com/snailHL/p/3906112.html" target="_blank" rel="external">关于dispatch_semaphore的使用</a></p>
<p><a href="http://tutuge.me/2015/04/03/something-about-gcd/#避免死锁！" target="_blank" rel="external">GCD使用经验与技巧浅谈</a></p>
<p><a href="http://blog.leichunfeng.com/blog/2015/07/29/ios-concurrency-programming-operation-queues/#jtss-tsina" target="_blank" rel="external">iOS 并发编程之 Operation Queues</a></p>
<p><a href="http://www.jianshu.com/p/0b0d9b1f1f19" target="_blank" rel="external">关于iOS多线程，你看我就够了</a></p>
<p><a href="http://www.jianshu.com/p/8ed06312d8bd" target="_blank" rel="external">小笨狼漫谈多线程：NSThread</a></p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2016/08/16/RegularExpression/" itemprop="url">
                iOS 正则表达式
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2016-08-16T21:59:49+08:00" content="2016-08-16">
            2016-08-16
          </time>
        </span>

        

        
          
        
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><h3 id="正则表达式">正则表达式</h3><h5 id="界定符">界定符</h5><p>表示一个正则表达式的开始和结束</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/[<span class="number">0</span>-<span class="number">9</span>]/</span><br></pre></td></tr></table></figure>
<p>在iOS中不加界定符</p>
<h5 id="原子">原子</h5><p>①可见原子<br><br>Unicode 编码表中用键盘输出后可见的字符</p>
<figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-<span class="ruby"> 标点；“<span class="number">_</span>?. 等等</span><br><span class="line"></span>-<span class="ruby"> 英文数字a-z,<span class="constant">A</span>-<span class="constant">Z</span>,<span class="number">0</span>-<span class="number">9</span></span><br><span class="line"></span>-<span class="ruby"> 数理化公式符号</span><br><span class="line"></span>-<span class="ruby"> 其他可见字符</span></span><br></pre></td></tr></table></figure>
<p>②不可见原子<br><br>Unicode 编码表中用键盘输出后不可见的字符</p>
<figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-<span class="ruby"> 换行符\n</span><br><span class="line"></span>-<span class="ruby"> 回车 \r</span><br><span class="line"></span>-<span class="ruby"> 制表符 \t</span><br><span class="line"></span>-<span class="ruby"> 空格</span><br><span class="line"></span>-<span class="ruby"> 其他不可见符号</span></span><br></pre></td></tr></table></figure>
<h5 id="元字符">元字符</h5><p>①原子的筛选方式</p>
<figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-<span class="ruby"> |   匹配两个或者多个分支选择</span><br><span class="line"></span>-<span class="ruby"> []  匹配方括号中的任意一个原子</span><br><span class="line"></span>-<span class="ruby"> [^] 匹配除方括号中的原子之外的任意字符</span></span><br></pre></td></tr></table></figure>
<p>②原子的集合</p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- .  匹配除换行符之外的任意字符</span><br><span class="line">- <span class="command">\d</span> 匹配任意一个十进制数字，即<span class="special">[</span>0-9<span class="special">]</span></span><br><span class="line">- <span class="command">\D</span> 匹配任意一个非十进制数字，即<span class="special">[</span>^0-9<span class="special">]</span></span><br><span class="line">- <span class="command">\s</span> 匹配一个不可见原子，即<span class="special">[</span><span class="command">\f</span><span class="command">\n</span><span class="command">\r</span><span class="command">\t</span><span class="command">\v</span><span class="special">]</span></span><br><span class="line">- <span class="command">\S</span> 匹配一个可见原子，即<span class="special">[</span>^<span class="command">\f</span><span class="command">\n</span><span class="command">\r</span><span class="command">\t</span><span class="command">\v</span><span class="special">]</span></span><br><span class="line">- <span class="command">\w</span> 匹配任意一个数字、字母或下划线，即<span class="special">[</span>0-9a-zA-Z_<span class="special">]</span></span><br><span class="line">- <span class="command">\W</span> 匹配任意一个非数字、字母或下划线，即<span class="special">[</span>^0-9a-zA-Z_<span class="special">]</span></span><br></pre></td></tr></table></figure>
<h5 id="量词">量词</h5><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-<span class="ruby"> &#123;n&#125;   表示其前面的原子恰好出现 n 次</span><br><span class="line"></span>-<span class="ruby"> &#123;n,&#125;  表示其前面的原子至少出现 n 次</span><br><span class="line"></span>-<span class="ruby"> &#123;n,m&#125; 表示其前面的原子恰好出现 n 次，最多出现m次</span><br><span class="line"></span>-<span class="ruby"> *     匹配<span class="number">0</span>次、<span class="number">1</span>次或者多次其之前的原子，即&#123;<span class="number">0</span>,&#125; </span><br><span class="line"></span>-<span class="ruby"> +     匹配一次或者多次其之前的原子，即&#123;<span class="number">1</span>,&#125;</span><br><span class="line"></span>-<span class="ruby"> ?     匹配<span class="number">0</span>次或者<span class="number">1</span>次其之前的原子，即&#123;<span class="number">0</span>,<span class="number">1</span>&#125;</span></span><br></pre></td></tr></table></figure>
<h5 id="边界控制与模式单元">边界控制与模式单元</h5><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-<span class="ruby"> ^  匹配字符串开始的位置</span><br><span class="line"></span>-<span class="ruby"> <span class="variable">$ </span> 匹配字符串结尾的位置</span><br><span class="line"></span>-<span class="ruby"> () 匹配其中的整体为一个原子</span></span><br></pre></td></tr></table></figure>
<h5 id="修正模式">修正模式</h5><p>常见的修正模式</p>
<figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-<span class="ruby"> <span class="constant">U</span> 懒惰匹配</span><br><span class="line"></span>-<span class="ruby"> i 忽略英文字母大小写</span><br><span class="line"></span>-<span class="ruby"> x 忽略空白</span><br><span class="line"></span>-<span class="ruby"> s 让元字符 <span class="string">` . `</span> 匹配包括换行符在内所有字符</span><br><span class="line"></span>-<span class="ruby"> e iOS 暂未知</span></span><br></pre></td></tr></table></figure>
<hr>
<p>好以上是正则的简单介绍，详细请看这个：<a href="http://www.jb51.net/tools/zhengze.html" target="_blank" rel="external">正则表达式30分钟入门教程</a></p>
<h3 id="iOS_正则表达式">iOS 正则表达式</h3><p>服务器每次返回的时间格式是这个样子的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2016</span>-<span class="number">08</span>-<span class="number">13</span>T13:<span class="number">06</span>:<span class="number">48</span>Z</span><br></pre></td></tr></table></figure>
<p>显示的时候只要年月日 或者是时分秒：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2016</span>-<span class="number">08</span>-<span class="number">13</span></span><br><span class="line"><span class="number">13</span>:<span class="number">06</span>:<span class="number">48</span></span><br></pre></td></tr></table></figure>
<p>这里常用的有两种方法<br></p>
<ol>
<li>使用 NSDateFormatter 格式化，来解析这时间格式的字符串，转换成 NSDate 格式，然后在格式化一次转换成相应的格式（这种方法感觉很蛋疼，折腾了两次）；<br></li>
<li>使用 NSString 分割方法:</li>
</ol>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">-</span> (<span class="tag">NSArray</span>&lt;<span class="tag">NSString</span> *&gt; *)<span class="rule"><span class="attribute">componentsSeparatedByString</span>:<span class="value">(NSString *)separator</span></span>;</span><br></pre></td></tr></table></figure>
<p>以 “T” 进行分割，最终得出自己想要的字符串；</p>
<hr>
<p>这两种方法是常用的方法，但是用起来总感觉不爽，后来想想还可以用 正则表达式，那就试试</p>
<h3 id="使用正则表达式来解析这个时间格式">使用正则表达式来解析这个时间格式</h3><p>在iOS中通常使用 “NSRegularExpression” 进行字符串匹配，一般是这个样子：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">     <span class="built_in">NSString</span> *string = <span class="string">@"字符串xxxx"</span>;</span><br><span class="line">     <span class="built_in">NSString</span> *regexString = <span class="string">@"正则表达式"</span>;</span><br><span class="line">     <span class="built_in">NSRegularExpression</span> *regex = [<span class="built_in">NSRegularExpression</span> regularExpressionWithPattern:regexString options:<span class="built_in">NSRegularExpressionCaseInsensitive</span> error:<span class="literal">nil</span>];</span><br><span class="line">     <span class="built_in">NSArray</span> *matches = [regex matchesInString:string options:<span class="built_in">NSMatchingReportProgress</span> range:<span class="built_in">NSMakeRange</span>(<span class="number">0</span>, string<span class="variable">.length</span>)];</span><br><span class="line">     <span class="keyword">for</span> (<span class="built_in">NSTextCheckingResult</span> *match <span class="keyword">in</span> matches) &#123;</span><br><span class="line"><span class="comment">// do something...</span></span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>下面我们来写这个正则来匹配出  年月日 和 时分秒。具体的正则写法请自行Google，不过我在这里介绍一个好网站<a href="https://regexper.com" target="_blank" rel="external">regexper</a>可以分析你写的正则表达式；匹配时间的正则我已经写好了：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^(\\d&#123;<span class="number">4</span>&#125;-\\d&#123;<span class="number">1</span>,<span class="number">2</span>&#125;-\\d&#123;<span class="number">1</span>,<span class="number">2</span>&#125;)T(\\d&#123;<span class="number">1</span>,<span class="number">2</span>&#125;:\\d&#123;<span class="number">1</span>,<span class="number">2</span>&#125;:\\d&#123;<span class="number">1</span>,<span class="number">2</span>&#125;)Z$</span><br></pre></td></tr></table></figure>
<p>在正则表达式中 有group之分，看上面的正则：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">group<span class="preprocessor">#<span class="number">1</span>:</span></span><br><span class="line">(\\d&#123;<span class="number">4</span>&#125;-\\d&#123;<span class="number">1</span>,<span class="number">2</span>&#125;-\\d&#123;<span class="number">1</span>,<span class="number">2</span>&#125;)</span><br><span class="line">group<span class="preprocessor">#<span class="number">2</span>:</span></span><br><span class="line">(\\d&#123;<span class="number">1</span>,<span class="number">2</span>&#125;:\\d&#123;<span class="number">1</span>,<span class="number">2</span>&#125;:\\d&#123;<span class="number">1</span>,<span class="number">2</span>&#125;)</span><br></pre></td></tr></table></figure>
<p>group#1 匹配的是年月日，group#2匹配的是时分秒，正则匹配之后，我们是可以分别取出这两个group匹配出来的值的；在iOS中“NSRegularExpression”类，也是有的；下面是匹配：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *string = <span class="string">@"2016-08-13T13:06:48Z"</span>;</span><br><span class="line"><span class="built_in">NSString</span> *regexString = <span class="string">@"^(\\d&#123;4&#125;-\\d&#123;1,2&#125;-\\d&#123;1,2&#125;)T(\\d&#123;1,2&#125;:\\d&#123;1,2&#125;:\\d&#123;1,2&#125;)Z$"</span>;</span><br><span class="line"><span class="built_in">NSRegularExpression</span> *regex = [<span class="built_in">NSRegularExpression</span> regularExpressionWithPattern:regexString options:<span class="built_in">NSRegularExpressionCaseInsensitive</span> error:<span class="literal">nil</span>];</span><br><span class="line"><span class="built_in">NSArray</span> *matches = [regex matchesInString:string options:<span class="built_in">NSMatchingReportProgress</span> range:<span class="built_in">NSMakeRange</span>(<span class="number">0</span>, string<span class="variable">.length</span>)];</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">NSTextCheckingResult</span> *match <span class="keyword">in</span> matches) &#123;</span><br><span class="line">    <span class="built_in">NSString</span>* group0 = [string substringWithRange:[match rangeAtIndex:<span class="number">0</span>]];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"group0 :%@"</span>, group0);</span><br><span class="line">    <span class="built_in">NSString</span>* group1 = [string substringWithRange:[match rangeAtIndex:<span class="number">1</span>]];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"group1 :%@"</span>, group1);</span><br><span class="line">    <span class="built_in">NSString</span>* group2 = [string substringWithRange:[match rangeAtIndex:<span class="number">2</span>]];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"group2 :%@"</span>, group2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用正则匹配出来之后，NSTextCheckingResult 中 使用 “[match rangeAtIndex:xxx]” 可以取出来。在这里NSTextCheckingResult 中 ：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">NSTextCheckingResult 类属性numberOfRanges 为<span class="number">3</span></span><br><span class="line">[match rangeAtIndex:<span class="number">0</span>] 匹配的是全量即：<span class="number">2016</span>-<span class="number">08</span>-<span class="number">13</span>T13:<span class="number">06</span>:<span class="number">48</span>Z</span><br><span class="line">[match rangeAtIndex:<span class="number">1</span>] 匹配的是：<span class="number">2016</span>-<span class="number">08</span>-<span class="number">13</span></span><br><span class="line">[match rangeAtIndex:<span class="number">2</span>] 匹配的是：<span class="number">13</span>:<span class="number">06</span>:<span class="number">48</span></span><br></pre></td></tr></table></figure>
<p>这下处理不就简单了许多。</p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2016/06/30/CATransition/" itemprop="url">
                CATransition 转场动画
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2016-06-30T07:39:42+08:00" content="2016-06-30">
            2016-06-30
          </time>
        </span>

        

        
          
        
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><h3 id="CATransition_转场动画">CATransition 转场动画</h3><p>转场动画就是从一个场景以动画的形式过渡到另一个场景，navigation的push就是一种转场方式（后面会介绍如何自定义）。<br>转场动画一般分为这几个步骤：<br>(1)初始化转场动画<br>(2)设置转场类型属性等<br>(3)设置转场后的新视图并添加动画到图层<br>下表列出了常用的转场类型(注意私有API是苹果官方没有公开的动画类型，但是目前通过仍然可以使用)：</p>
<h5 id="公开API">公开API</h5><table>
<thead>
<tr>
<th style="text-align:left">动画类型</th>
<th style="text-align:right">说明</th>
<th style="text-align:center">对应常量</th>
<th>是否支持方向设置</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">fade</td>
<td style="text-align:right">淡出效果</td>
<td style="text-align:center">kCATransitionFade</td>
<td>是</td>
</tr>
<tr>
<td style="text-align:left">movein</td>
<td style="text-align:right">新视图移动到旧视图上</td>
<td style="text-align:center">kCATransitionMoveIn</td>
<td>是</td>
</tr>
<tr>
<td style="text-align:left">push</td>
<td style="text-align:right">新视图推出旧视图</td>
<td style="text-align:center">kCATransitionPush</td>
<td>是</td>
</tr>
<tr>
<td style="text-align:left">reveal</td>
<td style="text-align:right">移开旧视图显示新视图</td>
<td style="text-align:center">kCATransitionReveal</td>
<td>是</td>
</tr>
</tbody>
</table>
<h5 id="私有API———-私有API只能通过字符串访问">私有API———-私有API只能通过字符串访问</h5><table>
<thead>
<tr>
<th style="text-align:left">动画类型</th>
<th style="text-align:right">说明</th>
<th style="text-align:center">对应常量</th>
<th>是否支持方向设置</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">cube</td>
<td style="text-align:right">立方体翻转效果</td>
<td style="text-align:center">无</td>
<td>是</td>
</tr>
<tr>
<td style="text-align:left">oglFlip</td>
<td style="text-align:right">翻转效果</td>
<td style="text-align:center">无</td>
<td>是</td>
</tr>
<tr>
<td style="text-align:left">suckEffect</td>
<td style="text-align:right">收缩效果</td>
<td style="text-align:center">无</td>
<td>否</td>
</tr>
<tr>
<td style="text-align:left">rippleEffect</td>
<td style="text-align:right">水滴波纹效果</td>
<td style="text-align:center">无</td>
<td>否</td>
</tr>
<tr>
<td style="text-align:left">pageCurl</td>
<td style="text-align:right">向上翻页效果</td>
<td style="text-align:center">无</td>
<td>是</td>
</tr>
<tr>
<td style="text-align:left">pageUnCurl</td>
<td style="text-align:right">向下翻页效果</td>
<td style="text-align:center">无</td>
<td>是</td>
</tr>
<tr>
<td style="text-align:left">cameralIrisHollowOpen</td>
<td style="text-align:right">摄像头打开效果</td>
<td style="text-align:center">无</td>
<td>否</td>
</tr>
<tr>
<td style="text-align:left">cameraIrisHollowClose</td>
<td style="text-align:right">摄像头关闭效果</td>
<td style="text-align:center">无</td>
<td>否</td>
</tr>
</tbody>
</table>
<h5 id="另外对于支持方向设置的动画类型还包含子类型">另外对于支持方向设置的动画类型还包含子类型</h5><table>
<thead>
<tr>
<th style="text-align:left">动画子类型</th>
<th style="text-align:right">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">kCATransitionFromRight</td>
<td style="text-align:right">从右侧转场</td>
</tr>
<tr>
<td style="text-align:left">kCATransitionFromLeft</td>
<td style="text-align:right">从左侧转场</td>
</tr>
<tr>
<td style="text-align:left">kCATransitionFromTop</td>
<td style="text-align:right">从顶部转场</td>
</tr>
<tr>
<td style="text-align:left">kCATransitionFromBottom</td>
<td style="text-align:right">从底部转场</td>
</tr>
</tbody>
</table>
<p>下面是一个小例子：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CATransition</span> *transition = [<span class="built_in">CATransition</span> animation];</span><br><span class="line">transition<span class="variable">.duration</span> = <span class="number">1.0</span>f;</span><br><span class="line">transition<span class="variable">.type</span> = <span class="string">@"cube"</span>;</span><br><span class="line"></span><br><span class="line">transition<span class="variable">.subtype</span> = k<span class="built_in">CATransitionFromRight</span>;</span><br><span class="line"><span class="built_in">UIView</span> *cubeView = [[<span class="built_in">UIView</span> alloc] initWithFrame:<span class="built_in">CGRectMake</span>(<span class="number">100</span>, <span class="number">100</span>, <span class="number">200</span>, <span class="number">300</span>)];</span><br><span class="line">cubeView<span class="variable">.backgroundColor</span> = [<span class="built_in">UIColor</span> cyanColor];</span><br><span class="line">[<span class="keyword">self</span><span class="variable">.view</span><span class="variable">.layer</span> addAnimation:transition forKey:<span class="string">@"cubeView"</span>];</span><br><span class="line">[<span class="keyword">self</span><span class="variable">.view</span> addSubview:cubeView];</span><br></pre></td></tr></table></figure>
<h4 id="感谢一下博客">感谢一下博客</h4><p><a href="http://www.cnblogs.com/kenshincui/p/3972100.html#autoid-3-3-0" target="_blank" rel="external">http://www.cnblogs.com/kenshincui/p/3972100.html#autoid-3-3-0</a></p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">&raquo;</a>
  </nav>

 </div>

        

        
      </div>

      
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      <section class="site-overview">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" src="/images/default_avatar.jpg" alt="Share" itemprop="image"/>
          <p class="site-author-name" itemprop="name">Share</p>
        </div>
        <p class="site-description motion-element" itemprop="description">just do it !</p>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">15</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          <div class="site-state-item site-state-categories">
            
              <span class="site-state-item-count">0</span>
              <span class="site-state-item-name">分类</span>
              
          </div>

          <div class="site-state-item site-state-tags">
            <a href="/tags">
              <span class="site-state-item-count">0</span>
              <span class="site-state-item-name">标签</span>
              </a>
          </div>

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        <div class="links-of-author motion-element">
          
        </div>

      </section>

      

    </div>
  </aside>


    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner"> <div class="copyright" >
  
  &copy; &nbsp;  2015 - 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="icon-next-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Share</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>


 </div>
    </footer>

    <div class="back-to-top"></div>
  </div>

  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  
  
    
    

  


  
  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script>
  <script type="text/javascript" src="/js/fancy-box.js?v=0.4.5.1"></script>


  <script type="text/javascript" src="/js/helpers.js?v=0.4.5.1"></script>
  

  <script type="text/javascript" src="/vendors/velocity/velocity.min.js"></script>
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js"></script>

  <script type="text/javascript" src="/js/motion_global.js?v=0.4.5.1" id="motion.global"></script>




  <script type="text/javascript" src="/js/nav-toggle.js?v=0.4.5.1"></script>
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  

  <script type="text/javascript">
    $(document).ready(function () {
      if (CONFIG.sidebar === 'always') {
        displaySidebar();
      }
      if (isMobile()) {
        FastClick.attach(document.body);
      }
    });
  </script>

  
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
      processEscapes: true,
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
  });
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for (i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>


  
  

  
  <script type="text/javascript" src="/js/lazyload.js"></script>
  <script type="text/javascript">
    $(function () {
      $("#posts").find('img').lazyload({
        placeholder: "/images/loading.gif",
        effect: "fadeIn"
      });
    });
  </script>
</body>
</html>
