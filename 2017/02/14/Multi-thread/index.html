<!doctype html>
<html class="theme-next use-motion theme-next-mist">
<head>
  

<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />








  <link rel="stylesheet" type="text/css" href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5"/>




<link rel="stylesheet" type="text/css" href="/css/main.css?v=0.4.5.1"/>


    <meta name="description" content="just do it !" />



  <meta name="keywords" content="Hexo,next" />





  <link rel="shorticon icon" type="image/x-icon" href="/favicon.ico?v=0.4.5.1" />


<meta name="description" content="iOS多线程前言在这篇文章中我整理了iOS多线程开发需要的一些知识点、方法和事项。本文主要讲述三部分 NSThread、Operation 和 GCD。本文不算是原创，是一些我觉得写的比较有质量文章的综合，文中摘抄了这些文章中的部分内容，在文中和文章末尾我已标注出处，之所以要摘抄是因为在需要之时，打开URL 是404 😂😂😂。我综合了这些文中给自己学习之用，也给大家方便查看之用，如有错误之处">
<meta property="og:type" content="article">
<meta property="og:title" content="iOS多线程">
<meta property="og:url" content="http://yoursite.com/2017/02/14/Multi-thread/index.html">
<meta property="og:site_name" content="吾生也有涯，而知也无涯">
<meta property="og:description" content="iOS多线程前言在这篇文章中我整理了iOS多线程开发需要的一些知识点、方法和事项。本文主要讲述三部分 NSThread、Operation 和 GCD。本文不算是原创，是一些我觉得写的比较有质量文章的综合，文中摘抄了这些文章中的部分内容，在文中和文章末尾我已标注出处，之所以要摘抄是因为在需要之时，打开URL 是404 😂😂😂。我综合了这些文中给自己学习之用，也给大家方便查看之用，如有错误之处">
<meta property="og:updated_time" content="2017-02-14T07:00:40.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="iOS多线程">
<meta name="twitter:description" content="iOS多线程前言在这篇文章中我整理了iOS多线程开发需要的一些知识点、方法和事项。本文主要讲述三部分 NSThread、Operation 和 GCD。本文不算是原创，是一些我觉得写的比较有质量文章的综合，文中摘抄了这些文章中的部分内容，在文中和文章末尾我已标注出处，之所以要摘抄是因为在需要之时，打开URL 是404 😂😂😂。我综合了这些文中给自己学习之用，也给大家方便查看之用，如有错误之处">


<script type="text/javascript" id="hexo.configuration">
  var CONFIG = {
    scheme: 'Mist',
    sidebar: 'post'
  };
</script>



  <title> iOS多线程 | 吾生也有涯，而知也无涯 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  <!--[if lte IE 8]>
  <div style=' clear: both; height: 59px; padding:0 0 0 15px; position: relative;margin:0 auto;'>
    <a href="http://windows.microsoft.com/en-US/internet-explorer/products/ie/home?ocid=ie6_countdown_bannercode">
      <img src="http://7u2nvr.com1.z0.glb.clouddn.com/picouterie.jpg" border="0" height="42" width="820"
           alt="You are using an outdated browser. For a faster, safer browsing experience, upgrade for free today or use other browser ,like chrome firefox safari."
           style='margin-left:auto;margin-right:auto;display: block;'/>
    </a>
  </div>
<![endif]-->
  






  <div class="container one-column page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><h1 class="site-meta">
  <span class="logo-line-before"><i></i></span>
  <a href="/" class="brand" rel="start">
      <span class="logo">
        <i class="icon-next-logo"></i>
      </span>
      <span class="site-title">吾生也有涯，而知也无涯</span>
  </a>
  <span class="logo-line-after"><i></i></span>
</h1>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu ">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            <i class="menu-item-icon icon-next-home"></i> <br />
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            <i class="menu-item-icon icon-next-archives"></i> <br />
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            <i class="menu-item-icon icon-next-tags"></i> <br />
            标签
          </a>
        </li>
      

      
      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div id="content" class="content"> 

  <div id="posts" class="posts-expand">
    

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              iOS多线程
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2017-02-14T15:00:40+08:00" content="2017-02-14">
            2017-02-14
          </time>
        </span>

        

        
          
        
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        <span itemprop="articleBody"><h2 id="iOS多线程">iOS多线程</h2><h3 id="前言">前言</h3><p>在这篇文章中我整理了iOS多线程开发需要的一些知识点、方法和事项。本文主要讲述三部分 NSThread、Operation 和 GCD。<br><br>本文不算是原创，是一些我觉得写的比较有质量文章的综合，文中摘抄了这些文章中的部分内容，在文中和文章末尾我已标注出处，之所以要摘抄是因为在需要之时，打开URL 是404 😂😂😂。我综合了这些文中给自己学习之用，也给大家方便查看之用，如有错误之处，见谅，不过欢迎指出。</p>
<h3 id="基本概念">基本概念</h3><p>我们先了解一线iOS多线程的一些基本概念(<a href="http://blog.leichunfeng.com/blog/2015/07/29/ios-concurrency-programming-operation-queues/#jtss-tsina" target="_blank" rel="external">这些基本概念参考了这里</a>)：</p>
<ul>
<li>进程（process）:指的是一个正在运行中的可执行文件。每一个进程都拥有独立的虚拟内存空间和系统资源，包括端口权限等，且至少包含一个主线程和任意数量的辅助线程（说白了就是：用于指代一个可执行程序，他可以包含多个线程）。另外，当一个进程的主线程退出时，这个进程就结束了；</li>
<li>线程（thread）:指的是一个独立的代码执行路径，也就是说线程是代码执行路径的最小分支。在 iOS 中，线程的底层实现是基于 <a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/Multithreading/Introduction/Introduction.html" target="_blank" rel="external">POSIX threads API</a> 的，也就是我们常说的 pthreads ；</li>
<li>任务（task），指的是我们需要执行的工作，是一个抽象的概念，用通俗的话说，就是一段代码。</li>
</ul>
<p><br></p>
<h4 id="串行_和_并发">串行 和 并发</h4><p>从本质上来说，串行和并发的主要区别在于允许同时执行的任务数量。</p>
<ul>
<li>串行：指的是一次只能执行一个任务，必须等一个任务执行完成后才能执行下一个任务；</li>
<li>并发：指的是允许多个任务在一段时间内同时执行。</li>
</ul>
<p><br></p>
<h4 id="同步_和_异步">同步 和 异步</h4><p>同步和异步操作的主要区别在于是否等待操作执行完成，亦即是否阻塞当前线程。</p>
<ul>
<li>同步操作：等待操作执行完成后再继续执行接下来的代码；</li>
<li>异步操作：它会在调用后立即返回，不会等待操作的执行结果。</li>
</ul>
<p><br></p>
<h4 id="队列_和_线程">队列 和 线程</h4><p>在 iOS 中，有两种不同类型的队列，分别是串行队列和并发队列。正如我们上面所说的，串行队列一次只能执行一个任务，而并发队列则可以允许多个任务同时执行。iOS 系统就是使用这些队列来进行任务调度的，它会根据调度任务的需要和系统当前的负载情况动态地创建和销毁线程，而不需要我们手动地管理</p>
<p><br></p>
<h4 id="iOS中的几种多线程类型">iOS中的几种多线程类型</h4><p>iOS 中其实目前有 4 种多线程，他们分别是：</p>
<ul>
<li>Pthreads：非常底层的东东；</li>
<li>NSThread：封装性最差，最偏向于底层，主要基于thread使用；</li>
<li>GCD：基于C的API，直接使用比较方便，主要基于task使用；</li>
<li>NSOperation &amp; NSOperationQueue：基于GCD封装的NSObject对象，对于复杂的多线程项目使用比较方便，主要基于队列使用。</li>
</ul>
<hr>
<p>下面开始介绍这几种类型<br><br></p>
<h3 id="Pthreads">Pthreads</h3><p>POSIX线程（POSIX threads），简称Pthreads，是线程的POSIX标准。该标准定义了创建和操纵线程的一整套API。在类Unix操作系统（Unix、Linux、Mac OS X等）中，都使用Pthreads作为操作系统的线程。<br><br>这个需要自己管理线程的生命周期，创建和销毁，写起来也是相当麻烦，若非是写一些非常底层的几乎是用不到的，这里暂时略过，如需要可自行去理解。<br><br></p>
<h3 id="NSThread">NSThread</h3><p>NSThread是苹果封装的，并且是面向对象的，这对我们来说就简便了许多，但是它的生命周期还是需要我们手动管理的；NSThread除Pthreads之外唯一一个基于线程封装的，每一个NSThread对象代表着一个线程。(<a href="http://www.jianshu.com/p/8ed06312d8bd" target="_blank" rel="external">这部分参考了这里</a>)<br><br></p>
<h4 id="线程的创建">线程的创建</h4><p>NSThread提供了2种创建线程的方法:</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="typename">void</span>)<span class="string">detachNewThreadSelector:</span>(SEL)selector <span class="string">toTarget:</span>(id)target <span class="string">withObject:</span>(nullable id)argument;</span><br><span class="line">- (instancetype)<span class="string">initWithTarget:</span>(id)target <span class="string">selector:</span>(SEL)selector <span class="string">object:</span>(nullable id)argument</span><br></pre></td></tr></table></figure>
<ul>
<li>detach方法直接创建并启动一个线程去Selector，由于没有返回值，如果需要获取新创建的Thread，需要在执行的Selector中调用-[NSThread currentThread]获取;</li>
<li>init方法初始化线程并返回，线程的入口函数由Selector传入。线程创建出来之后需要手动调用-start方法启动;<br><br><h4 id="线程操作">线程操作</h4>NSThread给线程提供的主要操作方法有启动，睡眠，取消，退出<br><br><h4 id="启动">启动</h4>使用init方法将线程创建出来之后，线程并不会立即运行，需要手动调用-start方法才会启动线程：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)<span class="function">start <span class="title">NS_AVAILABLE</span><span class="params">(<span class="number">10</span>_5, <span class="number">2</span>_0)</span></span>;</span><br></pre></td></tr></table></figure>
<p>在启动之前可以设置 线程的名称(当然启动后也可以在Selecter 中设置也可以)：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (nullable, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *name <span class="built_in">NS_AVAILABLE</span>(<span class="number">10</span>_5, <span class="number">2</span>_0);</span><br></pre></td></tr></table></figure>
<p>不过优先级 需要在 start 之前 设置，否则会无效：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@<span class="function">property NSQualityOfService qualityOfService <span class="title">NS_AVAILABLE</span><span class="params">(<span class="number">10</span>_10, <span class="number">8</span>_0)</span></span>;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h4 id="睡眠">睡眠</h4><p>NSThread提供了2个让线程睡眠的方法:</p>
<ul>
<li>根据NSDate传入睡眠时间；</li>
<li>直接传入NSTimeInterval</li>
</ul>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="tag">void</span>)<span class="rule"><span class="attribute">sleepUntilDate</span>:<span class="value">(NSDate *)date</span></span>;</span><br><span class="line">+ (<span class="tag">void</span>)<span class="rule"><span class="attribute">sleepForTimeInterval</span>:<span class="value">(NSTimeInterval)ti</span></span>;</span><br></pre></td></tr></table></figure>
<p>这里讲一下  sleepUntilDate:  和   runloop的runUntilDate: 上的一些区别：</p>
<ul>
<li>sleepUntilDate:相当于执行一个sleep的任务。在执行过程中，即使有其他任务传入runloop，runloop也不会立即响应，必须sleep任务完成之后，才会响应其他任务；</li>
<li>runUntilDate:虽然会阻塞线程，阻塞过程中并不妨碍新任务的执行。当有新任务的时候，会先执行接收到的新任务，新任务执行完之后，如果时间到了，再继续执行runUntilDate:之后的代码；</li>
</ul>
<p><br></p>
<h4 id="取消">取消</h4><p>NSThread提供了一个取消的方法和一个属性：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@property (readonly, getter=isCancelled) <span class="function">BOOL cancelled <span class="title">NS_AVAILABLE</span><span class="params">(<span class="number">10</span>_5, <span class="number">2</span>_0)</span></span>;</span><br><span class="line">- (<span class="keyword">void</span>)<span class="function">cancel <span class="title">NS_AVAILABLE</span><span class="params">(<span class="number">10</span>_5, <span class="number">2</span>_0)</span></span>;</span><br></pre></td></tr></table></figure>
<p>这里 cancel 方法要注意：调用-cancel方法并不会立刻取消线程，它仅仅是将cancelled属性设置为YES。cancelled也仅仅是一个用于记录状态的属性。线程取消的功能需要我们在main函数中自己实现；<br><br>要实现取消的功能，我们需要自己在线程的main函数中定期检查isCancelled状态来判断线程是否需要退出，当isCancelled为YES的时候，需要手动退出。<br></p>
<h4 id="退出">退出</h4><p>-exit函数可以让线程立即退出。<br><br>停止方法会立即终止除主线程以外所有线程（无论是否在执行任务）并退出，需要在掌控所有线程状态的情况下调用此方法，否则可能会导致内存问题。<br></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">void</span>)<span class="built_in">exit</span>;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h4 id="主线程和当前线程">主线程和当前线程</h4><p>NSThread提供了非常方便的获取和判断主线程的API：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@property (readonly) <span class="function">BOOL isMainThread <span class="title">NS_AVAILABLE</span><span class="params">(<span class="number">10</span>_5, <span class="number">2</span>_0)</span></span>;</span><br><span class="line">+ (BOOL)<span class="function">isMainThread <span class="title">NS_AVAILABLE</span><span class="params">(<span class="number">10</span>_5, <span class="number">2</span>_0)</span></span>; <span class="comment">// reports whether current thread is main</span></span><br><span class="line">+ (NSThread *)<span class="function">mainThread <span class="title">NS_AVAILABLE</span><span class="params">(<span class="number">10</span>_5, <span class="number">2</span>_0)</span></span>;</span><br></pre></td></tr></table></figure>
<p>获取当前线程：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">+ </span>(NSThread *)currentThread;</span><br></pre></td></tr></table></figure>
<p>是否为多线程：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ <span class="list">(<span class="keyword">BOOL</span>)</span>isMultiThreaded<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>关于isMultiThreaded 苹果在这里作了解释(相信你能看懂 😜😜😜)：</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Return</span> <span class="type">Value</span></span><br><span class="line"><span class="type">YES</span> <span class="keyword">if</span> the application <span class="keyword">is</span> multithreaded, <span class="type">NO</span> otherwise.</span><br><span class="line"></span><br><span class="line"><span class="type">Discussion</span></span><br><span class="line"><span class="type">An</span> application <span class="keyword">is</span> considered multithreaded <span class="keyword">if</span> a thread was ever detached <span class="keyword">from</span> the main thread <span class="keyword">using</span> either detachNewThreadSelector:toTarget:withObject: <span class="keyword">or</span> start. <span class="type">If</span> you detached a thread <span class="keyword">in</span> your application <span class="keyword">using</span> a non-<span class="type">Cocoa</span> <span class="type">API</span>, such <span class="keyword">as</span> the <span class="type">POSIX</span> <span class="keyword">or</span> <span class="type">Multiprocessing</span> <span class="type">Services</span> <span class="type">APIs</span>, this <span class="keyword">method</span> could still <span class="keyword">return</span> <span class="type">NO</span>. <span class="type">The</span> detached thread does <span class="keyword">not</span> have to be currently running <span class="keyword">for</span> the application to be considered multithreaded—this <span class="keyword">method</span> only indicates whether a single thread has been spawned.</span><br></pre></td></tr></table></figure>
<p><br></p>
<h4 id="线程优先级">线程优先级</h4><p>NSThread有4个优先级的API：</p>
<p>这两个用于设置和获取当前线程的优先级：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="tag">double</span>)<span class="tag">threadPriority</span>;</span><br><span class="line">+ (<span class="tag">BOOL</span>)<span class="rule"><span class="attribute">setThreadPriority</span>:<span class="value">(double)p</span></span>;</span><br></pre></td></tr></table></figure>
<p>后两个通过对象设置和获取优先级：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@<span class="function">property <span class="keyword">double</span> threadPriority <span class="title">NS_AVAILABLE</span><span class="params">(<span class="number">10</span>_6, <span class="number">4</span>_0)</span></span>; <span class="comment">// To be deprecated; use qualityOfService below</span></span><br><span class="line">@<span class="function">property NSQualityOfService qualityOfService <span class="title">NS_AVAILABLE</span><span class="params">(<span class="number">10</span>_10, <span class="number">8</span>_0)</span></span>; <span class="comment">// read-only after the thread is started</span></span><br></pre></td></tr></table></figure>
<p>在iOS 8 之前：</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">[NSThread setThreadPriority:1.0]</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>这个方法的优先级的数值设置让人困惑，因为你不知道你应该设置多大的值是比较合适的，因此在iOS8之后，threadPriority添加了一句注释：To be deprecated; use qualityOfService below <br><br>意为iOS 8以后推荐使用qualityOfService属性：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSInteger</span>, <span class="built_in">NSQualityOfService</span>) &#123;</span><br><span class="line">    <span class="built_in">NSQualityOfServiceUserInteractive</span> = <span class="number">0x21</span>, 最高优先级，用于用户交互事件</span><br><span class="line">    <span class="built_in">NSQualityOfServiceUserInitiated</span> = <span class="number">0x19</span>,   次高优先级，用于用户需要马上执行的事件</span><br><span class="line">    <span class="built_in">NSQualityOfServiceUtility</span> = <span class="number">0x11</span>,         普通优先级，用于普通任务       </span><br><span class="line">    <span class="built_in">NSQualityOfServiceBackground</span> = <span class="number">0x09</span>,      最低优先级，用于不重要的任务</span><br><span class="line">    <span class="built_in">NSQualityOfServiceDefault</span> = -<span class="number">1</span>            默认优先级，主线程和没有设置优先级的线程都默认为这个优先级</span><br><span class="line">&#125; <span class="built_in">NS_ENUM_AVAILABLE</span>(<span class="number">10</span>_10, <span class="number">8</span>_0);</span><br></pre></td></tr></table></figure>
<p>比如给线程设置次高优先级：</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">[newThread setQualityOfService:NSQualityOfServiceUserInitiated]</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p><br></p>
<h4 id="线程通讯">线程通讯</h4><p>创建线程之后，经常需要从主线程把耗时的任务丢给辅助线程，当任务完成之后辅助线程再把结果传回主线程传，这些线程通讯一般用的都是perform方法：</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)performSelectorOnMainThread:(<span class="type">SEL</span>)aSelector withObject:(nullable id)arg waitUntilDone:(<span class="type">BOOL</span>)wait modes:(nullable <span class="type">NSArray</span>&lt;<span class="type">NSString</span> *&gt; *)<span class="type">array</span>;</span><br><span class="line">- (<span class="type">void</span>)performSelectorOnMainThread:(<span class="type">SEL</span>)aSelector withObject:(nullable id)arg waitUntilDone:(<span class="type">BOOL</span>)wait;</span><br><span class="line">	// equivalent to the first <span class="keyword">method</span> <span class="keyword">with</span> kCFRunLoopCommonModes</span><br><span class="line">- (<span class="type">void</span>)performSelector:(<span class="type">SEL</span>)aSelector onThread:(<span class="type">NSThread</span> *)thr withObject:(nullable id)arg waitUntilDone:(<span class="type">BOOL</span>)wait modes:(nullable <span class="type">NSArray</span>&lt;<span class="type">NSString</span> *&gt; *)<span class="type">array</span> <span class="type">NS_AVAILABLE</span>(<span class="number">10_5</span>, <span class="number">2_0</span>);</span><br><span class="line">- (<span class="type">void</span>)performSelector:(<span class="type">SEL</span>)aSelector onThread:(<span class="type">NSThread</span> *)thr withObject:(nullable id)arg waitUntilDone:(<span class="type">BOOL</span>)wait <span class="type">NS_AVAILABLE</span>(<span class="number">10_5</span>, <span class="number">2_0</span>);</span><br><span class="line">	// equivalent to the first <span class="keyword">method</span> <span class="keyword">with</span> kCFRunLoopCommonModes</span><br></pre></td></tr></table></figure>
<p>①：将selector丢给主线程执行，可以指定runloop mode<br><br>②：将selector丢给主线程执行，runloop mode默认为common mode<br><br>③：将selector丢个指定线程执行，可以指定runloop mode<br><br>④：将selector丢个指定线程执行，runloop mode默认为default mode<br><br>一般用③④方法将任务丢给辅助线程，任务执行完成之后再使用①②方法将结果传回主线程<br><br>注意：perform方法只对拥有runloop的线程有效，如果创建的线程没有添加runloop，perform的selector将无法执行。<br><br><br></p>
<h4 id="线程通知">线程通知</h4><p>NSThread有三个线程相关的通知:</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FOUNDATION_EXPORT <span class="built_in">NSString</span> * <span class="keyword">const</span> <span class="built_in">NSWillBecomeMultiThreadedNotification</span>;</span><br><span class="line">FOUNDATION_EXPORT <span class="built_in">NSString</span> * <span class="keyword">const</span> <span class="built_in">NSDidBecomeSingleThreadedNotification</span>;</span><br><span class="line">FOUNDATION_EXPORT <span class="built_in">NSString</span> * <span class="keyword">const</span> <span class="built_in">NSThreadWillExitNotification</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>NSWillBecomeMultiThreadedNotification：由当前线程派生出第一个其他线程时发送；</li>
<li>NSDidBecomeSingleThreadedNotification：暂时不知道；</li>
<li>NSThreadWillExitNotification：线程退出时发送；</li>
</ul>
<p><br></p>
<h4 id="NSThread的简单使用">NSThread的简单使用</h4><p>NSThread 创建还是很简单的：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSThread</span> *thread = [[<span class="built_in">NSThread</span> alloc] initWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(threadAction) object:<span class="literal">nil</span>];</span><br><span class="line">thread<span class="variable">.name</span> = <span class="string">@"com.myCreate.www"</span>;</span><br><span class="line">[thread start];</span><br></pre></td></tr></table></figure>
<p>在线程启动之后会首先执行-threadAction，正常情况下threadAction方法执行结束之后，线程就会退出。为了线程可以长期复用接收消息，我们需要给线程加上runLoop</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)threadAction</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"当前线程：%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    <span class="built_in">NSRunLoop</span> *runLoop = [<span class="built_in">NSRunLoop</span> currentRunLoop];</span><br><span class="line">    [runLoop addPort:[<span class="built_in">NSMachPort</span> port] forMode:<span class="built_in">NSDefaultRunLoopMode</span>];</span><br><span class="line">    <span class="keyword">while</span> (![[<span class="built_in">NSThread</span> currentThread] isCancelled]) &#123;</span><br><span class="line">        [runLoop runMode:<span class="built_in">NSDefaultRunLoopMode</span> beforeDate:[<span class="built_in">NSDate</span> dateWithTimeIntervalSinceNow:<span class="number">10</span>]];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>自定义的线程默认是没有runloop的，调用-currentRunLoop，方法内部会为线程创建runloop；</li>
<li>如果没有数据源，runloop会在启动之后会立刻退出。所以需要给runloop添加一个数据源，这里添加的是NSPort数据源；</li>
<li>定期检查isCancelled，当外部调用-cancel方法将isCancelled置为YES的时候，线程可以退出；</li>
</ul>
<p><br></p>
<h4 id="结束线程">结束线程</h4><p>当我们想要结束线程的时候，我们可以使用CFRunLoopStop()配合-cancel来结束线程：</p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">[<span class="list">[<span class="keyword">NSThread</span> currentThread] cancel]<span class="comment">;</span></span><br><span class="line">CFRunLoopStop<span class="list">(<span class="keyword">CFRunLoopGetCurrent</span><span class="list">()</span>)</span><span class="comment">;</span></span></span></span><br></pre></td></tr></table></figure>
<p><br></p>
<h4 id="NSThread的一个小例子">NSThread的一个小例子</h4><p>这个例子很好的说明了NSThread使用时要注意些什么。<br><br>这个例子是：模拟售票<a href="http://www.jianshu.com/p/334bde6790be#" target="_blank" rel="external">这个例子来自这</a><br><br>情景：某演唱会门票发售，在广州和北京均开设窗口进行销售<br><br>下面是主要代码：新建两个线程<br></p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"***************售票开始****************"</span>);</span><br><span class="line"><span class="built_in">NSThread</span> *saleTicketsWindow_1 = [[<span class="built_in">NSThread</span> alloc] initWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(saleTicketsWindow_Action) object:<span class="literal">nil</span>];</span><br><span class="line">saleTicketsWindow_1<span class="variable">.name</span> = <span class="string">@"北京售票中心"</span>;</span><br><span class="line">[saleTicketsWindow_1 start];</span><br><span class="line">   </span><br><span class="line"><span class="built_in">NSThread</span> *saleTicketsWindow_2 = [[<span class="built_in">NSThread</span> alloc] initWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(saleTicketsWindow_Action) object:<span class="literal">nil</span>];</span><br><span class="line">saleTicketsWindow_2<span class="variable">.name</span> = <span class="string">@"广州售票中心"</span>;</span><br><span class="line">[saleTicketsWindow_2 start];</span><br></pre></td></tr></table></figure>
<p>开始执行售票<br></p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)saleTicketsWindow_Action</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (_ticketCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            _ticketCount --;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"剩余票数：%ld 窗口：%@"</span>, _ticketCount, [<span class="built_in">NSThread</span> currentThread]<span class="variable">.name</span>]);</span><br><span class="line">            [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">0.2</span>];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"***************售票完成****************"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">10</span> <span class="number">17</span>:<span class="number">54</span>:<span class="number">22.636</span> NSThreadTest[<span class="number">2323</span>:<span class="number">1382484</span>] 剩余票数：<span class="number">9</span> 窗口：广州售票中心</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">10</span> <span class="number">17</span>:<span class="number">54</span>:<span class="number">22.636</span> NSThreadTest[<span class="number">2323</span>:<span class="number">1382483</span>] 剩余票数：<span class="number">10</span> 窗口：北京售票中心</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">10</span> <span class="number">17</span>:<span class="number">54</span>:<span class="number">22.841</span> NSThreadTest[<span class="number">2323</span>:<span class="number">1382483</span>] 剩余票数：<span class="number">7</span> 窗口：北京售票中心</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">10</span> <span class="number">17</span>:<span class="number">54</span>:<span class="number">22.841</span> NSThreadTest[<span class="number">2323</span>:<span class="number">1382484</span>] 剩余票数：<span class="number">8</span> 窗口：广州售票中心</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">10</span> <span class="number">17</span>:<span class="number">54</span>:<span class="number">23.043</span> NSThreadTest[<span class="number">2323</span>:<span class="number">1382484</span>] 剩余票数：<span class="number">5</span> 窗口：广州售票中心</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">10</span> <span class="number">17</span>:<span class="number">54</span>:<span class="number">23.043</span> NSThreadTest[<span class="number">2323</span>:<span class="number">1382483</span>] 剩余票数：<span class="number">6</span> 窗口：北京售票中心</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">10</span> <span class="number">17</span>:<span class="number">54</span>:<span class="number">23.244</span> NSThreadTest[<span class="number">2323</span>:<span class="number">1382484</span>] 剩余票数：<span class="number">4</span> 窗口：广州售票中心</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">10</span> <span class="number">17</span>:<span class="number">54</span>:<span class="number">23.244</span> NSThreadTest[<span class="number">2323</span>:<span class="number">1382483</span>] 剩余票数：<span class="number">3</span> 窗口：北京售票中心</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">10</span> <span class="number">17</span>:<span class="number">54</span>:<span class="number">23.449</span> NSThreadTest[<span class="number">2323</span>:<span class="number">1382483</span>] 剩余票数：<span class="number">1</span> 窗口：北京售票中心</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">10</span> <span class="number">17</span>:<span class="number">54</span>:<span class="number">23.449</span> NSThreadTest[<span class="number">2323</span>:<span class="number">1382484</span>] 剩余票数：<span class="number">2</span> 窗口：广州售票中心</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">10</span> <span class="number">17</span>:<span class="number">54</span>:<span class="number">23.655</span> NSThreadTest[<span class="number">2323</span>:<span class="number">1382483</span>] 剩余票数：<span class="number">0</span> 窗口：北京售票中心</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">10</span> <span class="number">17</span>:<span class="number">54</span>:<span class="number">23.655</span> NSThreadTest[<span class="number">2323</span>:<span class="number">1382484</span>] ***************售票完成****************</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">10</span> <span class="number">17</span>:<span class="number">54</span>:<span class="number">23.656</span> NSThreadTest[<span class="number">2323</span>:<span class="number">1382484</span>] 线程退出了：广州售票中心</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">10</span> <span class="number">17</span>:<span class="number">54</span>:<span class="number">23.861</span> NSThreadTest[<span class="number">2323</span>:<span class="number">1382483</span>] ***************售票完成****************</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">10</span> <span class="number">17</span>:<span class="number">54</span>:<span class="number">23.861</span> NSThreadTest[<span class="number">2323</span>:<span class="number">1382483</span>] 线程退出了：北京售票中心</span><br></pre></td></tr></table></figure>
<p>可以看到，票的销售过程中出现了剩余数量错乱的情况，这就是线程同步问题。<br><br>售票是一个典型的需要线程同步的场景，由于售票渠道有很多，而票的资源是有限的，当多个渠道在短时间内卖出大量的票的时候，如果没有同步机制来管理票的数量，将会导致票的总数和售出票数对应不上的错误。<br></p>
<p>iOS实现线程加锁有几种方式，现在使用NSLock或@synchronized两种方式都可行<br></p>
<p>使用NSLock:<br></p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    [_lock lock];</span><br><span class="line">    <span class="keyword">if</span> (_ticketCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        _ticketCount --;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"剩余票数：%ld 窗口：%@"</span>, _ticketCount, [<span class="built_in">NSThread</span> currentThread]<span class="variable">.name</span>]);</span><br><span class="line">        [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">0.2</span>];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"***************售票完成****************"</span>);</span><br><span class="line">        [_lock unlock];</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    [_lock unlock];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用@synchronized:<br></p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">@synchronized</span>(<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (_ticketCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            _ticketCount --;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"剩余票数：%ld 窗口：%@"</span>, _ticketCount, [<span class="built_in">NSThread</span> currentThread]<span class="variable">.name</span>]);</span><br><span class="line">            [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">0.2</span>];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"***************售票完成****************"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="NSOperation">NSOperation</h3><p>NSOperation 只是一个抽象类，所以不能封装任务，因此，如果我们想要使用它来执行具体任务的话，就必须创建自己的子类或使用它的 2 个子类。分别是：NSInvocationOperation 和 NSBlockOperation 。创建一个 Operation 后，需要调用 start 方法来启动任务，它会 默认在当前队列同步执行。当然你也可以在中途取消一个任务，只需要调用其 cancel 方法即可。</p>
<h4 id="NSInvocationOperation">NSInvocationOperation</h4><p>下面是NSInvocationOperation的简单使用，可以看到 NSInvocationOperation 开始任务之后是在主线程执行任务的。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.创建对象</span></span><br><span class="line"><span class="built_in">NSInvocationOperation</span> *operation = [[<span class="built_in">NSInvocationOperation</span> alloc] initWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(invocationAction) object:<span class="literal">nil</span>];</span><br><span class="line"><span class="comment">//2.开始执行</span></span><br><span class="line">[operation start];</span><br><span class="line"><span class="comment">//3.结果</span></span><br><span class="line"><span class="comment">/*</span><br><span class="line"> 2016-05-06 05:53:43.219 NSOperationTest[5885:2491863] NSInvocationOperation --- &lt;NSThread: 0x7fa269c06dc0&gt;&#123;number = 1, name = main&#125;</span><br><span class="line"> 是在主线程</span><br><span class="line"> */</span></span><br></pre></td></tr></table></figure>
<h4 id="NSBlockOperation">NSBlockOperation</h4><p>NSBlockOperation 默认会在当前线程执行任务。但是 NSBlockOperation 还有一个方法：addExecutionBlock: ，通过这个方法可以给 Operation 添加多个执行 Block。这样 Operation 中的任务 会并发执行，它会 在主线程和其它的多个线程执行这些任务.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">NSBlockOperation *blockOperation = [NSBlockOperation blockOperationWithBlock:^&#123;</span><br><span class="line">    NSLog(@<span class="string">"NSBlockOperation --- %@"</span>, [NSThread currentThread]);</span><br><span class="line">&#125;];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    [blockOperation addExecutionBlock:^&#123;</span><br><span class="line">        NSLog(@<span class="string">"NSBlockOperation 第%d次：%@"</span>, i, [NSThread currentThread]);</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br><span class="line">[blockOperation start];</span><br><span class="line"></span><br><span class="line"> <span class="number">2016</span>-<span class="number">05</span>-<span class="number">06</span> <span class="number">05</span>:<span class="number">57</span>:<span class="number">46.227</span> NSBlockOperationTest[<span class="number">5921</span>:<span class="number">2510961</span>] NSBlockOperation --- &lt;NSThread: <span class="number">0x7fc4c0401af0</span>&gt;&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line"> </span><br><span class="line"> <span class="number">2016</span>-<span class="number">05</span>-<span class="number">06</span> <span class="number">06</span>:<span class="number">01</span>:<span class="number">25.939</span> NSBlockOperationTest[<span class="number">5939</span>:<span class="number">2525676</span>] NSBlockOperation 第<span class="number">2</span>次：&lt;NSThread: <span class="number">0x7fb6cbe04590</span>&gt;&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line"> <span class="number">2016</span>-<span class="number">05</span>-<span class="number">06</span> <span class="number">06</span>:<span class="number">01</span>:<span class="number">25.940</span> NSBlockOperationTest[<span class="number">5939</span>:<span class="number">2525676</span>] NSBlockOperation 第<span class="number">3</span>次：&lt;NSThread: <span class="number">0x7fb6cbe04590</span>&gt;&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line"> <span class="number">2016</span>-<span class="number">05</span>-<span class="number">06</span> <span class="number">06</span>:<span class="number">01</span>:<span class="number">25.940</span> NSBlockOperationTest[<span class="number">5939</span>:<span class="number">2525676</span>] NSBlockOperation 第<span class="number">4</span>次：&lt;NSThread: <span class="number">0x7fb6cbe04590</span>&gt;&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line"> <span class="number">2016</span>-<span class="number">05</span>-<span class="number">06</span> <span class="number">06</span>:<span class="number">01</span>:<span class="number">25.940</span> NSBlockOperationTest[<span class="number">5939</span>:<span class="number">2525717</span>] NSBlockOperation 第<span class="number">0</span>次：&lt;NSThread: <span class="number">0x7fb6cbf03040</span>&gt;&#123;number = <span class="number">2</span>, name = (null)&#125;</span><br><span class="line"> <span class="number">2016</span>-<span class="number">05</span>-<span class="number">06</span> <span class="number">06</span>:<span class="number">01</span>:<span class="number">25.940</span> NSBlockOperationTest[<span class="number">5939</span>:<span class="number">2525710</span>] NSBlockOperation 第<span class="number">1</span>次：&lt;NSThread: <span class="number">0x7fb6cbc3f6e0</span>&gt;&#123;number = <span class="number">3</span>, name = (null)&#125;</span><br></pre></td></tr></table></figure>
<p>注意：addExecutionBlock 方法必须在 start() 方法之前执行，否则就会报错：</p>
<figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Terminating app due <span class="keyword">to</span> uncaught exception <span class="attribute">'NSInvalidArgumentException</span>', reason: '*** -[NSBlockOperation addExecutionBlock:]: blocks cannot be added <span class="keyword">after</span> the operation has started executing <span class="keyword">or</span> finished'</span><br></pre></td></tr></table></figure>
<h4 id="NSOperationQueue">NSOperationQueue</h4><p>在 NSOperationQueue 中，任务不会在当前线程执行。当任务添加到队列，会自动调用任务的 start() 方法，所有任务是并行执行的。maxConcurrentOperationCount 可以设置最大任务并行数量，当设置为 1 时，在某种意义上就是串行了。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">    <span class="built_in">NSOperationQueue</span> *queue = [[<span class="built_in">NSOperationQueue</span> alloc] init];</span><br><span class="line">    <span class="built_in">NSBlockOperation</span> *blockOperation = [<span class="built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"NSBlockOperation --- %@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    &#125;];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        [blockOperation addExecutionBlock:^&#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"NSBlockOperation 第%d次：%@"</span>, i, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;</span><br><span class="line">    [queue addOperation:blockOperation];</span><br><span class="line">或者是：</span><br><span class="line">       [queue addOperationWithBlock:^&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"addOperationWithBlock 第%d次：%@"</span>, i, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">        &#125;</span><br><span class="line">        [[<span class="built_in">NSOperationQueue</span> mainQueue] addOperationWithBlock:^&#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"addOperationWithBlock %@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;];</span><br></pre></td></tr></table></figure>
<p>eg:NSOperation 有一个非常实用的功能，那就是添加依赖。比如有 3 个任务：A: 从服务器上下载一张图片，B：给这张图片加个水印，C：把图片返回给服务器。这时就可以用到依赖了:</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSBlockOperation</span> *operation1 = [<span class="built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class="line">       <span class="built_in">NSLog</span>(<span class="string">@"下载图片 --- %@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">   &#125;];</span><br><span class="line">   <span class="built_in">NSBlockOperation</span> *operation2 = [<span class="built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class="line">       <span class="built_in">NSLog</span>(<span class="string">@"打水印 --- %@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">   &#125;];</span><br><span class="line">   <span class="built_in">NSBlockOperation</span> *operation3 = [<span class="built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class="line">       <span class="built_in">NSLog</span>(<span class="string">@"上传图片 --- %@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">   &#125;];</span><br><span class="line">   [operation2 addDependency:operation1];</span><br><span class="line">   [operation3 addDependency:operation2];</span><br><span class="line">   <span class="built_in">NSOperationQueue</span> *operationQueue = [[<span class="built_in">NSOperationQueue</span> alloc] init];</span><br><span class="line">   [operationQueue addOperations:@[operation1,operation2,operation3] waitUntilFinished:<span class="literal">NO</span>];</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2016</span>-<span class="number">05</span>-<span class="number">06</span> <span class="number">06</span>:<span class="number">26</span>:<span class="number">12.732</span> NSOperationQueueTest[<span class="number">6061</span>:<span class="number">2650250</span>] 下载图片 --- &lt;NSThread: <span class="number">0x7fc589e1d740</span>&gt;&#123;number = <span class="number">3</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">05</span>-<span class="number">06</span> <span class="number">06</span>:<span class="number">26</span>:<span class="number">12.733</span> NSOperationQueueTest[<span class="number">6061</span>:<span class="number">2650257</span>] 打水印 --- &lt;NSThread: <span class="number">0x7fc589f01320</span>&gt;&#123;number = <span class="number">4</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">05</span>-<span class="number">06</span> <span class="number">06</span>:<span class="number">26</span>:<span class="number">12.734</span> NSOperationQueueTest[<span class="number">6061</span>:<span class="number">2650257</span>] 上传图片 --- &lt;NSThread: <span class="number">0x7fc589f01320</span>&gt;&#123;number = <span class="number">4</span>, name = (null)&#125;</span><br></pre></td></tr></table></figure>
<p>注意：不能添加相互依赖，会死锁，比如 A依赖B，B依赖A。<br><br>     可以使用 removeDependency 来解除依赖关系。<br><br>     可以在不同的队列之间依赖，反正就是这个依赖是添加到任务身上的，和队列没关系。<br></p>
<p>另外还有以下方法：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSOperation</span></span><br><span class="line"><span class="built_in">BOOL</span> executing; <span class="comment">//判断任务是否正在执行</span></span><br><span class="line"><span class="built_in">BOOL</span> finished; <span class="comment">//判断任务是否完成</span></span><br><span class="line"><span class="keyword">void</span> (^completionBlock)(<span class="keyword">void</span>); <span class="comment">//用来设置完成后需要执行的操作</span></span><br><span class="line">- (<span class="keyword">void</span>)cancel; <span class="comment">//取消任务</span></span><br><span class="line">- (<span class="keyword">void</span>)waitUntilFinished; <span class="comment">//阻塞当前线程直到此任务执行完毕</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">NSOperationQueue</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">NSUInteger</span> operationCount; <span class="comment">//获取队列的任务数</span></span><br><span class="line">- (<span class="keyword">void</span>)cancelAllOperations; <span class="comment">//取消队列中所有的任务</span></span><br><span class="line">- (<span class="keyword">void</span>)waitUntilAllOperationsAreFinished; <span class="comment">//阻塞当前线程直到此队列中的所有任务执行完毕</span></span><br><span class="line">[queue setSuspended:<span class="literal">YES</span>]; <span class="comment">// 暂停queue</span></span><br><span class="line">[queue setSuspended:<span class="literal">NO</span>]; <span class="comment">// 继续queue</span></span><br></pre></td></tr></table></figure>
<p>关于NSOperationQueue中 ：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@property (nullable, assign <span class="comment">/* actually retain */</span>) <span class="keyword">dispatch_queue_t</span> <span class="function">underlyingQueue <span class="title">NS_AVAILABLE</span><span class="params">(<span class="number">10</span>_10, <span class="number">8</span>_0)</span></span>;</span><br></pre></td></tr></table></figure>
<p><a href="http://stackoverflow.com/questions/16563410/get-underlying-dispatch-queue-t-from-nsoperationqueue" target="_blank" rel="external">在这里有介绍其用法</a><br><br><a href="http://stackoverflow.com/questions/31062196/can-nsoperation-have-a-lower-qualityofservice-than-nsoperationqueue/31076475#31076475" target="_blank" rel="external">这里也有解释</a><br><br>这里是苹果的解释：</p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Discussion</span><br><span class="line">The default <span class="built_in">value</span> <span class="operator">of</span> this property is nil. You can <span class="built_in">set</span> <span class="operator">the</span> <span class="built_in">value</span> <span class="operator">of</span> this property <span class="built_in">to</span> <span class="operator">an</span> existing <span class="built_in">dispatch</span> queue <span class="built_in">to</span> have enqueued operations interspersed <span class="operator">with</span> blocks submitted <span class="built_in">to</span> that <span class="built_in">dispatch</span> queue.</span><br><span class="line"></span><br><span class="line">The <span class="built_in">value</span> <span class="operator">of</span> this property should only be <span class="built_in">set</span> <span class="keyword">if</span> there are no operations <span class="operator">in</span> <span class="operator">the</span> queue; setting <span class="operator">the</span> <span class="built_in">value</span> <span class="operator">of</span> this property when operationCount is <span class="operator">not</span> equal <span class="built_in">to</span> <span class="number">0</span> raises <span class="operator">an</span> invalidArgumentException. The <span class="built_in">value</span> <span class="operator">of</span> this property must <span class="operator">not</span> be <span class="operator">the</span> <span class="built_in">value</span> returned <span class="keyword">by</span> dispatch_get_main_queue(). The quality-<span class="operator">of</span>-service level <span class="built_in">set</span> <span class="keyword">for</span> <span class="operator">the</span> underlying <span class="built_in">dispatch</span> queue overrides <span class="keyword">any</span> <span class="built_in">value</span> <span class="built_in">set</span> <span class="keyword">for</span> <span class="operator">the</span> operation queue<span class="string">'s qualityOfService property.</span></span><br></pre></td></tr></table></figure>
<h4 id="自定义Operation">自定义Operation</h4><p>后面会有专门有一节介绍</p>
<hr>
<h3 id="GCD">GCD</h3><p>Grand Central Dispatch 是苹果为多核的并行运算提出的解决方案，所以会自动合理地利用更多的CPU内核（比如双核、四核），最重要的是它会自动管理线程的生命周期（创建线程、调度任务、销毁线程），完全不需要我们管理，我们只需要告诉干什么就行。</p>
<p>在 GCD 中，加入了两个非常重要的概念： 任务 和 队列。 任务即你要执行的，同步、异步和队列 前面已经讲解过。<br></p>
<pre><code>放到串行队列的任务，<span class="keyword">GCD</span> 会 FIFO（先进先出） 地取出来一个，执行一个，然后取下一个，这样一个一个的执行。&lt;br/&gt;

放到并行队列的任务，<span class="keyword">GCD</span> 也会 FIFO的取出来，但不同的是，它取出来一个就会放到别的线程，然后再取出来一个又放到另一个的线程。这样由于取的动作很快，忽略不计，看起来，所有的任务都是一起执行的。不过需要注意，<span class="keyword">GCD</span> 会根据系统资源控制并行的数量，所以如果任务很多，它并不会让所有任务同时执行。&lt;br/&gt;
</code></pre><h4 id="创建队列">创建队列</h4><p>先讲概念：</p>
<p>GCD中的FIFO队列称为dispatch queue，用来保证先进来的任务先得到执行。</p>
<p> dispatch queue分三种</p>
<ul>
<li>Serial：又叫private dispatch queues，同时只执行一个任务。Serial queue常用于同步访问特定的资源或数据。当你创建多个Serial queue时，虽然各自是同步，但serial queue之间是并发执行。(DISPATCH_QUEUE_SERIAL)</li>
<li>Concurrent：又叫global dispatch queue，可以并发的执行多个任务，但执行完成顺序是随机的。(DISPATCH_QUEUE_CONCURRENT)</li>
<li>Main dispatch queue：全局可用的serial queue，在应用程序主线程上执行任务。</li>
</ul>
<p>公开的5个不同队列：<br> 运行在主线程中的main queue，<br> 3个不同优先级的后台队列（High Priority Queue，Default Priority Queue，Low Priority Queue），<br> 以及一个优先级更低的后台队列Background Priority Queue（用于I/O）</p>
<p> 5种队列，主队列（main queue）,四种通用调度队列，自己定制的队列。四种通用调度队列为</p>
<ul>
<li>QOS_CLASS_USER_INTERACTIVE：user interactive等级表示任务需要被立即执行提供好的体验，用来更新UI，响应事件等。这个等级最好保持小规模。</li>
<li>QOS_CLASS_USER_INITIATED：  user initiated等级表示任务由UI发起异步执行。适用场景是需要及时结果同时又可以继续交互的时候。</li>
<li>QOS_CLASS_UTILITY：         utility等级表示需要长时间运行的任务，伴有用户可见进度指示器。经常会用来做计算，I/O，网络，持续的数据填充等任务。这个任务节能。</li>
<li>QOS_CLASS_BACKGROUND：      background等级表示用户不会察觉的任务，使用它来处理预加载，或者不需要用户交互和对时间不敏感的任务。</li>
</ul>
<h5 id="主队列">主队列</h5><p>这是一个特殊的 串行队列,它用于刷新 UI，任何需要刷新 UI 的工作都要在主队列执行.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dispatch_queue_t</span> <span class="built_in">queue</span> = dispatch_get_main_queue();</span><br></pre></td></tr></table></figure>
<h5 id="自定义的队列">自定义的队列</h5><p>其中第一个参数是标识符，用于 DEBUG 的时候标识唯一的队列，可以为空.</p>
<p>第二个参数用来表示创建的队列是串行的还是并行的，传入 DISPATCH_QUEUE_SERIAL 或 NULL 表示创建串行队列。传入 DISPATCH_QUEUE_CONCURRENT 表示创建并行队列。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dispatch_queue_t</span></span><br><span class="line">dispatch_queue_create(<span class="keyword">const</span> <span class="keyword">char</span> *_Nullable label,</span><br><span class="line">		<span class="keyword">dispatch_queue_attr_t</span> _Nullable attr);</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 串行队列</span></span><br><span class="line"><span class="keyword">dispatch_queue_t</span> createQueue = dispatch_queue_create(<span class="string">"com.testQueue"</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">dispatch_queue_t</span> createQueue = dispatch_queue_create(<span class="string">"com.testQueue"</span>, DISPATCH_QUEUE_SERIAL);</span><br><span class="line"><span class="comment">// 并行队列</span></span><br><span class="line"><span class="keyword">dispatch_queue_t</span> createQueue = dispatch_queue_create(<span class="string">"com.testQueue"</span>, DISPATCH_QUEUE_CONCURRENT);</span><br></pre></td></tr></table></figure>
<p>系统还提供了 全局并行队列</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dispatch_queue_t</span> createQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p>全局队列有这几种优先级：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hexcolor">#def</span>ine DISPATCH_QUEUE_PRIORITY_HIGH <span class="number">2</span></span><br><span class="line"><span class="hexcolor">#def</span>ine DISPATCH_QUEUE_PRIORITY_DEFAULT <span class="number">0</span></span><br><span class="line"><span class="hexcolor">#def</span>ine DISPATCH_QUEUE_PRIORITY_LOW (-<span class="number">2</span>)</span><br><span class="line"><span class="hexcolor">#def</span>ine DISPATCH_QUEUE_PRIORITY_BACKGROUND INT16_MIN</span><br></pre></td></tr></table></figure>
<h5 id="创建任务">创建任务</h5><p>同步任务：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_sync</span>(queue, ^&#123;</span><br><span class="line">    </span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">"com.testQueue"</span>, DISPATCH_QUEUE_SERIAL);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"async之前 - %@"</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line"><span class="built_in">dispatch_sync</span>(queue, ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"async1 - %@"</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">dispatch_sync</span>(queue, ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"async2 - %@"</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">dispatch_sync</span>(queue, ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"async3 - %@"</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"async之后 - %@"</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br></pre></td></tr></table></figure>
<p>log:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2016</span>-<span class="number">05</span>-<span class="number">05</span> <span class="number">07</span>:<span class="number">03</span>:<span class="number">01.137</span> syncTest[<span class="number">5181</span>:<span class="number">1954382</span>] async之前 - &lt;NSThread: <span class="number">0x7fd7e9400ec0</span>&gt;&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">05</span>-<span class="number">05</span> <span class="number">07</span>:<span class="number">03</span>:<span class="number">01.138</span> syncTest[<span class="number">5181</span>:<span class="number">1954382</span>] async1 - &lt;NSThread: <span class="number">0x7fd7e9400ec0</span>&gt;&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">05</span>-<span class="number">05</span> <span class="number">07</span>:<span class="number">03</span>:<span class="number">01.138</span> syncTest[<span class="number">5181</span>:<span class="number">1954382</span>] async2 - &lt;NSThread: <span class="number">0x7fd7e9400ec0</span>&gt;&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">05</span>-<span class="number">05</span> <span class="number">07</span>:<span class="number">03</span>:<span class="number">01.138</span> syncTest[<span class="number">5181</span>:<span class="number">1954382</span>] async3 - &lt;NSThread: <span class="number">0x7fd7e9400ec0</span>&gt;&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">05</span>-<span class="number">05</span> <span class="number">07</span>:<span class="number">03</span>:<span class="number">01.138</span> syncTest[<span class="number">5181</span>:<span class="number">1954382</span>] async之后 - &lt;NSThread: <span class="number">0x7fd7e9400ec0</span>&gt;&#123;number = <span class="number">1</span>, name = main&#125;</span><br></pre></td></tr></table></figure>
<p>注意：</p>
<p>1.同步队列无论设置是DISPATCH_QUEUE_SERIAL还是DISPATCH_QUEUE_CONCURRENT，任务都是在主线程执行,会阻塞主线程</p>
<p>2.dispatch_sync 中 queue 不能是 dispatch_get_main_queue() 即为主线程队列，否则会creash</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NSLog</span>(<span class="at_rule">@<span class="string">"dispatch_sync  enter"</span>);</span></span><br><span class="line"><span class="function">dispatch_sync</span>(<span class="function">dispatch_get_main_queue</span>(), ^&#123;</span><br><span class="line">    <span class="function">NSLog</span>(<span class="at_rule">@<span class="string">"dispatch_sync action"</span>);</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="function">NSLog</span>(<span class="at_rule">@<span class="string">"dispatch_sync leave"</span>);</span></span><br></pre></td></tr></table></figure>
<p>异步任务：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_async</span>(createQueue, ^&#123;</span><br><span class="line">    </span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//并行队列 DISPATCH_QUEUE_CONCURRENT</span></span><br><span class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">"com.testQueue"</span>, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"async之前 - %@"</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line"><span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"async1 - %@"</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"async2 - %@"</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"async3 - %@"</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"async之后 - %@"</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br></pre></td></tr></table></figure>
<p>log:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">21</span> <span class="number">07</span>:<span class="number">19</span>:<span class="number">53.817</span> asyncTest[<span class="number">13930</span>:<span class="number">8566716</span>] async之前 - &lt;NSThread: <span class="number">0x600000066a40</span>&gt;&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">21</span> <span class="number">07</span>:<span class="number">19</span>:<span class="number">53.818</span> asyncTest[<span class="number">13930</span>:<span class="number">8566716</span>] async之后 - &lt;NSThread: <span class="number">0x600000066a40</span>&gt;&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">21</span> <span class="number">07</span>:<span class="number">20</span>:<span class="number">59.683</span> asyncTest[<span class="number">13930</span>:<span class="number">8566864</span>] async2 - &lt;NSThread: <span class="number">0x60800007d700</span>&gt;&#123;number = <span class="number">4</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">21</span> <span class="number">07</span>:<span class="number">20</span>:<span class="number">59.683</span> asyncTest[<span class="number">13930</span>:<span class="number">8566862</span>] async3 - &lt;NSThread: <span class="number">0x60000007a9c0</span>&gt;&#123;number = <span class="number">3</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">21</span> <span class="number">07</span>:<span class="number">20</span>:<span class="number">59.683</span> asyncTest[<span class="number">13930</span>:<span class="number">8566867</span>] async1 - &lt;NSThread: <span class="number">0x60000007ad00</span>&gt;&#123;number = <span class="number">5</span>, name = (null)&#125;</span><br></pre></td></tr></table></figure>
<h4 id="队列组">队列组</h4><h5 id="创建队列-1">创建队列</h5><p>group 可以分为 串行和并行的，区别在于DISPATCH_QUEUE_SERIAL和DISPATCH_QUEUE_CONCURRENT设置不同</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dispatch_group_t</span> group = dispatch_group_create();</span><br><span class="line"><span class="keyword">dispatch_queue_t</span> <span class="built_in">queue</span> = dispatch_queue_create(<span class="string">"com.testQueue"</span>, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">dispatch_group_async(group, <span class="built_in">queue</span>, ^&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        NSLog(@<span class="string">"group-01 - %@"</span>, [NSThread currentThread]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);    </span><br><span class="line">dispatch_group_async(group, <span class="built_in">queue</span>, ^&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        NSLog(@<span class="string">"group-03 - %@"</span>, [NSThread currentThread]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>log: 串行,但是异步的，不会阻塞当前线程</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">21</span> <span class="number">08</span>:<span class="number">05</span>:<span class="number">14.110</span> GCDTest[<span class="number">14034</span>:<span class="number">8745909</span>] group-<span class="number">01</span> - &lt;NSThread: <span class="number">0x60000027d100</span>&gt;&#123;number = <span class="number">4</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">21</span> <span class="number">08</span>:<span class="number">05</span>:<span class="number">14.111</span> GCDTest[<span class="number">14034</span>:<span class="number">8745909</span>] group-<span class="number">01</span> - &lt;NSThread: <span class="number">0x60000027d100</span>&gt;&#123;number = <span class="number">4</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">21</span> <span class="number">08</span>:<span class="number">05</span>:<span class="number">14.112</span> GCDTest[<span class="number">14034</span>:<span class="number">8745909</span>] group-<span class="number">01</span> - &lt;NSThread: <span class="number">0x60000027d100</span>&gt;&#123;number = <span class="number">4</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">21</span> <span class="number">08</span>:<span class="number">05</span>:<span class="number">14.112</span> GCDTest[<span class="number">14034</span>:<span class="number">8745909</span>] group-<span class="number">01</span> - &lt;NSThread: <span class="number">0x60000027d100</span>&gt;&#123;number = <span class="number">4</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">21</span> <span class="number">08</span>:<span class="number">05</span>:<span class="number">14.112</span> GCDTest[<span class="number">14034</span>:<span class="number">8745909</span>] group-<span class="number">01</span> - &lt;NSThread: <span class="number">0x60000027d100</span>&gt;&#123;number = <span class="number">4</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">21</span> <span class="number">08</span>:<span class="number">05</span>:<span class="number">19.589</span> GCDTest[<span class="number">14034</span>:<span class="number">8745909</span>] group-<span class="number">03</span> - &lt;NSThread: <span class="number">0x60000027d100</span>&gt;&#123;number = <span class="number">4</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">21</span> <span class="number">08</span>:<span class="number">05</span>:<span class="number">19.590</span> GCDTest[<span class="number">14034</span>:<span class="number">8745909</span>] group-<span class="number">03</span> - &lt;NSThread: <span class="number">0x60000027d100</span>&gt;&#123;number = <span class="number">4</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">21</span> <span class="number">08</span>:<span class="number">05</span>:<span class="number">19.590</span> GCDTest[<span class="number">14034</span>:<span class="number">8745909</span>] group-<span class="number">03</span> - &lt;NSThread: <span class="number">0x60000027d100</span>&gt;&#123;number = <span class="number">4</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">21</span> <span class="number">08</span>:<span class="number">05</span>:<span class="number">19.591</span> GCDTest[<span class="number">14034</span>:<span class="number">8745909</span>] group-<span class="number">03</span> - &lt;NSThread: <span class="number">0x60000027d100</span>&gt;&#123;number = <span class="number">4</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">21</span> <span class="number">08</span>:<span class="number">05</span>:<span class="number">19.591</span> GCDTest[<span class="number">14034</span>:<span class="number">8745909</span>] group-<span class="number">03</span> - &lt;NSThread: <span class="number">0x60000027d100</span>&gt;&#123;number = <span class="number">4</span>, name = (null)&#125;</span><br></pre></td></tr></table></figure>
<p>并行:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">21</span> <span class="number">08</span>:<span class="number">09</span>:<span class="number">46.984</span> GCDTest[<span class="number">14058</span>:<span class="number">8768392</span>] group-<span class="number">03</span> - &lt;NSThread: <span class="number">0x608000273900</span>&gt;&#123;number = <span class="number">4</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">21</span> <span class="number">08</span>:<span class="number">09</span>:<span class="number">46.984</span> GCDTest[<span class="number">14058</span>:<span class="number">8768371</span>] group-<span class="number">01</span> - &lt;NSThread: <span class="number">0x608000273200</span>&gt;&#123;number = <span class="number">3</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">21</span> <span class="number">08</span>:<span class="number">09</span>:<span class="number">46.984</span> GCDTest[<span class="number">14058</span>:<span class="number">8768392</span>] group-<span class="number">03</span> - &lt;NSThread: <span class="number">0x608000273900</span>&gt;&#123;number = <span class="number">4</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">21</span> <span class="number">08</span>:<span class="number">09</span>:<span class="number">46.984</span> GCDTest[<span class="number">14058</span>:<span class="number">8768371</span>] group-<span class="number">01</span> - &lt;NSThread: <span class="number">0x608000273200</span>&gt;&#123;number = <span class="number">3</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">21</span> <span class="number">08</span>:<span class="number">09</span>:<span class="number">46.985</span> GCDTest[<span class="number">14058</span>:<span class="number">8768392</span>] group-<span class="number">03</span> - &lt;NSThread: <span class="number">0x608000273900</span>&gt;&#123;number = <span class="number">4</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">21</span> <span class="number">08</span>:<span class="number">09</span>:<span class="number">46.985</span> GCDTest[<span class="number">14058</span>:<span class="number">8768371</span>] group-<span class="number">01</span> - &lt;NSThread: <span class="number">0x608000273200</span>&gt;&#123;number = <span class="number">3</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">21</span> <span class="number">08</span>:<span class="number">09</span>:<span class="number">46.985</span> GCDTest[<span class="number">14058</span>:<span class="number">8768392</span>] group-<span class="number">03</span> - &lt;NSThread: <span class="number">0x608000273900</span>&gt;&#123;number = <span class="number">4</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">21</span> <span class="number">08</span>:<span class="number">09</span>:<span class="number">46.985</span> GCDTest[<span class="number">14058</span>:<span class="number">8768371</span>] group-<span class="number">01</span> - &lt;NSThread: <span class="number">0x608000273200</span>&gt;&#123;number = <span class="number">3</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">21</span> <span class="number">08</span>:<span class="number">09</span>:<span class="number">46.985</span> GCDTest[<span class="number">14058</span>:<span class="number">8768392</span>] group-<span class="number">03</span> - &lt;NSThread: <span class="number">0x608000273900</span>&gt;&#123;number = <span class="number">4</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">21</span> <span class="number">08</span>:<span class="number">09</span>:<span class="number">46.986</span> GCDTest[<span class="number">14058</span>:<span class="number">8768371</span>] group-<span class="number">01</span> - &lt;NSThread: <span class="number">0x608000273200</span>&gt;&#123;number = <span class="number">3</span>, name = (null)&#125;</span><br></pre></td></tr></table></figure>
<h5 id="监听任务组事件的执行完毕">监听任务组事件的执行完毕</h5><p>1.dispatch_group_notify </p>
<p>用来监听任务组事件的执行完毕, 异步执行闭包，不会阻塞</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span></span><br><span class="line"><span class="title">dispatch_group_notify</span><span class="params">(dispatch_group_t group,</span><br><span class="line">	dispatch_queue_t <span class="built_in">queue</span>,</span><br><span class="line">	dispatch_block_t block)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">dispatch_group_t group = dispatch_group_create<span class="list">()</span><span class="comment">;</span></span><br><span class="line">dispatch_queue_t queue = dispatch_queue_create<span class="list">(<span class="string">"com.testQueue"</span>, DISPATCH_QUEUE_CONCURRENT)</span><span class="comment">;</span></span><br><span class="line">dispatch_group_async<span class="list">(<span class="keyword">group</span>, queue, ^&#123;</span><br><span class="line">    [[NSThread currentThread] setName:@<span class="string">"group-01-thread"</span>]<span class="comment">;</span></span><br><span class="line">    for <span class="list">(<span class="keyword">int</span> i = <span class="number">0</span><span class="comment">; i &lt; 3; i++) &#123;</span></span><br><span class="line">        NSLog<span class="list">(@<span class="string">"group-01 - %@"</span>, [NSThread currentThread])</span><span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><span class="comment">;</span></span><br><span class="line">dispatch_group_async<span class="list">(<span class="keyword">group</span>, queue, ^&#123;</span><br><span class="line">    [[NSThread currentThread] setName:@<span class="string">"group-03-thread"</span>]<span class="comment">;</span></span><br><span class="line">    for <span class="list">(<span class="keyword">int</span> i = <span class="number">0</span><span class="comment">; i &lt; 3; i++) &#123;</span></span><br><span class="line">        NSLog<span class="list">(@<span class="string">"group-03 - %@"</span>, [NSThread currentThread])</span><span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><span class="comment">;</span></span><br><span class="line">NSLog<span class="list">(@<span class="string">"notify leave"</span>)</span><span class="comment">;</span></span><br><span class="line">dispatch_group_notify<span class="list">(<span class="keyword">group</span>, dispatch_get_main_queue<span class="list">()</span>, ^&#123;</span><br><span class="line">    NSLog<span class="list">(@<span class="string">"notify 完成 - %@"</span>, [NSThread currentThread])</span><span class="comment">;</span></span><br><span class="line">&#125;)</span><span class="comment">;</span></span><br><span class="line">NSLog<span class="list">(@<span class="string">"notify leave"</span>)</span><span class="comment">;</span></span></span></span><br></pre></td></tr></table></figure>
<p>log:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">22</span> <span class="number">07</span>:<span class="number">03</span>:<span class="number">18.150</span> GCDTest[<span class="number">19000</span>:<span class="number">9806166</span>] notify leave</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">22</span> <span class="number">07</span>:<span class="number">03</span>:<span class="number">18.150</span> GCDTest[<span class="number">19000</span>:<span class="number">9813919</span>] group-<span class="number">01</span> - &lt;NSThread: <span class="number">0x60000026b700</span>&gt;&#123;number = <span class="number">5</span>, name = group-<span class="number">01</span>-thread&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">22</span> <span class="number">07</span>:<span class="number">03</span>:<span class="number">18.150</span> GCDTest[<span class="number">19000</span>:<span class="number">9814304</span>] group-<span class="number">03</span> - &lt;NSThread: <span class="number">0x608000277800</span>&gt;&#123;number = <span class="number">6</span>, name = group-<span class="number">03</span>-thread&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">22</span> <span class="number">07</span>:<span class="number">03</span>:<span class="number">18.151</span> GCDTest[<span class="number">19000</span>:<span class="number">9806166</span>] notify leave</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">22</span> <span class="number">07</span>:<span class="number">03</span>:<span class="number">18.151</span> GCDTest[<span class="number">19000</span>:<span class="number">9813919</span>] group-<span class="number">01</span> - &lt;NSThread: <span class="number">0x60000026b700</span>&gt;&#123;number = <span class="number">5</span>, name = group-<span class="number">01</span>-thread&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">22</span> <span class="number">07</span>:<span class="number">03</span>:<span class="number">18.151</span> GCDTest[<span class="number">19000</span>:<span class="number">9814304</span>] group-<span class="number">03</span> - &lt;NSThread: <span class="number">0x608000277800</span>&gt;&#123;number = <span class="number">6</span>, name = group-<span class="number">03</span>-thread&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">22</span> <span class="number">07</span>:<span class="number">03</span>:<span class="number">18.152</span> GCDTest[<span class="number">19000</span>:<span class="number">9813919</span>] group-<span class="number">01</span> - &lt;NSThread: <span class="number">0x60000026b700</span>&gt;&#123;number = <span class="number">5</span>, name = group-<span class="number">01</span>-thread&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">22</span> <span class="number">07</span>:<span class="number">03</span>:<span class="number">18.152</span> GCDTest[<span class="number">19000</span>:<span class="number">9814304</span>] group-<span class="number">03</span> - &lt;NSThread: <span class="number">0x608000277800</span>&gt;&#123;number = <span class="number">6</span>, name = group-<span class="number">03</span>-thread&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">22</span> <span class="number">07</span>:<span class="number">03</span>:<span class="number">18.157</span> GCDTest[<span class="number">19000</span>:<span class="number">9806166</span>] notify 完成 - &lt;NSThread: <span class="number">0x60800007b6c0</span>&gt;&#123;number = <span class="number">1</span>, name = main&#125;</span><br></pre></td></tr></table></figure>
<p>2.dispatch_group_wait   </p>
<p>会阻塞当前进程，等所有任务都完成或等待超时。设置等待时间，在等待时间结束后，如果还没有执行完任务组，则返回。返回0代表执行成功，非0则执行失败</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">dispatch_group_wait</span>(<span class="params">dispatch_group_t <span class="keyword">group</span>, dispatch_time_t timeout</span>)</span>;</span><br></pre></td></tr></table></figure>
<p>超时时间 可以根据需要设置，系统提供了两个宏：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hexcolor">#def</span>ine DISPATCH_TIME_NOW (<span class="number">0</span>ull)</span><br><span class="line"><span class="hexcolor">#def</span>ine DISPATCH_TIME_FOREVER (~<span class="number">0</span>ull)</span><br></pre></td></tr></table></figure>
<p>在此之前介绍一下时间：</p>
<p>iOS系统 GCD 中提供了一下几种时间</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hexcolor">#def</span>ine NSEC_PER_SEC  <span class="number">1000000000</span>ull</span><br><span class="line"><span class="hexcolor">#def</span>ine NSEC_PER_MSEC <span class="number">1000000</span>ull</span><br><span class="line"><span class="hexcolor">#def</span>ine USEC_PER_SEC  <span class="number">1000000</span>ull</span><br><span class="line"><span class="hexcolor">#def</span>ine NSEC_PER_USEC <span class="number">1000</span>ull</span><br></pre></td></tr></table></figure>
<p>关键词解释：    </p>
<ul>
<li>NSEC：纳秒</li>
<li>USEC：微秒</li>
<li>MSEC：毫秒</li>
<li>SEC：秒</li>
<li>PER：每</li>
</ul>
<p>故：</p>
<table>
<thead>
<tr>
<th>宏</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>NSEC_PER_SEC</td>
<td style="text-align:center">每秒有多少纳秒</td>
</tr>
<tr>
<td>NSEC_PER_MSEC</td>
<td style="text-align:center">每毫秒有多少纳秒</td>
</tr>
<tr>
<td>USEC_PER_SEC</td>
<td style="text-align:center">每秒有多少微秒</td>
</tr>
<tr>
<td>NSEC_PER_USEC</td>
<td style="text-align:center">每微秒有多少纳秒</td>
</tr>
</tbody>
</table>
<p>所以，延时1秒可以写成如下几种：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dispatch_time<span class="list">(<span class="keyword">DISPATCH_TIME_NOW</span>, <span class="number">1</span> <span class="variable">* NSEC_PER_SEC);</span><br><span class="line">dispatch_time(DISPATCH_TIME_NOW, 1000 *</span> USEC_PER_SEC)</span><span class="comment">;</span></span><br><span class="line">dispatch_time<span class="list">(<span class="keyword">DISPATCH_TIME_NOW</span>, USEC_PER_SEC <span class="variable">* NSEC_PER_USEC);</span><br><span class="line">dispatch_time(DISPATCH_TIME_NOW, NSEC_PER_MSEC *</span> NSEC_PER_USEC)</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>绝对时间，dispatch_group_wait 想等到2016年09月22日23:20:53 的时候超时，那么要使用 dispatch_walltime函数将NSdate 转化为dispatch_time，下面是方法：</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- (dispatch_time_t)switchDateToDispatch_time_tWithDate:(NSDate *)<span class="type">date</span></span><br><span class="line">&#123;</span><br><span class="line">    NSTimeInterval interval;</span><br><span class="line">    double <span class="keyword">second</span>,subsecond;</span><br><span class="line">    struct timespec <span class="property">time</span>;</span><br><span class="line">    dispatch_time_t milestone;</span><br><span class="line">    interval=[<span class="type">date</span> timeIntervalSince1970];</span><br><span class="line">    </span><br><span class="line">    subsecond = modf(interval, &amp;<span class="keyword">second</span>);</span><br><span class="line">    <span class="property">time</span>.tv_sec = <span class="keyword">second</span>;</span><br><span class="line">    <span class="property">time</span>.tv_nsec= subsecond*NSEC_PER_SEC;</span><br><span class="line">    </span><br><span class="line">    milestone = dispatch_walltime(&amp;<span class="property">time</span>, <span class="number">0</span>);</span><br><span class="line"><span class="command">    return</span> milestone;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>好了时间说完了，该说示例了：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dispatch_group_t</span> group = dispatch_group_create();</span><br><span class="line"><span class="keyword">dispatch_queue_t</span> <span class="built_in">queue</span> = dispatch_queue_create(<span class="string">"com.testQueue"</span>, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">dispatch_group_async(group, <span class="built_in">queue</span>, ^&#123;</span><br><span class="line">    [[NSThread currentThread] setName:@<span class="string">"group-01-thread"</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        NSLog(@<span class="string">"group-01 - %@"</span>, [NSThread currentThread]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_group_async(group, <span class="built_in">queue</span>, ^&#123;</span><br><span class="line">    [[NSThread currentThread] setName:@<span class="string">"group-03-thread"</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        NSLog(@<span class="string">"group-03 - %@"</span>, [NSThread currentThread]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">NSLog(@<span class="string">"dispatch_group_wait 之前"</span>);</span><br><span class="line"><span class="keyword">long</span> value = dispatch_group_wait(group, DISPATCH_TIME_FOREVER);</span><br><span class="line">NSLog(@<span class="string">"dispatch_group_wait 之后 value = %ld"</span>,value);</span><br></pre></td></tr></table></figure>
<p>log:</p>
<p>① DISPATCH_TIME_FOREVER 可以看到会阻塞当前线程直到任务全部完成</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">22</span> <span class="number">07</span>:<span class="number">15</span>:<span class="number">14.211</span> GCDTest[<span class="number">19022</span>:<span class="number">9870397</span>] dispatch_group_wait 之前</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">22</span> <span class="number">07</span>:<span class="number">15</span>:<span class="number">14.211</span> GCDTest[<span class="number">19022</span>:<span class="number">9874488</span>] group-<span class="number">01</span> - &lt;NSThread: <span class="number">0x608000268f40</span>&gt;&#123;number = <span class="number">5</span>, name = group-<span class="number">01</span>-thread&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">22</span> <span class="number">07</span>:<span class="number">15</span>:<span class="number">14.211</span> GCDTest[<span class="number">19022</span>:<span class="number">9874995</span>] group-<span class="number">03</span> - &lt;NSThread: <span class="number">0x608000268500</span>&gt;&#123;number = <span class="number">6</span>, name = group-<span class="number">03</span>-thread&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">22</span> <span class="number">07</span>:<span class="number">15</span>:<span class="number">14.211</span> GCDTest[<span class="number">19022</span>:<span class="number">9874488</span>] group-<span class="number">01</span> - &lt;NSThread: <span class="number">0x608000268f40</span>&gt;&#123;number = <span class="number">5</span>, name = group-<span class="number">01</span>-thread&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">22</span> <span class="number">07</span>:<span class="number">15</span>:<span class="number">14.211</span> GCDTest[<span class="number">19022</span>:<span class="number">9874995</span>] group-<span class="number">03</span> - &lt;NSThread: <span class="number">0x608000268500</span>&gt;&#123;number = <span class="number">6</span>, name = group-<span class="number">03</span>-thread&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">22</span> <span class="number">07</span>:<span class="number">15</span>:<span class="number">14.211</span> GCDTest[<span class="number">19022</span>:<span class="number">9874488</span>] group-<span class="number">01</span> - &lt;NSThread: <span class="number">0x608000268f40</span>&gt;&#123;number = <span class="number">5</span>, name = group-<span class="number">01</span>-thread&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">22</span> <span class="number">07</span>:<span class="number">15</span>:<span class="number">14.212</span> GCDTest[<span class="number">19022</span>:<span class="number">9874995</span>] group-<span class="number">03</span> - &lt;NSThread: <span class="number">0x608000268500</span>&gt;&#123;number = <span class="number">6</span>, name = group-<span class="number">03</span>-thread&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">22</span> <span class="number">07</span>:<span class="number">15</span>:<span class="number">14.212</span> GCDTest[<span class="number">19022</span>:<span class="number">9870397</span>] dispatch_group_wait 之后 value = <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>② DISPATCH_TIME_NOW dispatch_group_wait 并未阻塞当前线程 但是 返回非零值，表明任务执行失败或者超时，这明显是超时</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">22</span> <span class="number">07</span>:<span class="number">18</span>:<span class="number">21.506</span> GCDTest[<span class="number">19041</span>:<span class="number">9887622</span>] dispatch_group_wait 之前</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">22</span> <span class="number">07</span>:<span class="number">18</span>:<span class="number">21.506</span> GCDTest[<span class="number">19041</span>:<span class="number">9891849</span>] group-<span class="number">01</span> - &lt;NSThread: <span class="number">0x608000274700</span>&gt;&#123;number = <span class="number">3</span>, name = group-<span class="number">01</span>-thread&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">22</span> <span class="number">07</span>:<span class="number">18</span>:<span class="number">21.506</span> GCDTest[<span class="number">19041</span>:<span class="number">9891894</span>] group-<span class="number">03</span> - &lt;NSThread: <span class="number">0x608000274680</span>&gt;&#123;number = <span class="number">4</span>, name = group-<span class="number">03</span>-thread&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">22</span> <span class="number">07</span>:<span class="number">18</span>:<span class="number">21.506</span> GCDTest[<span class="number">19041</span>:<span class="number">9887622</span>] dispatch_group_wait 之后 value = <span class="number">49</span></span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">22</span> <span class="number">07</span>:<span class="number">18</span>:<span class="number">21.506</span> GCDTest[<span class="number">19041</span>:<span class="number">9891849</span>] group-<span class="number">01</span> - &lt;NSThread: <span class="number">0x608000274700</span>&gt;&#123;number = <span class="number">3</span>, name = group-<span class="number">01</span>-thread&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">22</span> <span class="number">07</span>:<span class="number">18</span>:<span class="number">21.507</span> GCDTest[<span class="number">19041</span>:<span class="number">9891894</span>] group-<span class="number">03</span> - &lt;NSThread: <span class="number">0x608000274680</span>&gt;&#123;number = <span class="number">4</span>, name = group-<span class="number">03</span>-thread&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">22</span> <span class="number">07</span>:<span class="number">18</span>:<span class="number">21.507</span> GCDTest[<span class="number">19041</span>:<span class="number">9891849</span>] group-<span class="number">01</span> - &lt;NSThread: <span class="number">0x608000274700</span>&gt;&#123;number = <span class="number">3</span>, name = group-<span class="number">01</span>-thread&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">22</span> <span class="number">07</span>:<span class="number">18</span>:<span class="number">21.508</span> GCDTest[<span class="number">19041</span>:<span class="number">9891894</span>] group-<span class="number">03</span> - &lt;NSThread: <span class="number">0x608000274680</span>&gt;&#123;number = <span class="number">4</span>, name = group-<span class="number">03</span>-thread&#125;</span><br></pre></td></tr></table></figure>
<p>③ 自定义时间 会阻塞当前的线程</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这里让线程 睡眠2s</span></span><br><span class="line">    dispatch_group_async(group, <span class="built_in">queue</span>, ^&#123;</span><br><span class="line">        [[NSThread currentThread] setName:@<span class="string">"group-03-thread"</span>];</span><br><span class="line">        [NSThread sleepForTimeInterval:<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            NSLog(@<span class="string">"group-03 - %@"</span>, [NSThread currentThread]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"><span class="keyword">long</span> value = dispatch_group_wait(group, dispatch_time(DISPATCH_TIME_NOW, (<span class="keyword">int64_t</span>)(<span class="number">5</span>*NSEC_PER_SEC)));</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">22</span> <span class="number">07</span>:<span class="number">37</span>:<span class="number">32.478</span> GCDTest[<span class="number">19217</span>:<span class="number">10005760</span>] dispatch_group_wait 之前</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">22</span> <span class="number">07</span>:<span class="number">37</span>:<span class="number">32.478</span> GCDTest[<span class="number">19217</span>:<span class="number">10006060</span>] group-<span class="number">01</span> - &lt;NSThread: <span class="number">0x608000274140</span>&gt;&#123;number = <span class="number">3</span>, name = group-<span class="number">01</span>-thread&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">22</span> <span class="number">07</span>:<span class="number">37</span>:<span class="number">32.479</span> GCDTest[<span class="number">19217</span>:<span class="number">10006060</span>] group-<span class="number">01</span> - &lt;NSThread: <span class="number">0x608000274140</span>&gt;&#123;number = <span class="number">3</span>, name = group-<span class="number">01</span>-thread&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">22</span> <span class="number">07</span>:<span class="number">37</span>:<span class="number">32.479</span> GCDTest[<span class="number">19217</span>:<span class="number">10006060</span>] group-<span class="number">01</span> - &lt;NSThread: <span class="number">0x608000274140</span>&gt;&#123;number = <span class="number">3</span>, name = group-<span class="number">01</span>-thread&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">22</span> <span class="number">07</span>:<span class="number">37</span>:<span class="number">34.482</span> GCDTest[<span class="number">19217</span>:<span class="number">10006057</span>] group-<span class="number">03</span> - &lt;NSThread: <span class="number">0x608000273f80</span>&gt;&#123;number = <span class="number">4</span>, name = group-<span class="number">03</span>-thread&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">22</span> <span class="number">07</span>:<span class="number">37</span>:<span class="number">34.483</span> GCDTest[<span class="number">19217</span>:<span class="number">10006057</span>] group-<span class="number">03</span> - &lt;NSThread: <span class="number">0x608000273f80</span>&gt;&#123;number = <span class="number">4</span>, name = group-<span class="number">03</span>-thread&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">22</span> <span class="number">07</span>:<span class="number">37</span>:<span class="number">34.483</span> GCDTest[<span class="number">19217</span>:<span class="number">10006057</span>] group-<span class="number">03</span> - &lt;NSThread: <span class="number">0x608000273f80</span>&gt;&#123;number = <span class="number">4</span>, name = group-<span class="number">03</span>-thread&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">22</span> <span class="number">07</span>:<span class="number">37</span>:<span class="number">34.484</span> GCDTest[<span class="number">19217</span>:<span class="number">10005760</span>] dispatch_group_wait 之后 value = <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>3.dispatch_group_enter  dispatch_group_leave<br>这里 dispatch_group_enter 和 dispatch_group_leave 需要成对出现,否则dispatch_group_notify不会回调用（这里可能会崩溃，不过在我测试中没有发现）</p>
<p>①这是 dispatch_queue_t 的例子：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">dispatch_group_t group = dispatch_group_create<span class="list">()</span><span class="comment">;</span></span><br><span class="line">dispatch_queue_t queue = dispatch_queue_create<span class="list">(<span class="string">"com.testQueue"</span>, DISPATCH_QUEUE_CONCURRENT)</span><span class="comment">;</span></span><br><span class="line">dispatch_group_enter<span class="list">(<span class="keyword">group</span>)</span><span class="comment">;</span></span><br><span class="line">dispatch_group_async<span class="list">(<span class="keyword">group</span>, queue, ^&#123;</span><br><span class="line">    [[NSThread currentThread] setName:@<span class="string">"group-01-thread"</span>]<span class="comment">;</span></span><br><span class="line">    for <span class="list">(<span class="keyword">int</span> i = <span class="number">0</span><span class="comment">; i &lt; 3; i++) &#123;</span></span><br><span class="line">        NSLog<span class="list">(@<span class="string">"group-01 - %@"</span>, [NSThread currentThread])</span><span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line">    dispatch_group_leave<span class="list">(<span class="keyword">group</span>)</span><span class="comment">;</span></span><br><span class="line">&#125;)</span><span class="comment">;</span></span><br><span class="line">dispatch_group_enter<span class="list">(<span class="keyword">group</span>)</span><span class="comment">;</span></span><br><span class="line">dispatch_group_async<span class="list">(<span class="keyword">group</span>, queue, ^&#123;</span><br><span class="line">    [[NSThread currentThread] setName:@<span class="string">"group-03-thread"</span>]<span class="comment">;</span></span><br><span class="line">    [NSThread sleepForTimeInterval:<span class="number">2</span>]<span class="comment">;</span></span><br><span class="line">    for <span class="list">(<span class="keyword">int</span> i = <span class="number">0</span><span class="comment">; i &lt; 3; i++) &#123;</span></span><br><span class="line">        NSLog<span class="list">(@<span class="string">"group-03 - %@"</span>, [NSThread currentThread])</span><span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line">    dispatch_group_leave<span class="list">(<span class="keyword">group</span>)</span><span class="comment">;</span></span><br><span class="line">&#125;)</span><span class="comment">;</span></span><br><span class="line">dispatch_group_notify<span class="list">(<span class="keyword">group</span>, dispatch_get_main_queue<span class="list">()</span>, ^&#123;</span><br><span class="line">    NSLog<span class="list">(@<span class="string">"notify 完成 - %@"</span>, [NSThread currentThread])</span><span class="comment">;</span></span><br><span class="line">&#125;)</span><span class="comment">;</span></span></span></span><br></pre></td></tr></table></figure>
<p>②这是NSOperationQueue的例子：</p>
<figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">dispatch_group_t <span class="keyword">group</span> = dispatch_group_create();</span><br><span class="line">NSOperationQueue *queue = [[NSOperationQueue alloc] init];</span><br><span class="line">dispatch_group_enter(<span class="keyword">group</span>);</span><br><span class="line">NSBlockOperation *<span class="built_in">block</span>Operation_1 = [NSBlockOperation <span class="built_in">block</span>OperationWithBlock:^&#123;</span><br><span class="line">    NSLog(@<span class="string">"NSBlockOperation 1 --- %@"</span>, [NSThread currentThread]);</span><br><span class="line">    [NSThread sleepForTimeInterval:<span class="number">2</span>];</span><br><span class="line">    dispatch_group_leave(<span class="keyword">group</span>);</span><br><span class="line">&#125;];</span><br><span class="line">dispatch_group_enter(<span class="keyword">group</span>);</span><br><span class="line">NSBlockOperation *<span class="built_in">block</span>Operation_2 = [NSBlockOperation <span class="built_in">block</span>OperationWithBlock:^&#123;</span><br><span class="line">    NSLog(@<span class="string">"NSBlockOperation 2 --- %@"</span>, [NSThread currentThread]);</span><br><span class="line">    dispatch_group_leave(<span class="keyword">group</span>);</span><br><span class="line">&#125;];</span><br><span class="line">[<span class="built_in">block</span>Operation_1 <span class="built_in">set</span>Name:@<span class="string">"blockOperation_1"</span>];</span><br><span class="line">[<span class="built_in">block</span>Operation_1 <span class="built_in">set</span>Name:@<span class="string">"blockOperation_2"</span>];</span><br><span class="line">[queue addOperation:<span class="built_in">block</span>Operation_1];</span><br><span class="line">[queue addOperation:<span class="built_in">block</span>Operation_2];</span><br><span class="line">dispatch_group_notify(<span class="keyword">group</span>, dispatch_get_main_queue(), ^&#123;</span><br><span class="line">    NSLog(@<span class="string">"notify 完成 - %@"</span>, [NSThread currentThread]);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h5 id="dispatch_once">dispatch_once</h5><p>dispatch_once 大家都不会陌生，但我认为还是有必要强调一次，dispatch_once_t 必须为静态变量</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line"><span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">    <span class="comment">// to do something</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h5 id="dispatch_after">dispatch_after</h5><p>dispatch_after 能让我们添加进队列的任务延时（这里说延时不严谨，后面会说到）执行</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">NSLog(@<span class="string">"begin"</span>);</span><br><span class="line"><span class="keyword">double</span> delayInSeconds = <span class="number">1.0</span>;</span><br><span class="line"><span class="keyword">dispatch_time_t</span> popTime = dispatch_time(DISPATCH_TIME_NOW, (<span class="keyword">int64_t</span>)(delayInSeconds * NSEC_PER_SEC));</span><br><span class="line">dispatch_after(popTime, dispatch_get_main_queue(), ^&#123;</span><br><span class="line">    NSLog(@<span class="string">"end"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>虽然可以提供NStimer 的功能，但它不是，看下面官方文档：</p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Enqueue <span class="operator">a</span> block <span class="keyword">for</span> execution <span class="keyword">at</span> <span class="operator">the</span> specified <span class="built_in">time</span>.</span><br></pre></td></tr></table></figure>
<p>Enqueue，就是入队，指的就是将一个Block在特定的延时以后，加入到指定的队列中，不是在特定的时间后立即运行！。这里有个例子:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dispatch_queue_t</span> <span class="built_in">queue</span> = dispatch_queue_create(<span class="string">"com.testQueue"</span>, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">NSLog(@<span class="string">"begin"</span>);</span><br><span class="line">dispatch_async(<span class="built_in">queue</span>, ^&#123;</span><br><span class="line">    [[NSThread currentThread] setName:@<span class="string">"group-01-thread"</span>];</span><br><span class="line">    [NSThread sleepForTimeInterval:<span class="number">10</span>];</span><br><span class="line">    NSLog(@<span class="string">"dispatch_group_async"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//1.使用 dispatch_after 延后工作</span></span><br><span class="line"><span class="keyword">double</span> delayInSeconds = <span class="number">5.0</span>;</span><br><span class="line"><span class="keyword">dispatch_time_t</span> popTime = dispatch_time(DISPATCH_TIME_NOW, (<span class="keyword">int64_t</span>)(delayInSeconds * NSEC_PER_SEC));</span><br><span class="line">dispatch_after(popTime, <span class="built_in">queue</span>, ^&#123;</span><br><span class="line">    NSLog(@<span class="string">"dispatch_time"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>log:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">23</span> <span class="number">22</span>:<span class="number">56</span>:<span class="number">05.258</span> GCDTest[<span class="number">20684</span>:<span class="number">11209748</span>] begin</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">23</span> <span class="number">22</span>:<span class="number">56</span>:<span class="number">15.263</span> GCDTest[<span class="number">20684</span>:<span class="number">11209796</span>] dispatch_group_async</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">23</span> <span class="number">22</span>:<span class="number">56</span>:<span class="number">15.263</span> GCDTest[<span class="number">20684</span>:<span class="number">11209796</span>] dispatch_time</span><br></pre></td></tr></table></figure>
<p>从结果也验证了，dispatch_after只是延时提交block，并不是延时后立即执行。所以想用dispatch_after精确控制运行状态的朋友可要注意了~</p>
<h5 id="dispatch_apply">dispatch_apply</h5><p>dispatch_apply的作用是在一个队列（串行或并行）上“运行”多次block，不过会阻塞当前线程，按执行最长任务时间阻塞(异步，同步是所有任务时间总和)，用时间要小心：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dispatch_queue_t</span> <span class="built_in">queue</span> = dispatch_queue_create(<span class="string">"com.testQueue"</span>, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">NSLog(@<span class="string">"apply 之前"</span>);</span><br><span class="line">dispatch_apply(<span class="number">3</span>, <span class="built_in">queue</span>, ^(<span class="keyword">size_t</span> y) &#123;</span><br><span class="line">    <span class="keyword">switch</span> (y) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:[NSThread sleepForTimeInterval:<span class="number">1</span>];<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:[NSThread sleepForTimeInterval:<span class="number">2</span>];<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:[NSThread sleepForTimeInterval:<span class="number">3</span>];<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:<span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    NSLog(@<span class="string">"%ld"</span>,y);</span><br><span class="line">&#125;);</span><br><span class="line">NSLog(@<span class="string">"apply 之后"</span>);</span><br></pre></td></tr></table></figure>
<p>log:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">23</span> <span class="number">23</span>:<span class="number">30</span>:<span class="number">24.984</span> GCDTest[<span class="number">20779</span>:<span class="number">11373252</span>] apply 之前</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">23</span> <span class="number">23</span>:<span class="number">30</span>:<span class="number">25.985</span> GCDTest[<span class="number">20779</span>:<span class="number">11373252</span>] <span class="number">0</span></span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">23</span> <span class="number">23</span>:<span class="number">30</span>:<span class="number">26.987</span> GCDTest[<span class="number">20779</span>:<span class="number">11373585</span>] <span class="number">1</span></span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">23</span> <span class="number">23</span>:<span class="number">30</span>:<span class="number">27.988</span> GCDTest[<span class="number">20779</span>:<span class="number">11373584</span>] <span class="number">2</span></span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">23</span> <span class="number">23</span>:<span class="number">30</span>:<span class="number">27.988</span> GCDTest[<span class="number">20779</span>:<span class="number">11373252</span>] apply 之后</span><br></pre></td></tr></table></figure>
<p>将其放在异步线程去执行，这样就不阻塞主线程了：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">NSLog(@<span class="string">"dispatch_async 之前"</span>);</span><br><span class="line">dispatch_async(dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>), ^&#123;</span><br><span class="line">    <span class="keyword">dispatch_queue_t</span> <span class="built_in">queue</span> = dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">//使用dispatch_apply可以运行的更快</span></span><br><span class="line">    NSLog(@<span class="string">"apply 之前"</span>);</span><br><span class="line">    dispatch_apply(<span class="number">3</span>, <span class="built_in">queue</span>, ^(<span class="keyword">size_t</span> y) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (y) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:[NSThread sleepForTimeInterval:<span class="number">1</span>];<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:[NSThread sleepForTimeInterval:<span class="number">2</span>];<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:[NSThread sleepForTimeInterval:<span class="number">3</span>];<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        NSLog(@<span class="string">"%ld"</span>,y);</span><br><span class="line">    &#125;);</span><br><span class="line">    NSLog(@<span class="string">"apply 之后"</span>);</span><br><span class="line">&#125;);</span><br><span class="line">NSLog(@<span class="string">"dispatch_async 之后"</span>);</span><br></pre></td></tr></table></figure>
<p>log:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">23</span> <span class="number">23</span>:<span class="number">38</span>:<span class="number">21.221</span> GCDTest[<span class="number">20817</span>:<span class="number">11403936</span>] dispatch_async 之前</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">23</span> <span class="number">23</span>:<span class="number">38</span>:<span class="number">21.222</span> GCDTest[<span class="number">20817</span>:<span class="number">11403936</span>] dispatch_async 之后</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">23</span> <span class="number">23</span>:<span class="number">38</span>:<span class="number">21.222</span> GCDTest[<span class="number">20817</span>:<span class="number">11404070</span>] apply 之前</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">23</span> <span class="number">23</span>:<span class="number">38</span>:<span class="number">22.223</span> GCDTest[<span class="number">20817</span>:<span class="number">11404070</span>] <span class="number">0</span></span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">23</span> <span class="number">23</span>:<span class="number">38</span>:<span class="number">23.226</span> GCDTest[<span class="number">20817</span>:<span class="number">11404072</span>] <span class="number">1</span></span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">23</span> <span class="number">23</span>:<span class="number">38</span>:<span class="number">24.225</span> GCDTest[<span class="number">20817</span>:<span class="number">11404069</span>] <span class="number">2</span></span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">23</span> <span class="number">23</span>:<span class="number">38</span>:<span class="number">24.226</span> GCDTest[<span class="number">20817</span>:<span class="number">11404070</span>] apply 之后</span><br></pre></td></tr></table></figure>
<h5 id="dispatch_barrier_async">dispatch_barrier_async</h5><p>dispatch_barrier_async的作用就是向某个队列插入一个block，当目前正在执行的block运行完成后，阻塞这个block后面添加的block，只运行这个block直到完成，然后再继续后续的任务。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">dispatch_group_t group = dispatch_group_create<span class="list">()</span><span class="comment">;</span></span><br><span class="line">//    dispatch_queue_t queue = dispatch_get_global_queue<span class="list">(<span class="keyword">DISPATCH_QUEUE_PRIORITY_DEFAULT</span>, <span class="number">0</span>)</span><span class="comment">;</span></span><br><span class="line">dispatch_queue_t queue = dispatch_queue_create<span class="list">(<span class="string">"com.testQueue"</span>, DISPATCH_QUEUE_CONCURRENT)</span><span class="comment">;</span></span><br><span class="line">dispatch_group_async<span class="list">(<span class="keyword">group</span>, queue, ^&#123;</span><br><span class="line">    NSLog<span class="list">(@<span class="string">"group-01 - %@"</span>, [NSThread currentThread])</span><span class="comment">;</span></span><br><span class="line">&#125;)</span><span class="comment">;</span></span><br><span class="line"></span><br><span class="line">dispatch_barrier_async<span class="list">(<span class="keyword">queue</span>, ^&#123;</span><br><span class="line">    NSLog<span class="list">(@<span class="string">"barrier - %@"</span>, [NSThread currentThread])</span><span class="comment">;</span></span><br><span class="line">&#125;)</span><span class="comment">;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">dispatch_group_async<span class="list">(<span class="keyword">group</span>, queue, ^&#123;</span><br><span class="line">    for <span class="list">(<span class="keyword">int</span> i = <span class="number">0</span><span class="comment">; i &lt; 3; i++) &#123;</span></span><br><span class="line">        NSLog<span class="list">(@<span class="string">"group-02 - %@"</span>, [NSThread currentThread])</span><span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><span class="comment">;</span></span><br><span class="line"></span><br><span class="line">dispatch_group_async<span class="list">(<span class="keyword">group</span>, queue, ^&#123;</span><br><span class="line">    for <span class="list">(<span class="keyword">int</span> i = <span class="number">0</span><span class="comment">; i &lt; 3; i++) &#123;</span></span><br><span class="line">        NSLog<span class="list">(@<span class="string">"group-03 - %@"</span>, [NSThread currentThread])</span><span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><span class="comment">;</span></span></span></span><br></pre></td></tr></table></figure>
<p>log:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">23</span> <span class="number">23</span>:<span class="number">54</span>:<span class="number">08.478</span> GCDTest[<span class="number">20928</span>:<span class="number">11478999</span>] group-<span class="number">01</span> - &lt;NSThread: <span class="number">0x608000265700</span>&gt;&#123;number = <span class="number">3</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">23</span> <span class="number">23</span>:<span class="number">54</span>:<span class="number">08.478</span> GCDTest[<span class="number">20928</span>:<span class="number">11478999</span>] barrier - &lt;NSThread: <span class="number">0x608000265700</span>&gt;&#123;number = <span class="number">3</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">23</span> <span class="number">23</span>:<span class="number">54</span>:<span class="number">08.480</span> GCDTest[<span class="number">20928</span>:<span class="number">11478999</span>] group-<span class="number">02</span> - &lt;NSThread: <span class="number">0x608000265700</span>&gt;&#123;number = <span class="number">3</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">23</span> <span class="number">23</span>:<span class="number">54</span>:<span class="number">08.480</span> GCDTest[<span class="number">20928</span>:<span class="number">11478997</span>] group-<span class="number">03</span> - &lt;NSThread: <span class="number">0x60000026c680</span>&gt;&#123;number = <span class="number">4</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">23</span> <span class="number">23</span>:<span class="number">54</span>:<span class="number">08.481</span> GCDTest[<span class="number">20928</span>:<span class="number">11478999</span>] group-<span class="number">02</span> - &lt;NSThread: <span class="number">0x608000265700</span>&gt;&#123;number = <span class="number">3</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">23</span> <span class="number">23</span>:<span class="number">54</span>:<span class="number">08.481</span> GCDTest[<span class="number">20928</span>:<span class="number">11478997</span>] group-<span class="number">03</span> - &lt;NSThread: <span class="number">0x60000026c680</span>&gt;&#123;number = <span class="number">4</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">23</span> <span class="number">23</span>:<span class="number">54</span>:<span class="number">08.482</span> GCDTest[<span class="number">20928</span>:<span class="number">11478999</span>] group-<span class="number">02</span> - &lt;NSThread: <span class="number">0x608000265700</span>&gt;&#123;number = <span class="number">3</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">23</span> <span class="number">23</span>:<span class="number">54</span>:<span class="number">08.482</span> GCDTest[<span class="number">20928</span>:<span class="number">11478997</span>] group-<span class="number">03</span> - &lt;NSThread: <span class="number">0x60000026c680</span>&gt;&#123;number = <span class="number">4</span>, name = (null)&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>dispatch<em>barrier\</em>(a)sync 只在自己创建的并发队列上有效，在全局(Global)并发队列、串行队列上，效果跟dispatch_(a)sync效果一样。</li>
<li>既然在串行队列上跟dispatch_(a)sync效果一样，那就要小心别死锁！</li>
</ul>
<p>在dispatch_get_global_queue：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">23</span> <span class="number">23</span>:<span class="number">56</span>:<span class="number">14.201</span> GCDTest[<span class="number">20946</span>:<span class="number">11496633</span>] group-<span class="number">01</span> - &lt;NSThread: <span class="number">0x608000263780</span>&gt;&#123;number = <span class="number">3</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">23</span> <span class="number">23</span>:<span class="number">56</span>:<span class="number">14.201</span> GCDTest[<span class="number">20946</span>:<span class="number">11497029</span>] group-<span class="number">02</span> - &lt;NSThread: <span class="number">0x600000277200</span>&gt;&#123;number = <span class="number">5</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">23</span> <span class="number">23</span>:<span class="number">56</span>:<span class="number">14.201</span> GCDTest[<span class="number">20946</span>:<span class="number">11497030</span>] group-<span class="number">03</span> - &lt;NSThread: <span class="number">0x608000265840</span>&gt;&#123;number = <span class="number">6</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">23</span> <span class="number">23</span>:<span class="number">56</span>:<span class="number">14.201</span> GCDTest[<span class="number">20946</span>:<span class="number">11497028</span>] barrier - &lt;NSThread: <span class="number">0x608000265680</span>&gt;&#123;number = <span class="number">4</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">23</span> <span class="number">23</span>:<span class="number">56</span>:<span class="number">14.201</span> GCDTest[<span class="number">20946</span>:<span class="number">11497029</span>] group-<span class="number">02</span> - &lt;NSThread: <span class="number">0x600000277200</span>&gt;&#123;number = <span class="number">5</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">23</span> <span class="number">23</span>:<span class="number">56</span>:<span class="number">14.201</span> GCDTest[<span class="number">20946</span>:<span class="number">11497030</span>] group-<span class="number">03</span> - &lt;NSThread: <span class="number">0x608000265840</span>&gt;&#123;number = <span class="number">6</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">23</span> <span class="number">23</span>:<span class="number">56</span>:<span class="number">14.202</span> GCDTest[<span class="number">20946</span>:<span class="number">11497029</span>] group-<span class="number">02</span> - &lt;NSThread: <span class="number">0x600000277200</span>&gt;&#123;number = <span class="number">5</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">23</span> <span class="number">23</span>:<span class="number">56</span>:<span class="number">14.202</span> GCDTest[<span class="number">20946</span>:<span class="number">11497030</span>] group-<span class="number">03</span> - &lt;NSThread: <span class="number">0x608000265840</span>&gt;&#123;number = <span class="number">6</span>, name = (null)&#125;</span><br></pre></td></tr></table></figure>
<h5 id="暂停与恢复">暂停与恢复</h5><ul>
<li>dispatch_suspend(queue); 暂停队列</li>
<li>dispatch_resume(queue); 恢复队列</li>
</ul>
<p>dispatch_suspend函数对已经执行的处理没有影响。挂起后，追加到 Dispatch Queue 中但尚未执行的处理在此之后停止执行。而dispatch_resume则使得这些处理能够继续执行。</p>
<p>这里有个例子（<a href="https://github.com/ChenYilong/ParseSourceCodeStudy/blob/master/01_Parse的多线程处理思路/Parse的底层多线程处理思路.md#parse-ios-sdk介绍" target="_blank" rel="external">参考来自这里</a>）</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t queue1 = dispatch_queue_create<span class="list">(<span class="string">"com.queue1"</span>, <span class="number">0</span>)</span><span class="comment">;</span></span><br><span class="line">dispatch_queue_t queue2 = dispatch_queue_create<span class="list">(<span class="string">"com.queue2"</span>, <span class="number">0</span>)</span><span class="comment">;</span></span><br><span class="line">dispatch_group_t group  = dispatch_group_create<span class="list">()</span><span class="comment">;</span></span><br><span class="line">dispatch_async<span class="list">(<span class="keyword">queue1</span>, ^&#123;</span><br><span class="line">    NSLog<span class="list">(@<span class="string">"任务 1 ： queue 1..."</span>)</span><span class="comment">;</span></span><br><span class="line">    sleep<span class="list">(<span class="number">1</span>)</span><span class="comment">;</span></span><br><span class="line">    NSLog<span class="list">(@<span class="string">"✅完成任务 1"</span>)</span><span class="comment">;</span></span><br><span class="line">&#125;)</span><span class="comment">;</span></span><br><span class="line"></span><br><span class="line">dispatch_async<span class="list">(<span class="keyword">queue2</span>, ^&#123;</span><br><span class="line">    NSLog<span class="list">(@<span class="string">"任务 1 ： queue 2..."</span>)</span><span class="comment">;</span></span><br><span class="line">    sleep<span class="list">(<span class="number">1</span>)</span><span class="comment">;</span></span><br><span class="line">    NSLog<span class="list">(@<span class="string">"✅完成任务 2"</span>)</span><span class="comment">;</span></span><br><span class="line">&#125;)</span><span class="comment">;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">dispatch_group_async<span class="list">(<span class="keyword">group</span>, queue1, ^&#123;</span><br><span class="line">    NSLog<span class="list">(@<span class="string">"🚫正在暂停 1"</span>)</span><span class="comment">;</span></span><br><span class="line">    dispatch_suspend<span class="list">(<span class="keyword">queue1</span>)</span><span class="comment">;</span></span><br><span class="line">&#125;)</span><span class="comment">;</span></span><br><span class="line">dispatch_group_async<span class="list">(<span class="keyword">group</span>, queue2, ^&#123;</span><br><span class="line">    NSLog<span class="list">(@<span class="string">"🚫正在暂停 2"</span>)</span><span class="comment">;</span></span><br><span class="line">    dispatch_suspend<span class="list">(<span class="keyword">queue2</span>)</span><span class="comment">;</span></span><br><span class="line">&#125;)</span><span class="comment">;</span></span><br><span class="line">dispatch_group_wait<span class="list">(<span class="keyword">group</span>, DISPATCH_TIME_FOREVER)</span><span class="comment">;</span></span><br><span class="line">NSLog<span class="list">(@<span class="string">"＝＝＝＝＝＝＝等待两个queue完成, 再往下进行..."</span>)</span><span class="comment">;</span></span><br><span class="line">dispatch_async<span class="list">(<span class="keyword">queue1</span>, ^&#123;</span><br><span class="line">    NSLog<span class="list">(@<span class="string">"任务 2 ： queue 1"</span>)</span><span class="comment">;</span></span><br><span class="line">&#125;)</span><span class="comment">;</span></span><br><span class="line">dispatch_async<span class="list">(<span class="keyword">queue2</span>, ^&#123;</span><br><span class="line">    NSLog<span class="list">(@<span class="string">"任务 2 ： queue 2"</span>)</span><span class="comment">;</span></span><br><span class="line">&#125;)</span><span class="comment">;</span></span><br><span class="line">NSLog<span class="list">(@<span class="string">"🔴为什么这个NSLog会在上面两个NSLog之前打印❓❓答：dispatch_suspend的作用‼️"</span>)</span><span class="comment">;</span></span><br><span class="line"></span><br><span class="line">dispatch_resume<span class="list">(<span class="keyword">queue1</span>)</span><span class="comment">;</span></span><br><span class="line">dispatch_resume<span class="list">(<span class="keyword">queue2</span>)</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>log:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">24</span> <span class="number">22</span>:<span class="number">12</span>:<span class="number">58.646</span> GCDTest[<span class="number">22178</span>:<span class="number">12407680</span>] 任务 <span class="number">1</span> ： <span class="built_in">queue</span> <span class="number">1.</span>..</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">24</span> <span class="number">22</span>:<span class="number">12</span>:<span class="number">58.646</span> GCDTest[<span class="number">22178</span>:<span class="number">12408707</span>] 任务 <span class="number">1</span> ： <span class="built_in">queue</span> <span class="number">2.</span>..</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">24</span> <span class="number">22</span>:<span class="number">12</span>:<span class="number">59.650</span> GCDTest[<span class="number">22178</span>:<span class="number">12407680</span>] ✅完成任务 <span class="number">1</span></span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">24</span> <span class="number">22</span>:<span class="number">12</span>:<span class="number">59.650</span> GCDTest[<span class="number">22178</span>:<span class="number">12408707</span>] ✅完成任务 <span class="number">2</span></span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">24</span> <span class="number">22</span>:<span class="number">12</span>:<span class="number">59.650</span> GCDTest[<span class="number">22178</span>:<span class="number">12407680</span>] 🚫正在暂停 <span class="number">1</span></span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">24</span> <span class="number">22</span>:<span class="number">12</span>:<span class="number">59.650</span> GCDTest[<span class="number">22178</span>:<span class="number">12408707</span>] 🚫正在暂停 <span class="number">2</span></span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">24</span> <span class="number">22</span>:<span class="number">12</span>:<span class="number">59.650</span> GCDTest[<span class="number">22178</span>:<span class="number">12407286</span>] ＝＝＝＝＝＝＝等待两个<span class="built_in">queue</span>完成, 再往下进行...</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">24</span> <span class="number">22</span>:<span class="number">12</span>:<span class="number">59.651</span> GCDTest[<span class="number">22178</span>:<span class="number">12407286</span>] 🔴为什么这个NSLog会在上面两个NSLog之前打印❓❓答：dispatch_suspend的作用‼️</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">24</span> <span class="number">22</span>:<span class="number">12</span>:<span class="number">59.651</span> GCDTest[<span class="number">22178</span>:<span class="number">12408707</span>] 任务 <span class="number">2</span> ： <span class="built_in">queue</span> <span class="number">1</span></span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">24</span> <span class="number">22</span>:<span class="number">12</span>:<span class="number">59.651</span> GCDTest[<span class="number">22178</span>:<span class="number">12407680</span>] 任务 <span class="number">2</span> ： <span class="built_in">queue</span> <span class="number">2</span></span><br></pre></td></tr></table></figure>
<h4 id="Dispatch_Source_（信号源)">Dispatch Source （信号源)</h4><p>GCD中除了主要的 Dispatch Queue 外，还有不太引人注目的 Dispatch Source .它是BSD系内核惯有功能kqueue的包装。kqueue 是在 XNU 内核中发生各种事件时，在应用程序编程方执行处理的技术。其 CPU 负荷非常小，尽量不占用资源。kqueue 可以说是应用程序处理 XNU 内核中发生的各种事件的方法中最优秀的一种。</p>
<p>Dispatch Source是GCD中的一个基本类型，从字面意思可称为调度源，它的作用是当有一些特定的较底层的系统事件发生时，调度源会捕捉到这些事件，然后可以做其他的逻辑处理，调度源有多种类型，分别监听对应类型的系统事件。</p>
<p>Dispatch Source 可处理的所有事件。如下表所示：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th style="text-align:center">内容</th>
</tr>
</thead>
<tbody>
<tr>
<td>DISPATCH_SOURCE_TYPE_DATA_ADD</td>
<td style="text-align:center">变量增加</td>
</tr>
<tr>
<td>DISPATCH_SOURCE_TYPE_DATA_OR</td>
<td style="text-align:center">变量OR</td>
</tr>
<tr>
<td>DISPATCH_SOURCE_TYPE_MACH_SEND</td>
<td style="text-align:center">MACH端口发送</td>
</tr>
<tr>
<td>DISPATCH_SOURCE_TYPE_MACH_RECV</td>
<td style="text-align:center">MACH端口接收</td>
</tr>
<tr>
<td>DISPATCH_SOURCE_TYPE_PROC</td>
<td style="text-align:center">监测到与进程相关的事件</td>
</tr>
<tr>
<td>DISPATCH_SOURCE_TYPE_READ</td>
<td style="text-align:center">可读取文件映像</td>
</tr>
<tr>
<td>DISPATCH_SOURCE_TYPE_SIGNAL</td>
<td style="text-align:center">接收信号</td>
</tr>
<tr>
<td>DISPATCH_SOURCE_TYPE_TIMER</td>
<td style="text-align:center">定时器</td>
</tr>
<tr>
<td>DISPATCH_SOURCE_TYPE_VNODE</td>
<td style="text-align:center">文件系统有变更</td>
</tr>
<tr>
<td>DISPATCH_SOURCE_TYPE_WRITE</td>
<td style="text-align:center">可写入文件映像</td>
</tr>
</tbody>
</table>
<p> 其中DISPATCH_SOURCE_TYPE_DATA_ADD和DISPATCH_SOURCE_TYPE_DATA_OR是常用的两个，其它用于Mac开发的比较多。</p>
<p> 在任一线程上调用它的的一个函数 dispatch_source_merge_data 后，会执行 Dispatch Source 事先定义好的句柄（可以把句柄简单理解为一个 block ）。</p>
<p>这个过程叫 Custom event ,用户事件。是 dispatch source 支持处理的一种事件。</p>
<p>例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">dispatch_source_t</span> queueSource = dispatch_source_create(DISPATCH_SOURCE_TYPE_DATA_ADD, <span class="number">0</span>, <span class="number">0</span>, dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line"> __block NSUInteger totalComplete = <span class="number">0</span>;</span><br><span class="line">dispatch_source_set_event_handler(queueSource, ^&#123;</span><br><span class="line">    <span class="comment">//当处理事件被最终执行时，计算后的数据可以通过dispatch_source_get_data来获取。</span></span><br><span class="line">    <span class="comment">//这个数据的值在每次响应事件执行后会被重置，所以totalComplete的值是最终累积的值。</span></span><br><span class="line">    NSUInteger value = dispatch_source_get_data(queueSource);</span><br><span class="line">    totalComplete += value;</span><br><span class="line">    NSLog(@<span class="string">"进度：%@"</span>, @((CGFloat)totalComplete/<span class="number">100</span>));</span><br><span class="line">&#125;);</span><br><span class="line">  <span class="comment">/*</span><br><span class="line">  分派源创建时默认处于暂停状态，在分派源分派处理程序之前必须先恢复。</span><br><span class="line">  因为忘记恢复分派源的状态而产生bug是常见的事儿。</span><br><span class="line">  恢复的方法是调用 dispatch_resume :</span><br><span class="line">  */</span></span><br><span class="line"> dispatch_resume(queueSource);</span><br><span class="line"> </span><br><span class="line"> <span class="comment">/*</span><br><span class="line">  在每次循环中执行加1操作。也可以传递已处理记录的数目或已写入的字节数。</span><br><span class="line">  在任何线程中都可以调用 dispatch_source_merge_data 。</span><br><span class="line">  需要注意的是，不可以传递0值(事件不会被触发)，同样也不可以传递负数(会无穷大)。</span><br><span class="line">  */</span></span><br><span class="line"> <span class="keyword">dispatch_queue_t</span> <span class="built_in">queue</span> = dispatch_queue_create(<span class="string">"com.sourcequeue"</span>, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line"> <span class="keyword">for</span> (NSUInteger index = <span class="number">0</span>; index &lt; <span class="number">10</span>; index++) &#123;</span><br><span class="line">     dispatch_async(<span class="built_in">queue</span>, ^&#123;</span><br><span class="line">         dispatch_source_merge_data(queueSource, <span class="number">1</span>);</span><br><span class="line">         [NSThread sleepForTimeInterval:<span class="number">1</span>];</span><br><span class="line">     &#125;);</span><br><span class="line"> &#125;</span><br><span class="line"> NSLog(@<span class="string">"queue for 循环 完成"</span>);</span><br></pre></td></tr></table></figure>
<p>log:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">25</span> <span class="number">09</span>:<span class="number">35</span>:<span class="number">20.128</span> GCDTest[<span class="number">22525</span>:<span class="number">12717227</span>] <span class="built_in">queue</span> <span class="keyword">for</span> 循环 完成</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">25</span> <span class="number">09</span>:<span class="number">35</span>:<span class="number">20.129</span> GCDTest[<span class="number">22525</span>:<span class="number">12718440</span>] 进度：<span class="number">0.3</span></span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">25</span> <span class="number">09</span>:<span class="number">35</span>:<span class="number">20.129</span> GCDTest[<span class="number">22525</span>:<span class="number">12718440</span>] 进度：<span class="number">0.4</span></span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">25</span> <span class="number">09</span>:<span class="number">35</span>:<span class="number">20.129</span> GCDTest[<span class="number">22525</span>:<span class="number">12718440</span>] 进度：<span class="number">0.6</span></span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">25</span> <span class="number">09</span>:<span class="number">35</span>:<span class="number">20.130</span> GCDTest[<span class="number">22525</span>:<span class="number">12718440</span>] 进度：<span class="number">0.9</span></span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">25</span> <span class="number">09</span>:<span class="number">35</span>:<span class="number">20.130</span> GCDTest[<span class="number">22525</span>:<span class="number">12718440</span>] 进度：<span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>可以看到 0.1~1 并没有全部打印，而是跳过：</p>
<p>这是 DispatchSource 能通过合并事件的方式确保在高负载下正常工作 的能力</p>
<p>在同一时间，只有一个处理 block 的实例被分配，如果这个处理方法还没有执行完毕，另一个事件就发生了，事件会以指定方式（ADD或 OR）进行累积。DispatchSource能通过合并事件（block）的方式确保在高负载下正常工作。当处理事件被最终执行时，计算后的数据可以通过 dispatch_source_get_data 来获取。这个数据的值在每次响应时间执行后会被重置，所以上面的例子中进度条 totalComplete 的值是最终积累的值，而 block 不是每次都执行的。但能确保进度条能从0.0到1.0的正常执行。</p>
<h4 id="Dispatch_Semaphore_信号量">Dispatch Semaphore 信号量</h4><p>为了展示作用，举个反例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dispatch_queue_t</span> <span class="built_in">queue</span> = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</span><br><span class="line"> NSMutableArray *<span class="built_in">array</span> = [[NSMutableArray alloc] init];</span><br><span class="line"> <span class="keyword">dispatch_group_t</span> group = dispatch_group_create();</span><br><span class="line"> <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; <span class="number">100000</span>; ++i) &#123;</span><br><span class="line">     dispatch_group_async(group, <span class="built_in">queue</span>, ^&#123;</span><br><span class="line">         [<span class="built_in">array</span> addObject:[NSNumber numberWithInt:i]];</span><br><span class="line">     &#125;);</span><br><span class="line"> &#125;</span><br><span class="line"> dispatch_group_wait(group, DISPATCH_TIME_FOREVER);</span><br><span class="line"> NSLog(@<span class="string">"%@"</span>,  @([<span class="built_in">array</span> count]));</span><br></pre></td></tr></table></figure>
<p>然后就发生了崩溃：</p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">malloc: *** error <span class="keyword">for</span> object <span class="number">0x7f88ed03ca00</span>: pointer being freed was <span class="operator">not</span> allocated</span><br><span class="line">*** <span class="built_in">set</span> <span class="operator">a</span> <span class="built_in">breakpoint</span> <span class="operator">in</span> malloc_error_break <span class="built_in">to</span> debug</span><br></pre></td></tr></table></figure>
<p>这种资源抢夺的情况，一般的做法是使用串行队列，或者像下面一样的同步队列，得以解决：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dispatch_queue_t</span> <span class="built_in">queue</span> = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</span><br><span class="line">NSMutableArray *<span class="built_in">array</span> = [[NSMutableArray alloc] init];</span><br><span class="line"><span class="keyword">dispatch_group_t</span> group = dispatch_group_create();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; <span class="number">1000</span>; ++i) &#123;</span><br><span class="line">    dispatch_sync(<span class="built_in">queue</span>, ^&#123;</span><br><span class="line">        [<span class="built_in">array</span> addObject:[NSNumber numberWithInt:i]];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">dispatch_group_wait(group, DISPATCH_TIME_FOREVER);</span><br><span class="line">NSLog(@<span class="string">"%@"</span>,  @([<span class="built_in">array</span> count]));</span><br></pre></td></tr></table></figure>
<p>dispatch_semaphore_t 的作用之一就是解决这种资源抢夺的情况,下面展示下展示使用 dispatch_semaphore_t 的解决方案：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dispatch_queue_t</span> <span class="built_in">queue</span> = dispatch_queue_create(<span class="string">"com.semaphore"</span>, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line"><span class="keyword">dispatch_semaphore_t</span> semaphore = dispatch_semaphore_create(<span class="number">1</span>);</span><br><span class="line">NSMutableArray *<span class="built_in">array</span> = [[NSMutableArray alloc] init];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">    dispatch_async(<span class="built_in">queue</span>, ^&#123;</span><br><span class="line">        dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</span><br><span class="line">        NSLog(@<span class="string">"🔴%@  index = %d"</span>,[NSThread currentThread],i);</span><br><span class="line">        [<span class="built_in">array</span> addObject:@(i)];</span><br><span class="line">        dispatch_semaphore_signal(semaphore);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">dispatch_barrier_async(<span class="built_in">queue</span>, ^&#123;</span><br><span class="line">    NSLog(@<span class="string">"🔴类名与方法名：%s（在第%d行），描述：%@"</span>, __PRETTY_FUNCTION__, __LINE__, @([<span class="built_in">array</span> count]));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>测试,设置：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dispatch_semaphore_t</span> semaphore = dispatch_semaphore_create(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p>可以发现 程序会永远停留在：</p>
<figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">等待<span class="keyword">Dispatch</span> Semaphore</span><br><span class="line">一直等待，直到<span class="keyword">Dispatch</span> Semaphore的计数值达到大于等于<span class="number">1</span></span><br><span class="line">dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</span><br></pre></td></tr></table></figure>
<p><a href="http://www.cnblogs.com/snailHL/p/3906112.html" target="_blank" rel="external">关于信号量这里有非常详细的解释</a></p>
<p>dispatch_semaphore是GCD用来同步的一种方式，与他相关的共有三个函数，分别是</p>
<p>dispatch_semaphore_create，dispatch_semaphore_signal，dispatch_semaphore_wait。</p>
<p>下面我们逐一介绍三个函数：</p>
<p>①dispatch_semaphore_create的声明为：</p>
<pre><code><span class="keyword">dispatch_semaphore_t</span>  dispatch_semaphore_create(<span class="keyword">long</span> value);

传入的参数为<span class="keyword">long</span>，输出一个<span class="keyword">dispatch_semaphore_t</span>类型且值为value的信号量。

值得注意的是，这里的传入的参数value必须大于或等于<span class="number">0</span>，否则dispatch_semaphore_create会返回<span class="literal">NULL</span>。

（关于信号量，我就不在这里累述了，网上很多介绍这个的。我们这里主要讲一下dispatch_semaphore这三个函数的用法）。
</code></pre><p>②dispatch_semaphore_signal的声明为：</p>
<pre><code><span class="keyword">long</span> dispatch_semaphore_signal(dispatch_semaphore_t dsema)

这个函数会使传入的信号量dsema的值加<span class="number">1</span>；（至于返回值，待会儿再讲）
dispatch_semaphore_signal的返回值为<span class="keyword">long</span>类型，当返回值为<span class="number">0</span>时表示当前并没有线程等待其处理的信号量，其处理

的信号量的值加<span class="number">1</span>即可。当返回值不为<span class="number">0</span>时，表示其当前有（一个或多个）线程等待其处理的信号量，并且该函数唤醒了一

个等待的线程（当线程有优先级时，唤醒优先级最高的线程；否则随机唤醒）。

dispatch_semaphore_wait的返回值也为<span class="keyword">long</span>型。当其返回<span class="number">0</span>时表示在timeout之前，该函数所处的线程被成功唤醒。

当其返回不为<span class="number">0</span>时，表示timeout发生。
</code></pre><p>③dispatch_semaphore_wait的声明为：</p>
<pre><code>long dispatch_semaphore_wait(dispatch_semaphore_t dsema, dispatch_time_t <span class="keyword">timeout</span>)；

这个函数会使传入的信号量dsema的值减<span class="number">1</span>；

这个函数的作用是这样的，如果dsema信号量的值大于<span class="number">0</span>，该函数所处线程就继续执行下面的语句，并且将信号量的值减<span class="number">1</span>；

如果desema的值为<span class="number">0</span>，那么这个函数就阻塞当前线程等待<span class="keyword">timeout</span>（注意<span class="keyword">timeout</span>的类型为dispatch_time_t，

不能直接传入整形或float型数），如果等待的期间desema的值被dispatch_semaphore_signal函数加<span class="number">1</span>了，

且该函数（即dispatch_semaphore_wait）所处线程获得了信号量，那么就继续向下执行并将信号量减<span class="number">1</span>。

如果等待期间没有获取到信号量或者信号量的值一直为<span class="number">0</span>，那么等到<span class="keyword">timeout</span>时，其所处线程自动执行其后语句。
</code></pre><p>关于信号量，这里有一个很形象的解释：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">停车场剩余<span class="number">4</span>个车位，那么即使同时来了四辆车也能停的下。如果此时来了五辆车，那么就有一辆需要等待。</span><br><span class="line">信号量的值就相当于剩余车位的数目，dispatch_semaphore_<span class="built_in">wait</span>函数就相当于来了一辆车，dispatch_semaphore_signal</span><br><span class="line">就相当于走了一辆车。停车位的剩余数目在初始化的时候就已经指明了（dispatch_semaphore_create（long value）），</span><br><span class="line">调用一次dispatch_semaphore_signal，剩余的车位就增加一个；调用一次dispatch_semaphore_<span class="built_in">wait</span>剩余车位就减少一个；</span><br><span class="line">当剩余车位为<span class="number">0</span>时，再来车（即调用dispatch_semaphore_<span class="built_in">wait</span>）就只能等待。有可能同时有几辆车等待一个停车位。有些车主</span><br><span class="line">没有耐心，给自己设定了一段等待时间，这段时间内等不到停车位就走了，如果等到了就开进去停车。而有些车主就像把车停在这，</span><br><span class="line">所以就一直等下去。</span><br></pre></td></tr></table></figure>
<p>本文到此就结束了</p>
<hr>
<p>参考：</p>
<p><a href="https://github.com/ChenYilong/ParseSourceCodeStudy/blob/master/01_Parse的多线程处理思路/Parse的底层多线程处理思路.md" target="_blank" rel="external">Parse源码浅析系列（一）—Parse的底层多线程处理思路：GCD高级用法</a></p>
<p><a href="http://www.cnblogs.com/snailHL/p/3906112.html" target="_blank" rel="external">关于dispatch_semaphore的使用</a></p>
<p><a href="http://tutuge.me/2015/04/03/something-about-gcd/#避免死锁！" target="_blank" rel="external">GCD使用经验与技巧浅谈</a></p>
<p><a href="http://blog.leichunfeng.com/blog/2015/07/29/ios-concurrency-programming-operation-queues/#jtss-tsina" target="_blank" rel="external">iOS 并发编程之 Operation Queues</a></p>
<p><a href="http://www.jianshu.com/p/0b0d9b1f1f19" target="_blank" rel="external">关于iOS多线程，你看我就够了</a></p>
<p><a href="http://www.jianshu.com/p/8ed06312d8bd" target="_blank" rel="external">小笨狼漫谈多线程：NSThread</a></p>
</span>
      
    </div>

    <footer class="post-footer">
      

      
        <div class="post-nav">
          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/03/05/bubble-sort/" rel="prev">排序算法之冒泡排序和选择排序</a>
            
          </div>

          <div class="post-nav-next post-nav-item">
            
              <a href="/2016/08/16/RegularExpression/" rel="next">iOS 正则表达式</a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>

 </div>

        

        
          <div class="comments" id="comments">
            
          </div>
        
      </div>

      
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" src="/images/default_avatar.jpg" alt="Share" itemprop="image"/>
          <p class="site-author-name" itemprop="name">Share</p>
        </div>
        <p class="site-description motion-element" itemprop="description">just do it !</p>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">12</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          <div class="site-state-item site-state-categories">
            
              <span class="site-state-item-count">0</span>
              <span class="site-state-item-name">分类</span>
              
          </div>

          <div class="site-state-item site-state-tags">
            <a href="/tags">
              <span class="site-state-item-count">0</span>
              <span class="site-state-item-name">标签</span>
              </a>
          </div>

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        <div class="links-of-author motion-element">
          
        </div>

      </section>

      
        <section class="post-toc-wrap sidebar-panel-active">
          <div class="post-toc-indicator-top post-toc-indicator"></div>
          <div class="post-toc">
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#iOS多线程"><span class="nav-number">1.</span> <span class="nav-text">iOS多线程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#前言"><span class="nav-number">1.1.</span> <span class="nav-text">前言</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#基本概念"><span class="nav-number">1.2.</span> <span class="nav-text">基本概念</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#串行_和_并发"><span class="nav-number">1.2.1.</span> <span class="nav-text">串行 和 并发</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#同步_和_异步"><span class="nav-number">1.2.2.</span> <span class="nav-text">同步 和 异步</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#队列_和_线程"><span class="nav-number">1.2.3.</span> <span class="nav-text">队列 和 线程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#iOS中的几种多线程类型"><span class="nav-number">1.2.4.</span> <span class="nav-text">iOS中的几种多线程类型</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Pthreads"><span class="nav-number">1.3.</span> <span class="nav-text">Pthreads</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#NSThread"><span class="nav-number">1.4.</span> <span class="nav-text">NSThread</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#线程的创建"><span class="nav-number">1.4.1.</span> <span class="nav-text">线程的创建</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#线程操作"><span class="nav-number">1.4.2.</span> <span class="nav-text">线程操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#启动"><span class="nav-number">1.4.3.</span> <span class="nav-text">启动</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#睡眠"><span class="nav-number">1.4.4.</span> <span class="nav-text">睡眠</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#取消"><span class="nav-number">1.4.5.</span> <span class="nav-text">取消</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#退出"><span class="nav-number">1.4.6.</span> <span class="nav-text">退出</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#主线程和当前线程"><span class="nav-number">1.4.7.</span> <span class="nav-text">主线程和当前线程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#线程优先级"><span class="nav-number">1.4.8.</span> <span class="nav-text">线程优先级</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#线程通讯"><span class="nav-number">1.4.9.</span> <span class="nav-text">线程通讯</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#线程通知"><span class="nav-number">1.4.10.</span> <span class="nav-text">线程通知</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#NSThread的简单使用"><span class="nav-number">1.4.11.</span> <span class="nav-text">NSThread的简单使用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#结束线程"><span class="nav-number">1.4.12.</span> <span class="nav-text">结束线程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#NSThread的一个小例子"><span class="nav-number">1.4.13.</span> <span class="nav-text">NSThread的一个小例子</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#NSOperation"><span class="nav-number">1.5.</span> <span class="nav-text">NSOperation</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#NSInvocationOperation"><span class="nav-number">1.5.1.</span> <span class="nav-text">NSInvocationOperation</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#NSBlockOperation"><span class="nav-number">1.5.2.</span> <span class="nav-text">NSBlockOperation</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#NSOperationQueue"><span class="nav-number">1.5.3.</span> <span class="nav-text">NSOperationQueue</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#自定义Operation"><span class="nav-number">1.5.4.</span> <span class="nav-text">自定义Operation</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#GCD"><span class="nav-number">1.6.</span> <span class="nav-text">GCD</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#创建队列"><span class="nav-number">1.6.1.</span> <span class="nav-text">创建队列</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#主队列"><span class="nav-number">1.6.1.1.</span> <span class="nav-text">主队列</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#自定义的队列"><span class="nav-number">1.6.1.2.</span> <span class="nav-text">自定义的队列</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#创建任务"><span class="nav-number">1.6.1.3.</span> <span class="nav-text">创建任务</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#队列组"><span class="nav-number">1.6.2.</span> <span class="nav-text">队列组</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#创建队列-1"><span class="nav-number">1.6.2.1.</span> <span class="nav-text">创建队列</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#监听任务组事件的执行完毕"><span class="nav-number">1.6.2.2.</span> <span class="nav-text">监听任务组事件的执行完毕</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#dispatch_once"><span class="nav-number">1.6.2.3.</span> <span class="nav-text">dispatch_once</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#dispatch_after"><span class="nav-number">1.6.2.4.</span> <span class="nav-text">dispatch_after</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#dispatch_apply"><span class="nav-number">1.6.2.5.</span> <span class="nav-text">dispatch_apply</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#dispatch_barrier_async"><span class="nav-number">1.6.2.6.</span> <span class="nav-text">dispatch_barrier_async</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#暂停与恢复"><span class="nav-number">1.6.2.7.</span> <span class="nav-text">暂停与恢复</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Dispatch_Source_（信号源)"><span class="nav-number">1.6.3.</span> <span class="nav-text">Dispatch Source （信号源)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Dispatch_Semaphore_信号量"><span class="nav-number">1.6.4.</span> <span class="nav-text">Dispatch Semaphore 信号量</span></a></li></ol></li></ol></li></ol></div>
            
          </div>
          <div class="post-toc-indicator-bottom post-toc-indicator"></div>
        </section>
      

    </div>
  </aside>


    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner"> <div class="copyright" >
  
  &copy; &nbsp;  2015 - 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="icon-next-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Share</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>


 </div>
    </footer>

    <div class="back-to-top"></div>
  </div>

  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  
  
    
    

  


  
  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script>
  <script type="text/javascript" src="/js/fancy-box.js?v=0.4.5.1"></script>


  <script type="text/javascript" src="/js/helpers.js?v=0.4.5.1"></script>
  

  <script type="text/javascript" src="/vendors/velocity/velocity.min.js"></script>
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js"></script>

  <script type="text/javascript" src="/js/motion_global.js?v=0.4.5.1" id="motion.global"></script>




  <script type="text/javascript" src="/js/nav-toggle.js?v=0.4.5.1"></script>
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  
<script type="text/javascript" src="/js/bootstrap.scrollspy.js?v=0.4.5.1" id="bootstrap.scrollspy.custom"></script>


<script type="text/javascript" id="sidebar.toc.highlight">
  $(document).ready(function () {
    var tocSelector = '.post-toc';
    var $tocSelector = $(tocSelector);
    var activeCurrentSelector = '.active-current';

    $tocSelector
      .on('activate.bs.scrollspy', function () {
        var $currentActiveElement = $(tocSelector + ' .active').last();

        removeCurrentActiveClass();
        $currentActiveElement.addClass('active-current');

        $tocSelector[0].scrollTop = $currentActiveElement.position().top;
      })
      .on('clear.bs.scrollspy', function () {
        removeCurrentActiveClass();
      });

    function removeCurrentActiveClass () {
      $(tocSelector + ' ' + activeCurrentSelector)
        .removeClass(activeCurrentSelector.substring(1));
    }

    function processTOC () {
      getTOCMaxHeight();
      toggleTOCOverflowIndicators();
    }

    function getTOCMaxHeight () {
      var height = $('.sidebar').height() -
                   $tocSelector.position().top -
                   $('.post-toc-indicator-bottom').height();

      $tocSelector.css('height', height);

      return height;
    }

    function toggleTOCOverflowIndicators () {
      tocOverflowIndicator(
        '.post-toc-indicator-top',
        $tocSelector.scrollTop() > 0 ? 'show' : 'hide'
      );

      tocOverflowIndicator(
        '.post-toc-indicator-bottom',
        $tocSelector.scrollTop() >= $tocSelector.find('ol').height() - $tocSelector.height() ? 'hide' : 'show'
      )
    }

    $(document).on('sidebar.motion.complete', function () {
      processTOC();
    });

    $('body').scrollspy({ target: tocSelector });
    $(window).on('resize', function () {
      if ( $('.sidebar').hasClass('sidebar-active') ) {
        processTOC();
      }
    });

    onScroll($tocSelector);

    function onScroll (element) {
      element.on('mousewheel DOMMouseScroll', function (event) {
          var oe = event.originalEvent;
          var delta = oe.wheelDelta || -oe.detail;

          this.scrollTop += ( delta < 0 ? 1 : -1 ) * 30;
          event.preventDefault();

          toggleTOCOverflowIndicators();
      });
    }

    function tocOverflowIndicator (indicator, action) {
      var $indicator = $(indicator);
      var opacity = action === 'show' ? 0.4 : 0;
      $indicator.velocity ?
        $indicator.velocity('stop').velocity({
          opacity: opacity
        }, { duration: 100 }) :
        $indicator.stop().animate({
          opacity: opacity
        }, 100);
    }

  });
</script>

<script type="text/javascript" id="sidebar.nav">
  $(document).ready(function () {
    var html = $('html');
    var TAB_ANIMATE_DURATION = 200;
    var hasVelocity = $.isFunction(html.velocity);

    $('.sidebar-nav li').on('click', function () {
      var item = $(this);
      var activeTabClassName = 'sidebar-nav-active';
      var activePanelClassName = 'sidebar-panel-active';
      if (item.hasClass(activeTabClassName)) {
        return;
      }

      var currentTarget = $('.' + activePanelClassName);
      var target = $('.' + item.data('target'));

      hasVelocity ?
        currentTarget.velocity('transition.slideUpOut', TAB_ANIMATE_DURATION, function () {
          target
            .velocity('stop')
            .velocity('transition.slideDownIn', TAB_ANIMATE_DURATION)
            .addClass(activePanelClassName);
        }) :
        currentTarget.animate({ opacity: 0 }, TAB_ANIMATE_DURATION, function () {
          currentTarget.hide();
          target
            .stop()
            .css({'opacity': 0, 'display': 'block'})
            .animate({ opacity: 1 }, TAB_ANIMATE_DURATION, function () {
              currentTarget.removeClass(activePanelClassName);
              target.addClass(activePanelClassName);
            });
        });

      item.siblings().removeClass(activeTabClassName);
      item.addClass(activeTabClassName);
    });

    $('.post-toc a').on('click', function (e) {
      e.preventDefault();
      var targetSelector = escapeSelector(this.getAttribute('href'));
      var offset = $(targetSelector).offset().top;
      hasVelocity ?
        html.velocity('stop').velocity('scroll', {
          offset: offset  + 'px',
          mobileHA: false
        }) :
        $('html, body').stop().animate({
          scrollTop: offset
        }, 500);
    });

    // Expand sidebar on post detail page by default, when post has a toc.
    var $tocContent = $('.post-toc-content');
    if (isDesktop() && CONFIG.sidebar === 'post') {
      if ($tocContent.length > 0 && $tocContent.html().trim().length > 0) {
        displaySidebar();
      }
    }
  });
</script>



  <script type="text/javascript">
    $(document).ready(function () {
      if (CONFIG.sidebar === 'always') {
        displaySidebar();
      }
      if (isMobile()) {
        FastClick.attach(document.body);
      }
    });
  </script>

  
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
      processEscapes: true,
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
  });
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for (i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>


  
  

  
  <script type="text/javascript" src="/js/lazyload.js"></script>
  <script type="text/javascript">
    $(function () {
      $("#posts").find('img').lazyload({
        placeholder: "/images/loading.gif",
        effect: "fadeIn"
      });
    });
  </script>
</body>
</html>
