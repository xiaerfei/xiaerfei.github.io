
 <!DOCTYPE HTML>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
  
    <title>iOS多线程 | 二哥的博客</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="夏二飞">
    

    
    <meta name="description" content="iOS多线程前言在这篇文章中我整理了iOS多线程开发需要的一些知识点、方法和事项。本文主要讲述三部分 NSThread、Operation 和 GCD。本文不算是原创，是一些我觉得写的比较有质量文章的综合，文中摘抄了这些文章中的部分内容，在文中和文章末尾我已标注出处，之所以要摘抄是因为在需要之时，打开URL 是404 😂😂😂。我综合了这些文中给自己学习之用，也给大家方便查看之用，如有错误之处">
<meta property="og:type" content="article">
<meta property="og:title" content="iOS多线程">
<meta property="og:url" content="http://yoursite.com/2016/09/19/Multi-thread/index.html">
<meta property="og:site_name" content="二哥的博客">
<meta property="og:description" content="iOS多线程前言在这篇文章中我整理了iOS多线程开发需要的一些知识点、方法和事项。本文主要讲述三部分 NSThread、Operation 和 GCD。本文不算是原创，是一些我觉得写的比较有质量文章的综合，文中摘抄了这些文章中的部分内容，在文中和文章末尾我已标注出处，之所以要摘抄是因为在需要之时，打开URL 是404 😂😂😂。我综合了这些文中给自己学习之用，也给大家方便查看之用，如有错误之处">
<meta property="og:updated_time" content="2016-09-19T00:00:30.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="iOS多线程">
<meta name="twitter:description" content="iOS多线程前言在这篇文章中我整理了iOS多线程开发需要的一些知识点、方法和事项。本文主要讲述三部分 NSThread、Operation 和 GCD。本文不算是原创，是一些我觉得写的比较有质量文章的综合，文中摘抄了这些文章中的部分内容，在文中和文章末尾我已标注出处，之所以要摘抄是因为在需要之时，打开URL 是404 😂😂😂。我综合了这些文中给自己学习之用，也给大家方便查看之用，如有错误之处">

    
    <link rel="alternative" href="/atom.xml" title="二哥的博客" type="application/atom+xml">
    
    
    
    <link rel="stylesheet" href="/css/style.css" type="text/css">
</head>

  <body>
    <header>
      
<div>
		
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="二哥的博客">二哥的博客</a></h1>
				<h2 class="blog-motto"></h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="Menu">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">Home</a></li>
					
						<li><a href="/archives">Archives</a></li>
					
						<li><a href="/about">About</a></li>
					
					<li>
 					
					<form class="search" action="//google.com/search" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="search" id="search" name="q" autocomplete="off" maxlength="20" placeholder="搜索" />
						<input type="hidden" name="q" value="site:yoursite.com">
					</form>
					
					</li>
				</ul>
			</nav>			
</div>
    </header>
    <div id="container">
      <div id="main" class="post" itemscope itemprop="blogPost">
  
	<article itemprop="articleBody"> 
		<header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2016/09/19/Multi-thread/" title="iOS多线程" itemprop="url">iOS多线程</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="夏二飞" target="_blank" itemprop="author">夏二飞</a>
		
  <p class="article-time">
    <time datetime="2016-09-19T00:00:30.000Z" itemprop="datePublished"> 发布于 2016-09-19</time>
    
  </p>
</header>
	<div class="article-content">
		
		<div id="toc" class="toc-article">
			<strong class="toc-title">文章目录</strong>
		
			<ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#iOS多线程"><span class="toc-number">1.</span> <span class="toc-text">iOS多线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#前言"><span class="toc-number">1.1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#基本概念"><span class="toc-number">1.2.</span> <span class="toc-text">基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#串行_和_并发"><span class="toc-number">1.2.1.</span> <span class="toc-text">串行 和 并发</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#同步_和_异步"><span class="toc-number">1.2.2.</span> <span class="toc-text">同步 和 异步</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#队列_和_线程"><span class="toc-number">1.2.3.</span> <span class="toc-text">队列 和 线程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#iOS中的几种多线程类型"><span class="toc-number">1.2.4.</span> <span class="toc-text">iOS中的几种多线程类型</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Pthreads"><span class="toc-number">1.3.</span> <span class="toc-text">Pthreads</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#NSThread"><span class="toc-number">1.4.</span> <span class="toc-text">NSThread</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#线程的创建"><span class="toc-number">1.4.1.</span> <span class="toc-text">线程的创建</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#线程操作"><span class="toc-number">1.4.2.</span> <span class="toc-text">线程操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#启动"><span class="toc-number">1.4.3.</span> <span class="toc-text">启动</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#睡眠"><span class="toc-number">1.4.4.</span> <span class="toc-text">睡眠</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#取消"><span class="toc-number">1.4.5.</span> <span class="toc-text">取消</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#退出"><span class="toc-number">1.4.6.</span> <span class="toc-text">退出</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#主线程和当前线程"><span class="toc-number">1.4.7.</span> <span class="toc-text">主线程和当前线程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#线程优先级"><span class="toc-number">1.4.8.</span> <span class="toc-text">线程优先级</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#线程通讯"><span class="toc-number">1.4.9.</span> <span class="toc-text">线程通讯</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#线程通知"><span class="toc-number">1.4.10.</span> <span class="toc-text">线程通知</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#NSThread的简单使用"><span class="toc-number">1.4.11.</span> <span class="toc-text">NSThread的简单使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#结束线程"><span class="toc-number">1.4.12.</span> <span class="toc-text">结束线程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#NSThread的一个小例子"><span class="toc-number">1.4.13.</span> <span class="toc-text">NSThread的一个小例子</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#NSOperation"><span class="toc-number">1.5.</span> <span class="toc-text">NSOperation</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#NSInvocationOperation"><span class="toc-number">1.5.1.</span> <span class="toc-text">NSInvocationOperation</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#NSBlockOperation"><span class="toc-number">1.5.2.</span> <span class="toc-text">NSBlockOperation</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#NSOperationQueue"><span class="toc-number">1.5.3.</span> <span class="toc-text">NSOperationQueue</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#自定义Operation"><span class="toc-number">1.5.4.</span> <span class="toc-text">自定义Operation</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GCD"><span class="toc-number">1.6.</span> <span class="toc-text">GCD</span></a></li></ol></li></ol>
		
		</div>
		
		<h2 id="iOS多线程">iOS多线程</h2><h3 id="前言">前言</h3><p>在这篇文章中我整理了iOS多线程开发需要的一些知识点、方法和事项。本文主要讲述三部分 NSThread、Operation 和 GCD。<br><br>本文不算是原创，是一些我觉得写的比较有质量文章的综合，文中摘抄了这些文章中的部分内容，在文中和文章末尾我已标注出处，之所以要摘抄是因为在需要之时，打开URL 是404 😂😂😂。我综合了这些文中给自己学习之用，也给大家方便查看之用，如有错误之处，见谅，不过欢迎指出。</p>
<h3 id="基本概念">基本概念</h3><p>我们先了解一线iOS多线程的一些基本概念(<a href="http://blog.leichunfeng.com/blog/2015/07/29/ios-concurrency-programming-operation-queues/#jtss-tsina" target="_blank" rel="external">这些基本概念参考了这里</a>)：</p>
<ul>
<li>进程（process）:指的是一个正在运行中的可执行文件。每一个进程都拥有独立的虚拟内存空间和系统资源，包括端口权限等，且至少包含一个主线程和任意数量的辅助线程（说白了就是：用于指代一个可执行程序，他可以包含多个线程）。另外，当一个进程的主线程退出时，这个进程就结束了；</li>
<li>线程（thread）:指的是一个独立的代码执行路径，也就是说线程是代码执行路径的最小分支。在 iOS 中，线程的底层实现是基于 <a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/Multithreading/Introduction/Introduction.html" target="_blank" rel="external">POSIX threads API</a> 的，也就是我们常说的 pthreads ；</li>
<li>任务（task），指的是我们需要执行的工作，是一个抽象的概念，用通俗的话说，就是一段代码。</li>
</ul>
<p><br></p>
<h4 id="串行_和_并发">串行 和 并发</h4><p>从本质上来说，串行和并发的主要区别在于允许同时执行的任务数量。</p>
<ul>
<li>串行：指的是一次只能执行一个任务，必须等一个任务执行完成后才能执行下一个任务；</li>
<li>并发：指的是允许多个任务在一段时间内同时执行。</li>
</ul>
<h4 id="同步_和_异步">同步 和 异步</h4><p>同步和异步操作的主要区别在于是否等待操作执行完成，亦即是否阻塞当前线程。</p>
<ul>
<li>同步操作：等待操作执行完成后再继续执行接下来的代码；</li>
<li>异步操作：它会在调用后立即返回，不会等待操作的执行结果。</li>
</ul>
<p><br></p>
<h4 id="队列_和_线程">队列 和 线程</h4><p>在 iOS 中，有两种不同类型的队列，分别是串行队列和并发队列。正如我们上面所说的，串行队列一次只能执行一个任务，而并发队列则可以允许多个任务同时执行。iOS 系统就是使用这些队列来进行任务调度的，它会根据调度任务的需要和系统当前的负载情况动态地创建和销毁线程，而不需要我们手动地管理</p>
<h4 id="iOS中的几种多线程类型">iOS中的几种多线程类型</h4><p>iOS 中其实目前有 4 种多线程，他们分别是：</p>
<ul>
<li>Pthreads：非常底层的东东；</li>
<li>NSThread：封装性最差，最偏向于底层，主要基于thread使用；</li>
<li>GCD：基于C的API，直接使用比较方便，主要基于task使用；</li>
<li>NSOperation &amp; NSOperationQueue：基于GCD封装的NSObject对象，对于复杂的多线程项目使用比较方便，主要基于队列使用。</li>
</ul>
<hr>
<p>下面开始介绍这几种类型<br><br></p>
<h3 id="Pthreads">Pthreads</h3><p>POSIX线程（POSIX threads），简称Pthreads，是线程的POSIX标准。该标准定义了创建和操纵线程的一整套API。在类Unix操作系统（Unix、Linux、Mac OS X等）中，都使用Pthreads作为操作系统的线程。<br><br>这个需要自己管理线程的生命周期，创建和销毁，写起来也是相当麻烦，若非是写一些非常底层的几乎是用不到的，这里暂时略过，如需要可自行去理解。<br><br></p>
<h3 id="NSThread">NSThread</h3><p>NSThread是苹果封装的，并且是面向对象的，这对我们来说就简便了许多，但是它的生命周期还是需要我们手动管理的；NSThread除Pthreads之外唯一一个基于线程封装的，每一个NSThread对象代表着一个线程。(<a href="http://www.jianshu.com/p/8ed06312d8bd" target="_blank" rel="external">这部分参考了这里</a>)<br><br></p>
<h4 id="线程的创建">线程的创建</h4><p>NSThread提供了2种创建线程的方法:</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="typename">void</span>)<span class="string">detachNewThreadSelector:</span>(SEL)selector <span class="string">toTarget:</span>(id)target <span class="string">withObject:</span>(nullable id)argument;</span><br><span class="line">- (instancetype)<span class="string">initWithTarget:</span>(id)target <span class="string">selector:</span>(SEL)selector <span class="string">object:</span>(nullable id)argument</span><br></pre></td></tr></table></figure>
<ul>
<li>detach方法直接创建并启动一个线程去Selector，由于没有返回值，如果需要获取新创建的Thread，需要在执行的Selector中调用-[NSThread currentThread]获取;</li>
<li>init方法初始化线程并返回，线程的入口函数由Selector传入。线程创建出来之后需要手动调用-start方法启动;<br><br><h4 id="线程操作">线程操作</h4>NSThread给线程提供的主要操作方法有启动，睡眠，取消，退出<br><br><h4 id="启动">启动</h4>使用init方法将线程创建出来之后，线程并不会立即运行，需要手动调用-start方法才会启动线程：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)<span class="function">start <span class="title">NS_AVAILABLE</span><span class="params">(<span class="number">10</span>_5, <span class="number">2</span>_0)</span></span>;</span><br></pre></td></tr></table></figure>
<p>在启动之前可以设置 线程的名称(当然启动后也可以在Selecter 中设置也可以)：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (nullable, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *name <span class="built_in">NS_AVAILABLE</span>(<span class="number">10</span>_5, <span class="number">2</span>_0);</span><br></pre></td></tr></table></figure>
<p>不过优先级 需要在 start 之前 设置，否则会无效：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@<span class="function">property NSQualityOfService qualityOfService <span class="title">NS_AVAILABLE</span><span class="params">(<span class="number">10</span>_10, <span class="number">8</span>_0)</span></span>;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h4 id="睡眠">睡眠</h4><p>NSThread提供了2个让线程睡眠的方法:</p>
<ul>
<li>根据NSDate传入睡眠时间；</li>
<li>直接传入NSTimeInterval</li>
</ul>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="tag">void</span>)<span class="rule"><span class="attribute">sleepUntilDate</span>:<span class="value">(NSDate *)date</span></span>;</span><br><span class="line">+ (<span class="tag">void</span>)<span class="rule"><span class="attribute">sleepForTimeInterval</span>:<span class="value">(NSTimeInterval)ti</span></span>;</span><br></pre></td></tr></table></figure>
<p>这里讲一下  sleepUntilDate:  和   runloop的runUntilDate: 上的一些区别：</p>
<ul>
<li>sleepUntilDate:相当于执行一个sleep的任务。在执行过程中，即使有其他任务传入runloop，runloop也不会立即响应，必须sleep任务完成之后，才会响应其他任务；</li>
<li>runUntilDate:虽然会阻塞线程，阻塞过程中并不妨碍新任务的执行。当有新任务的时候，会先执行接收到的新任务，新任务执行完之后，如果时间到了，再继续执行runUntilDate:之后的代码；</li>
</ul>
<p><br></p>
<h4 id="取消">取消</h4><p>NSThread提供了一个取消的方法和一个属性：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@property (readonly, getter=isCancelled) <span class="function">BOOL cancelled <span class="title">NS_AVAILABLE</span><span class="params">(<span class="number">10</span>_5, <span class="number">2</span>_0)</span></span>;</span><br><span class="line">- (<span class="keyword">void</span>)<span class="function">cancel <span class="title">NS_AVAILABLE</span><span class="params">(<span class="number">10</span>_5, <span class="number">2</span>_0)</span></span>;</span><br></pre></td></tr></table></figure>
<p>这里 cancel 方法要注意：调用-cancel方法并不会立刻取消线程，它仅仅是将cancelled属性设置为YES。cancelled也仅仅是一个用于记录状态的属性。线程取消的功能需要我们在main函数中自己实现；<br><br>要实现取消的功能，我们需要自己在线程的main函数中定期检查isCancelled状态来判断线程是否需要退出，当isCancelled为YES的时候，需要手动退出。<br></p>
<h4 id="退出">退出</h4><p>-exit函数可以让线程立即退出。<br><br>停止方法会立即终止除主线程以外所有线程（无论是否在执行任务）并退出，需要在掌控所有线程状态的情况下调用此方法，否则可能会导致内存问题。<br></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">void</span>)<span class="built_in">exit</span>;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h4 id="主线程和当前线程">主线程和当前线程</h4><p>NSThread提供了非常方便的获取和判断主线程的API：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@property (readonly) <span class="function">BOOL isMainThread <span class="title">NS_AVAILABLE</span><span class="params">(<span class="number">10</span>_5, <span class="number">2</span>_0)</span></span>;</span><br><span class="line">+ (BOOL)<span class="function">isMainThread <span class="title">NS_AVAILABLE</span><span class="params">(<span class="number">10</span>_5, <span class="number">2</span>_0)</span></span>; <span class="comment">// reports whether current thread is main</span></span><br><span class="line">+ (NSThread *)<span class="function">mainThread <span class="title">NS_AVAILABLE</span><span class="params">(<span class="number">10</span>_5, <span class="number">2</span>_0)</span></span>;</span><br></pre></td></tr></table></figure>
<p>获取当前线程：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">+ </span>(NSThread *)currentThread;</span><br></pre></td></tr></table></figure>
<p>是否为多线程：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ <span class="list">(<span class="keyword">BOOL</span>)</span>isMultiThreaded<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>关于isMultiThreaded 苹果在这里作了解释(相信你能看懂 😜😜😜)：</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Return</span> <span class="type">Value</span></span><br><span class="line"><span class="type">YES</span> <span class="keyword">if</span> the application <span class="keyword">is</span> multithreaded, <span class="type">NO</span> otherwise.</span><br><span class="line"></span><br><span class="line"><span class="type">Discussion</span></span><br><span class="line"><span class="type">An</span> application <span class="keyword">is</span> considered multithreaded <span class="keyword">if</span> a thread was ever detached <span class="keyword">from</span> the main thread <span class="keyword">using</span> either detachNewThreadSelector:toTarget:withObject: <span class="keyword">or</span> start. <span class="type">If</span> you detached a thread <span class="keyword">in</span> your application <span class="keyword">using</span> a non-<span class="type">Cocoa</span> <span class="type">API</span>, such <span class="keyword">as</span> the <span class="type">POSIX</span> <span class="keyword">or</span> <span class="type">Multiprocessing</span> <span class="type">Services</span> <span class="type">APIs</span>, this <span class="keyword">method</span> could still <span class="keyword">return</span> <span class="type">NO</span>. <span class="type">The</span> detached thread does <span class="keyword">not</span> have to be currently running <span class="keyword">for</span> the application to be considered multithreaded—this <span class="keyword">method</span> only indicates whether a single thread has been spawned.</span><br></pre></td></tr></table></figure>
<p><br></p>
<h4 id="线程优先级">线程优先级</h4><p>NSThread有4个优先级的API：</p>
<p>这两个用于设置和获取当前线程的优先级：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="tag">double</span>)<span class="tag">threadPriority</span>;</span><br><span class="line">+ (<span class="tag">BOOL</span>)<span class="rule"><span class="attribute">setThreadPriority</span>:<span class="value">(double)p</span></span>;</span><br></pre></td></tr></table></figure>
<p>后两个通过对象设置和获取优先级：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@<span class="function">property <span class="keyword">double</span> threadPriority <span class="title">NS_AVAILABLE</span><span class="params">(<span class="number">10</span>_6, <span class="number">4</span>_0)</span></span>; <span class="comment">// To be deprecated; use qualityOfService below</span></span><br><span class="line">@<span class="function">property NSQualityOfService qualityOfService <span class="title">NS_AVAILABLE</span><span class="params">(<span class="number">10</span>_10, <span class="number">8</span>_0)</span></span>; <span class="comment">// read-only after the thread is started</span></span><br></pre></td></tr></table></figure>
<p>在iOS 8 之前：</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">[NSThread setThreadPriority:1.0]</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>这个方法的优先级的数值设置让人困惑，因为你不知道你应该设置多大的值是比较合适的，因此在iOS8之后，threadPriority添加了一句注释：To be deprecated; use qualityOfService below <br><br>意为iOS 8以后推荐使用qualityOfService属性：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSInteger</span>, <span class="built_in">NSQualityOfService</span>) &#123;</span><br><span class="line">    <span class="built_in">NSQualityOfServiceUserInteractive</span> = <span class="number">0x21</span>, 最高优先级，用于用户交互事件</span><br><span class="line">    <span class="built_in">NSQualityOfServiceUserInitiated</span> = <span class="number">0x19</span>,   次高优先级，用于用户需要马上执行的事件</span><br><span class="line">    <span class="built_in">NSQualityOfServiceUtility</span> = <span class="number">0x11</span>,         普通优先级，用于普通任务       </span><br><span class="line">    <span class="built_in">NSQualityOfServiceBackground</span> = <span class="number">0x09</span>,      最低优先级，用于不重要的任务</span><br><span class="line">    <span class="built_in">NSQualityOfServiceDefault</span> = -<span class="number">1</span>            默认优先级，主线程和没有设置优先级的线程都默认为这个优先级</span><br><span class="line">&#125; <span class="built_in">NS_ENUM_AVAILABLE</span>(<span class="number">10</span>_10, <span class="number">8</span>_0);</span><br></pre></td></tr></table></figure>
<p>比如给线程设置次高优先级：</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">[newThread setQualityOfService:NSQualityOfServiceUserInitiated]</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p><br></p>
<h4 id="线程通讯">线程通讯</h4><p>创建线程之后，经常需要从主线程把耗时的任务丢给辅助线程，当任务完成之后辅助线程再把结果传回主线程传，这些线程通讯一般用的都是perform方法：</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)performSelectorOnMainThread:(<span class="type">SEL</span>)aSelector withObject:(nullable id)arg waitUntilDone:(<span class="type">BOOL</span>)wait modes:(nullable <span class="type">NSArray</span>&lt;<span class="type">NSString</span> *&gt; *)<span class="type">array</span>;</span><br><span class="line">- (<span class="type">void</span>)performSelectorOnMainThread:(<span class="type">SEL</span>)aSelector withObject:(nullable id)arg waitUntilDone:(<span class="type">BOOL</span>)wait;</span><br><span class="line">	// equivalent to the first <span class="keyword">method</span> <span class="keyword">with</span> kCFRunLoopCommonModes</span><br><span class="line">- (<span class="type">void</span>)performSelector:(<span class="type">SEL</span>)aSelector onThread:(<span class="type">NSThread</span> *)thr withObject:(nullable id)arg waitUntilDone:(<span class="type">BOOL</span>)wait modes:(nullable <span class="type">NSArray</span>&lt;<span class="type">NSString</span> *&gt; *)<span class="type">array</span> <span class="type">NS_AVAILABLE</span>(<span class="number">10_5</span>, <span class="number">2_0</span>);</span><br><span class="line">- (<span class="type">void</span>)performSelector:(<span class="type">SEL</span>)aSelector onThread:(<span class="type">NSThread</span> *)thr withObject:(nullable id)arg waitUntilDone:(<span class="type">BOOL</span>)wait <span class="type">NS_AVAILABLE</span>(<span class="number">10_5</span>, <span class="number">2_0</span>);</span><br><span class="line">	// equivalent to the first <span class="keyword">method</span> <span class="keyword">with</span> kCFRunLoopCommonModes</span><br></pre></td></tr></table></figure>
<p>①：将selector丢给主线程执行，可以指定runloop mode<br><br>②：将selector丢给主线程执行，runloop mode默认为common mode<br><br>③：将selector丢个指定线程执行，可以指定runloop mode<br><br>④：将selector丢个指定线程执行，runloop mode默认为default mode<br><br>一般用③④方法将任务丢给辅助线程，任务执行完成之后再使用①②方法将结果传回主线程<br><br>注意：perform方法只对拥有runloop的线程有效，如果创建的线程没有添加runloop，perform的selector将无法执行。<br><br><br></p>
<h4 id="线程通知">线程通知</h4><p>NSThread有三个线程相关的通知:</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FOUNDATION_EXPORT <span class="built_in">NSString</span> * <span class="keyword">const</span> <span class="built_in">NSWillBecomeMultiThreadedNotification</span>;</span><br><span class="line">FOUNDATION_EXPORT <span class="built_in">NSString</span> * <span class="keyword">const</span> <span class="built_in">NSDidBecomeSingleThreadedNotification</span>;</span><br><span class="line">FOUNDATION_EXPORT <span class="built_in">NSString</span> * <span class="keyword">const</span> <span class="built_in">NSThreadWillExitNotification</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>NSWillBecomeMultiThreadedNotification：由当前线程派生出第一个其他线程时发送；</li>
<li>NSDidBecomeSingleThreadedNotification：暂时不知道；</li>
<li>NSThreadWillExitNotification：线程退出时发送；</li>
</ul>
<p><br></p>
<h4 id="NSThread的简单使用">NSThread的简单使用</h4><p>NSThread 创建还是很简单的：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSThread</span> *thread = [[<span class="built_in">NSThread</span> alloc] initWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(threadAction) object:<span class="literal">nil</span>];</span><br><span class="line">thread<span class="variable">.name</span> = <span class="string">@"com.myCreate.www"</span>;</span><br><span class="line">[thread start];</span><br></pre></td></tr></table></figure>
<p>在线程启动之后会首先执行-threadAction，正常情况下threadAction方法执行结束之后，线程就会退出。为了线程可以长期复用接收消息，我们需要给线程加上runLoop</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)threadAction</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"当前线程：%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    <span class="built_in">NSRunLoop</span> *runLoop = [<span class="built_in">NSRunLoop</span> currentRunLoop];</span><br><span class="line">    [runLoop addPort:[<span class="built_in">NSMachPort</span> port] forMode:<span class="built_in">NSDefaultRunLoopMode</span>];</span><br><span class="line">    <span class="keyword">while</span> (![[<span class="built_in">NSThread</span> currentThread] isCancelled]) &#123;</span><br><span class="line">        [runLoop runMode:<span class="built_in">NSDefaultRunLoopMode</span> beforeDate:[<span class="built_in">NSDate</span> dateWithTimeIntervalSinceNow:<span class="number">10</span>]];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>自定义的线程默认是没有runloop的，调用-currentRunLoop，方法内部会为线程创建runloop；</li>
<li>如果没有数据源，runloop会在启动之后会立刻退出。所以需要给runloop添加一个数据源，这里添加的是NSPort数据源；</li>
<li>定期检查isCancelled，当外部调用-cancel方法将isCancelled置为YES的时候，线程可以退出；</li>
</ul>
<p><br></p>
<h4 id="结束线程">结束线程</h4><p>当我们想要结束线程的时候，我们可以使用CFRunLoopStop()配合-cancel来结束线程：</p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">[<span class="list">[<span class="keyword">NSThread</span> currentThread] cancel]<span class="comment">;</span></span><br><span class="line">CFRunLoopStop<span class="list">(<span class="keyword">CFRunLoopGetCurrent</span><span class="list">()</span>)</span><span class="comment">;</span></span></span></span><br></pre></td></tr></table></figure>
<p><br></p>
<h4 id="NSThread的一个小例子">NSThread的一个小例子</h4><p>这个例子很好的说明了NSThread使用时要注意些什么。<br><br>这个例子是：模拟售票<a href="http://www.jianshu.com/p/334bde6790be#" target="_blank" rel="external">这个例子来自这</a><br><br>情景：某演唱会门票发售，在广州和北京均开设窗口进行销售<br><br>下面是主要代码：新建两个线程<br></p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"***************售票开始****************"</span>);</span><br><span class="line"><span class="built_in">NSThread</span> *saleTicketsWindow_1 = [[<span class="built_in">NSThread</span> alloc] initWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(saleTicketsWindow_Action) object:<span class="literal">nil</span>];</span><br><span class="line">saleTicketsWindow_1<span class="variable">.name</span> = <span class="string">@"北京售票中心"</span>;</span><br><span class="line">[saleTicketsWindow_1 start];</span><br><span class="line">   </span><br><span class="line"><span class="built_in">NSThread</span> *saleTicketsWindow_2 = [[<span class="built_in">NSThread</span> alloc] initWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(saleTicketsWindow_Action) object:<span class="literal">nil</span>];</span><br><span class="line">saleTicketsWindow_2<span class="variable">.name</span> = <span class="string">@"广州售票中心"</span>;</span><br><span class="line">[saleTicketsWindow_2 start];</span><br></pre></td></tr></table></figure>
<p>开始执行售票<br></p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)saleTicketsWindow_Action</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (_ticketCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            _ticketCount --;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"剩余票数：%ld 窗口：%@"</span>, _ticketCount, [<span class="built_in">NSThread</span> currentThread]<span class="variable">.name</span>]);</span><br><span class="line">            [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">0.2</span>];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"***************售票完成****************"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">10</span> <span class="number">17</span>:<span class="number">54</span>:<span class="number">22.636</span> NSThreadTest[<span class="number">2323</span>:<span class="number">1382484</span>] 剩余票数：<span class="number">9</span> 窗口：广州售票中心</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">10</span> <span class="number">17</span>:<span class="number">54</span>:<span class="number">22.636</span> NSThreadTest[<span class="number">2323</span>:<span class="number">1382483</span>] 剩余票数：<span class="number">10</span> 窗口：北京售票中心</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">10</span> <span class="number">17</span>:<span class="number">54</span>:<span class="number">22.841</span> NSThreadTest[<span class="number">2323</span>:<span class="number">1382483</span>] 剩余票数：<span class="number">7</span> 窗口：北京售票中心</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">10</span> <span class="number">17</span>:<span class="number">54</span>:<span class="number">22.841</span> NSThreadTest[<span class="number">2323</span>:<span class="number">1382484</span>] 剩余票数：<span class="number">8</span> 窗口：广州售票中心</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">10</span> <span class="number">17</span>:<span class="number">54</span>:<span class="number">23.043</span> NSThreadTest[<span class="number">2323</span>:<span class="number">1382484</span>] 剩余票数：<span class="number">5</span> 窗口：广州售票中心</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">10</span> <span class="number">17</span>:<span class="number">54</span>:<span class="number">23.043</span> NSThreadTest[<span class="number">2323</span>:<span class="number">1382483</span>] 剩余票数：<span class="number">6</span> 窗口：北京售票中心</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">10</span> <span class="number">17</span>:<span class="number">54</span>:<span class="number">23.244</span> NSThreadTest[<span class="number">2323</span>:<span class="number">1382484</span>] 剩余票数：<span class="number">4</span> 窗口：广州售票中心</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">10</span> <span class="number">17</span>:<span class="number">54</span>:<span class="number">23.244</span> NSThreadTest[<span class="number">2323</span>:<span class="number">1382483</span>] 剩余票数：<span class="number">3</span> 窗口：北京售票中心</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">10</span> <span class="number">17</span>:<span class="number">54</span>:<span class="number">23.449</span> NSThreadTest[<span class="number">2323</span>:<span class="number">1382483</span>] 剩余票数：<span class="number">1</span> 窗口：北京售票中心</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">10</span> <span class="number">17</span>:<span class="number">54</span>:<span class="number">23.449</span> NSThreadTest[<span class="number">2323</span>:<span class="number">1382484</span>] 剩余票数：<span class="number">2</span> 窗口：广州售票中心</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">10</span> <span class="number">17</span>:<span class="number">54</span>:<span class="number">23.655</span> NSThreadTest[<span class="number">2323</span>:<span class="number">1382483</span>] 剩余票数：<span class="number">0</span> 窗口：北京售票中心</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">10</span> <span class="number">17</span>:<span class="number">54</span>:<span class="number">23.655</span> NSThreadTest[<span class="number">2323</span>:<span class="number">1382484</span>] ***************售票完成****************</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">10</span> <span class="number">17</span>:<span class="number">54</span>:<span class="number">23.656</span> NSThreadTest[<span class="number">2323</span>:<span class="number">1382484</span>] 线程退出了：广州售票中心</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">10</span> <span class="number">17</span>:<span class="number">54</span>:<span class="number">23.861</span> NSThreadTest[<span class="number">2323</span>:<span class="number">1382483</span>] ***************售票完成****************</span><br><span class="line"><span class="number">2016</span>-<span class="number">09</span>-<span class="number">10</span> <span class="number">17</span>:<span class="number">54</span>:<span class="number">23.861</span> NSThreadTest[<span class="number">2323</span>:<span class="number">1382483</span>] 线程退出了：北京售票中心</span><br></pre></td></tr></table></figure>
<p>可以看到，票的销售过程中出现了剩余数量错乱的情况，这就是线程同步问题。<br><br>售票是一个典型的需要线程同步的场景，由于售票渠道有很多，而票的资源是有限的，当多个渠道在短时间内卖出大量的票的时候，如果没有同步机制来管理票的数量，将会导致票的总数和售出票数对应不上的错误。<br></p>
<p>iOS实现线程加锁有几种方式，现在使用NSLock或@synchronized两种方式都可行<br></p>
<p>使用NSLock:<br></p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    [_lock lock];</span><br><span class="line">    <span class="keyword">if</span> (_ticketCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        _ticketCount --;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"剩余票数：%ld 窗口：%@"</span>, _ticketCount, [<span class="built_in">NSThread</span> currentThread]<span class="variable">.name</span>]);</span><br><span class="line">        [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">0.2</span>];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"***************售票完成****************"</span>);</span><br><span class="line">        [_lock unlock];</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    [_lock unlock];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用@synchronized:<br></p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">@synchronized</span>(<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (_ticketCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            _ticketCount --;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"剩余票数：%ld 窗口：%@"</span>, _ticketCount, [<span class="built_in">NSThread</span> currentThread]<span class="variable">.name</span>]);</span><br><span class="line">            [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">0.2</span>];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"***************售票完成****************"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="NSOperation">NSOperation</h3><p>NSOperation 只是一个抽象类，所以不能封装任务，因此，如果我们想要使用它来执行具体任务的话，就必须创建自己的子类或使用它的 2 个子类。分别是：NSInvocationOperation 和 NSBlockOperation 。创建一个 Operation 后，需要调用 start 方法来启动任务，它会 默认在当前队列同步执行。当然你也可以在中途取消一个任务，只需要调用其 cancel 方法即可。</p>
<h4 id="NSInvocationOperation">NSInvocationOperation</h4><p>下面是NSInvocationOperation的简单使用，可以看到 NSInvocationOperation 开始任务之后是在主线程执行任务的。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.创建对象</span></span><br><span class="line"><span class="built_in">NSInvocationOperation</span> *operation = [[<span class="built_in">NSInvocationOperation</span> alloc] initWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(invocationAction) object:<span class="literal">nil</span>];</span><br><span class="line"><span class="comment">//2.开始执行</span></span><br><span class="line">[operation start];</span><br><span class="line"><span class="comment">//3.结果</span></span><br><span class="line"><span class="comment">/*</span><br><span class="line"> 2016-05-06 05:53:43.219 NSOperationTest[5885:2491863] NSInvocationOperation --- &lt;NSThread: 0x7fa269c06dc0&gt;&#123;number = 1, name = main&#125;</span><br><span class="line"> 是在主线程</span><br><span class="line"> */</span></span><br></pre></td></tr></table></figure>
<h4 id="NSBlockOperation">NSBlockOperation</h4><p>NSBlockOperation 默认会在当前线程执行任务。但是 NSBlockOperation 还有一个方法：addExecutionBlock: ，通过这个方法可以给 Operation 添加多个执行 Block。这样 Operation 中的任务 会并发执行，它会 在主线程和其它的多个线程执行这些任务.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">NSBlockOperation *blockOperation = [NSBlockOperation blockOperationWithBlock:^&#123;</span><br><span class="line">    NSLog(@<span class="string">"NSBlockOperation --- %@"</span>, [NSThread currentThread]);</span><br><span class="line">&#125;];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    [blockOperation addExecutionBlock:^&#123;</span><br><span class="line">        NSLog(@<span class="string">"NSBlockOperation 第%d次：%@"</span>, i, [NSThread currentThread]);</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br><span class="line">[blockOperation start];</span><br><span class="line"></span><br><span class="line"> <span class="number">2016</span>-<span class="number">05</span>-<span class="number">06</span> <span class="number">05</span>:<span class="number">57</span>:<span class="number">46.227</span> NSBlockOperationTest[<span class="number">5921</span>:<span class="number">2510961</span>] NSBlockOperation --- &lt;NSThread: <span class="number">0x7fc4c0401af0</span>&gt;&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line"> </span><br><span class="line"> <span class="number">2016</span>-<span class="number">05</span>-<span class="number">06</span> <span class="number">06</span>:<span class="number">01</span>:<span class="number">25.939</span> NSBlockOperationTest[<span class="number">5939</span>:<span class="number">2525676</span>] NSBlockOperation 第<span class="number">2</span>次：&lt;NSThread: <span class="number">0x7fb6cbe04590</span>&gt;&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line"> <span class="number">2016</span>-<span class="number">05</span>-<span class="number">06</span> <span class="number">06</span>:<span class="number">01</span>:<span class="number">25.940</span> NSBlockOperationTest[<span class="number">5939</span>:<span class="number">2525676</span>] NSBlockOperation 第<span class="number">3</span>次：&lt;NSThread: <span class="number">0x7fb6cbe04590</span>&gt;&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line"> <span class="number">2016</span>-<span class="number">05</span>-<span class="number">06</span> <span class="number">06</span>:<span class="number">01</span>:<span class="number">25.940</span> NSBlockOperationTest[<span class="number">5939</span>:<span class="number">2525676</span>] NSBlockOperation 第<span class="number">4</span>次：&lt;NSThread: <span class="number">0x7fb6cbe04590</span>&gt;&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line"> <span class="number">2016</span>-<span class="number">05</span>-<span class="number">06</span> <span class="number">06</span>:<span class="number">01</span>:<span class="number">25.940</span> NSBlockOperationTest[<span class="number">5939</span>:<span class="number">2525717</span>] NSBlockOperation 第<span class="number">0</span>次：&lt;NSThread: <span class="number">0x7fb6cbf03040</span>&gt;&#123;number = <span class="number">2</span>, name = (null)&#125;</span><br><span class="line"> <span class="number">2016</span>-<span class="number">05</span>-<span class="number">06</span> <span class="number">06</span>:<span class="number">01</span>:<span class="number">25.940</span> NSBlockOperationTest[<span class="number">5939</span>:<span class="number">2525710</span>] NSBlockOperation 第<span class="number">1</span>次：&lt;NSThread: <span class="number">0x7fb6cbc3f6e0</span>&gt;&#123;number = <span class="number">3</span>, name = (null)&#125;</span><br></pre></td></tr></table></figure>
<p>注意：addExecutionBlock 方法必须在 start() 方法之前执行，否则就会报错：</p>
<figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Terminating app due <span class="keyword">to</span> uncaught exception <span class="attribute">'NSInvalidArgumentException</span>', reason: '*** -[NSBlockOperation addExecutionBlock:]: blocks cannot be added <span class="keyword">after</span> the operation has started executing <span class="keyword">or</span> finished'</span><br></pre></td></tr></table></figure>
<h4 id="NSOperationQueue">NSOperationQueue</h4><p>在 NSOperationQueue 中，任务不会在当前线程执行。当任务添加到队列，会自动调用任务的 start() 方法，所有任务是并行执行的。maxConcurrentOperationCount 可以设置最大任务并行数量，当设置为 1 时，在某种意义上就是串行了。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">    <span class="built_in">NSOperationQueue</span> *queue = [[<span class="built_in">NSOperationQueue</span> alloc] init];</span><br><span class="line">    <span class="built_in">NSBlockOperation</span> *blockOperation = [<span class="built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"NSBlockOperation --- %@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    &#125;];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        [blockOperation addExecutionBlock:^&#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"NSBlockOperation 第%d次：%@"</span>, i, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;</span><br><span class="line">    [queue addOperation:blockOperation];</span><br><span class="line">或者是：</span><br><span class="line">       [queue addOperationWithBlock:^&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"addOperationWithBlock 第%d次：%@"</span>, i, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">        &#125;</span><br><span class="line">        [[<span class="built_in">NSOperationQueue</span> mainQueue] addOperationWithBlock:^&#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"addOperationWithBlock %@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;];</span><br></pre></td></tr></table></figure>
<p>eg:NSOperation 有一个非常实用的功能，那就是添加依赖。比如有 3 个任务：A: 从服务器上下载一张图片，B：给这张图片加个水印，C：把图片返回给服务器。这时就可以用到依赖了:</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSBlockOperation</span> *operation1 = [<span class="built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class="line">       <span class="built_in">NSLog</span>(<span class="string">@"下载图片 --- %@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">   &#125;];</span><br><span class="line">   <span class="built_in">NSBlockOperation</span> *operation2 = [<span class="built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class="line">       <span class="built_in">NSLog</span>(<span class="string">@"打水印 --- %@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">   &#125;];</span><br><span class="line">   <span class="built_in">NSBlockOperation</span> *operation3 = [<span class="built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class="line">       <span class="built_in">NSLog</span>(<span class="string">@"上传图片 --- %@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">   &#125;];</span><br><span class="line">   [operation2 addDependency:operation1];</span><br><span class="line">   [operation3 addDependency:operation2];</span><br><span class="line">   <span class="built_in">NSOperationQueue</span> *operationQueue = [[<span class="built_in">NSOperationQueue</span> alloc] init];</span><br><span class="line">   [operationQueue addOperations:@[operation1,operation2,operation3] waitUntilFinished:<span class="literal">NO</span>];</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2016</span>-<span class="number">05</span>-<span class="number">06</span> <span class="number">06</span>:<span class="number">26</span>:<span class="number">12.732</span> NSOperationQueueTest[<span class="number">6061</span>:<span class="number">2650250</span>] 下载图片 --- &lt;NSThread: <span class="number">0x7fc589e1d740</span>&gt;&#123;number = <span class="number">3</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">05</span>-<span class="number">06</span> <span class="number">06</span>:<span class="number">26</span>:<span class="number">12.733</span> NSOperationQueueTest[<span class="number">6061</span>:<span class="number">2650257</span>] 打水印 --- &lt;NSThread: <span class="number">0x7fc589f01320</span>&gt;&#123;number = <span class="number">4</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2016</span>-<span class="number">05</span>-<span class="number">06</span> <span class="number">06</span>:<span class="number">26</span>:<span class="number">12.734</span> NSOperationQueueTest[<span class="number">6061</span>:<span class="number">2650257</span>] 上传图片 --- &lt;NSThread: <span class="number">0x7fc589f01320</span>&gt;&#123;number = <span class="number">4</span>, name = (null)&#125;</span><br></pre></td></tr></table></figure>
<p>注意：不能添加相互依赖，会死锁，比如 A依赖B，B依赖A。<br><br>     可以使用 removeDependency 来解除依赖关系。<br><br>     可以在不同的队列之间依赖，反正就是这个依赖是添加到任务身上的，和队列没关系。<br></p>
<p>另外还有以下方法：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSOperation</span></span><br><span class="line"><span class="built_in">BOOL</span> executing; <span class="comment">//判断任务是否正在执行</span></span><br><span class="line"><span class="built_in">BOOL</span> finished; <span class="comment">//判断任务是否完成</span></span><br><span class="line"><span class="keyword">void</span> (^completionBlock)(<span class="keyword">void</span>); <span class="comment">//用来设置完成后需要执行的操作</span></span><br><span class="line">- (<span class="keyword">void</span>)cancel; <span class="comment">//取消任务</span></span><br><span class="line">- (<span class="keyword">void</span>)waitUntilFinished; <span class="comment">//阻塞当前线程直到此任务执行完毕</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">NSOperationQueue</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">NSUInteger</span> operationCount; <span class="comment">//获取队列的任务数</span></span><br><span class="line">- (<span class="keyword">void</span>)cancelAllOperations; <span class="comment">//取消队列中所有的任务</span></span><br><span class="line">- (<span class="keyword">void</span>)waitUntilAllOperationsAreFinished; <span class="comment">//阻塞当前线程直到此队列中的所有任务执行完毕</span></span><br><span class="line">[queue setSuspended:<span class="literal">YES</span>]; <span class="comment">// 暂停queue</span></span><br><span class="line">[queue setSuspended:<span class="literal">NO</span>]; <span class="comment">// 继续queue</span></span><br></pre></td></tr></table></figure>
<h4 id="自定义Operation">自定义Operation</h4><p>请大家先自行研究，后面会补上！</p>
<hr>
<h3 id="GCD">GCD</h3><p>下一节 是 GCD…</p>
  
	</div>
		<footer class="article-footer clearfix">
<div class="article-catetags">


</div>



	<div class="article-share" id="share">
	
	  <div data-url="http://yoursite.com/2016/09/19/Multi-thread/" data-title="iOS多线程 | 二哥的博客" data-tsina="null" class="share clearfix">
	  </div>
	
	</div>


</footer>

   	       
	</article>
	
<nav class="article-nav clearfix">
 

<div class="next">
<a href="/2016/08/16/RegularExpression/"  title="iOS 正则表达式">
 <strong>下一篇：</strong><br/> 
 <span>iOS 正则表达式
</span>
</a>
</div>

</nav>

	
<section id="comments" class="comment">
	<div class="ds-thread" data-thread-key="2016/09/19/Multi-thread/" data-title="iOS多线程" data-url="http://yoursite.com/2016/09/19/Multi-thread/"></div>
</section>


</div>  
      <div class="openaside"><a class="navbutton" href="#" title="Show Sidebar"></a></div>

  <div id="toc" class="toc-aside">
  <strong class="toc-title">文章目录</strong>
 
 <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#iOS多线程"><span class="toc-number">1.</span> <span class="toc-text">iOS多线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#前言"><span class="toc-number">1.1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#基本概念"><span class="toc-number">1.2.</span> <span class="toc-text">基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#串行_和_并发"><span class="toc-number">1.2.1.</span> <span class="toc-text">串行 和 并发</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#同步_和_异步"><span class="toc-number">1.2.2.</span> <span class="toc-text">同步 和 异步</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#队列_和_线程"><span class="toc-number">1.2.3.</span> <span class="toc-text">队列 和 线程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#iOS中的几种多线程类型"><span class="toc-number">1.2.4.</span> <span class="toc-text">iOS中的几种多线程类型</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Pthreads"><span class="toc-number">1.3.</span> <span class="toc-text">Pthreads</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#NSThread"><span class="toc-number">1.4.</span> <span class="toc-text">NSThread</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#线程的创建"><span class="toc-number">1.4.1.</span> <span class="toc-text">线程的创建</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#线程操作"><span class="toc-number">1.4.2.</span> <span class="toc-text">线程操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#启动"><span class="toc-number">1.4.3.</span> <span class="toc-text">启动</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#睡眠"><span class="toc-number">1.4.4.</span> <span class="toc-text">睡眠</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#取消"><span class="toc-number">1.4.5.</span> <span class="toc-text">取消</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#退出"><span class="toc-number">1.4.6.</span> <span class="toc-text">退出</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#主线程和当前线程"><span class="toc-number">1.4.7.</span> <span class="toc-text">主线程和当前线程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#线程优先级"><span class="toc-number">1.4.8.</span> <span class="toc-text">线程优先级</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#线程通讯"><span class="toc-number">1.4.9.</span> <span class="toc-text">线程通讯</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#线程通知"><span class="toc-number">1.4.10.</span> <span class="toc-text">线程通知</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#NSThread的简单使用"><span class="toc-number">1.4.11.</span> <span class="toc-text">NSThread的简单使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#结束线程"><span class="toc-number">1.4.12.</span> <span class="toc-text">结束线程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#NSThread的一个小例子"><span class="toc-number">1.4.13.</span> <span class="toc-text">NSThread的一个小例子</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#NSOperation"><span class="toc-number">1.5.</span> <span class="toc-text">NSOperation</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#NSInvocationOperation"><span class="toc-number">1.5.1.</span> <span class="toc-text">NSInvocationOperation</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#NSBlockOperation"><span class="toc-number">1.5.2.</span> <span class="toc-text">NSBlockOperation</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#NSOperationQueue"><span class="toc-number">1.5.3.</span> <span class="toc-text">NSOperationQueue</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#自定义Operation"><span class="toc-number">1.5.4.</span> <span class="toc-text">自定义Operation</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GCD"><span class="toc-number">1.6.</span> <span class="toc-text">GCD</span></a></li></ol></li></ol>
 
  </div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="Hide Sidebar"></a></div>
<aside class="clearfix">

  

  

  <div class="linkslist">
  <p class="asidetitle">友情链接</p>
    <ul>
        
          <li>
            
            	<a href="http://blog.sina.com.cn/s/articlelist_2774672495_0_1.html" target="_blank" title="浪漫的zerlinda的博客">浪漫的zerlinda的博客</a>
            
          </li>
        
    </ul>
</div>

  <div class="weiboshow">
  <p class="asidetitle">微博</p>
    <iframe width="100%" height="119" class="share_self"  frameborder="0" scrolling="no" src="http://widget.weibo.com/weiboshow/index.php?language=&width=0&height=119&fansRow=2&ptype=1&speed=0&skin=9&isTitle=1&noborder=1&isWeibo=0&isFans=0&uid=null&verifier=&dpc=1"></iframe>
</div>


</aside>
</div>
    </div>
    <footer><div id="footer" >
	
	
	<div class="social-font" class="clearfix">
		
		<a href="http://weibo.com/2371405300" target="_blank" class="icon-weibo" title="微博"></a>
		
		
		<a href="https://github.com/https://github.com/xiaerfei" target="_blank" class="icon-github" title="github"></a>
		
		
		
		
		
		
		
		
		
	</div>
			
		

		<p class="copyright">
		Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/wuchong/jacman" target="_blank" title="Jacman">Jacman</a> © 2016 
		
		<a href="/about" target="_blank" title="夏二飞">夏二飞</a>
		
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/jquery.qrcode-0.12.0.min.js"></script>

<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
  
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else{
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
      
      $('#toc.toc-aside').css('display', 'none');
        
    }
  });
});
</script>

<script type="text/javascript">
$(document).ready(function(){ 
  var ai = $('.article-content>iframe'),
      ae = $('.article-content>embed'),
      t  = $('#toc'),
      ta = $('#toc.toc-aside'),
      o  = $('.openaside'),
      c  = $('.closeaside');
  if(ai.length>0){
    ai.wrap('<div class="video-container" />');
  };
  if(ae.length>0){
   ae.wrap('<div class="video-container" />');
  };
  c.click(function(){
    ta.css('display', 'block').addClass('fadeIn');
  });
  o.click(function(){
    ta.css('display', 'none');
  });
  $(window).scroll(function(){
    ta.css("top",Math.max(140,320-$(this).scrollTop()));
  });
});
</script>


<script type="text/javascript">
$(document).ready(function(){ 
  var $this = $('.share'),
      url = $this.attr('data-url'),
      encodedUrl = encodeURIComponent(url),
      title = $this.attr('data-title'),
      tsina = $this.attr('data-tsina'),
      description = $this.attr('description');
  var html = [
  '<div class="hoverqrcode clearfix"></div>',
  '<a class="overlay" id="qrcode"></a>',
  '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="article-share-facebook" target="_blank" title="Facebook"></a>',
  '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="article-share-twitter" target="_blank" title="Twitter"></a>',
  '<a href="#qrcode" class="article-share-qrcode" title="微信"></a>',
  '<a href="http://widget.renren.com/dialog/share?resourceUrl=' + encodedUrl + '&srcUrl=' + encodedUrl + '&title=' + title +'" class="article-share-renren" target="_blank" title="人人"></a>',
  '<a href="http://service.weibo.com/share/share.php?title='+title+'&url='+encodedUrl +'&ralateUid='+ tsina +'&searchPic=true&style=number' +'" class="article-share-weibo" target="_blank" title="微博"></a>',
  '<span title="Share to"></span>'
  ].join('');
  $this.append(html);

  $('.hoverqrcode').hide();

  var myWidth = 0;
  function updatehoverqrcode(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
    var qrsize = myWidth > 1024 ? 200:100;
    var options = {render: 'image', size: qrsize, fill: '#2ca6cb', text: url, radius: 0.5, quiet: 1};
    var p = $('.article-share-qrcode').position();
    $('.hoverqrcode').empty().css('width', qrsize).css('height', qrsize)
                          .css('left', p.left-qrsize/2+20).css('top', p.top-qrsize-10)
                          .qrcode(options);
  };
  $(window).resize(function(){
    $('.hoverqrcode').hide();
  });
  $('.article-share-qrcode').click(function(){
    updatehoverqrcode();
    $('.hoverqrcode').toggle();
  });
  $('.article-share-qrcode').hover(function(){}, function(){
      $('.hoverqrcode').hide();
  });
});   
</script>



<script type="text/javascript">
  var duoshuoQuery = {short_name:"xiaerfei"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
    || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
</script> 







<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
}); 
</script>



<!-- Analytics Begin -->



<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?e6d1f421bbc9962127a50488f9ed37d1";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>



<!-- Analytics End -->

<!-- Totop Begin -->

	<div id="totop">
	<a title="Back to Top"><img src="/img/scrollup.png"/></a>
	</div>
	<script src="/js/totop.js"></script>

<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->


<!-- MathJax End -->

<!-- Tiny_search Begin -->

<!-- Tiny_search End -->

  </body>
</html>
